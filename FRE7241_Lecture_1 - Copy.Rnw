% FRE7241_Lecture_1

% Define knitr options
% !Rnw weave = knitr
% Set global chunk options
<<knitr_setup,include=FALSE,cache=FALSE>>=
library(knitr)
opts_chunk$set(prompt=TRUE, tidy=FALSE, strip.white=FALSE, comment=NA, highlight=FALSE, message=FALSE, warning=FALSE, size='scriptsize', fig.width=4, fig.height=4)
options(width=60, dev='pdf')
thm <- knit_theme$get("acid")
knit_theme$set(thm)
@


% Define document options
\documentclass[10pt]{beamer}
\mode<presentation>
\usetheme{AnnArbor}
% \usecolortheme{whale}
% Uncover everything in a step-wise fashion
% \beamerdefaultoverlayspecification{<+->}
% amsmath package for math symbols
% \usepackage{amsmath}
\usepackage[latin1]{inputenc}
\usepackage{hyperref}
\usepackage{fancybox}
\usepackage{url}
\usepackage[backend=bibtex,style=alphabetic]{biblatex} % bibstyle=numeric
% \bibliographystyle{amsalpha} % doesn't work
\addbibresource{FRE6871_bib.bib}
% \addbibresource[location=remote]{http://www.citeulike.org/user/jerzyp}
\renewcommand\bibfont{\footnotesize}
\renewcommand{\pgfuseimage}[1]{\scalebox{0.75}{\includegraphics{#1}}} % scale bib icons
\setbeamertemplate{bibliography item}[text] % set bib icons
% \setbeamertemplate{bibliography item}{} % remove bib icons

% \usepackage{enumerate}
% \let\emph\textbf
% \let\alert\textbf
% Define colors for hyperlinks
\definecolor{links}{HTML}{2A1B81}
\hypersetup{colorlinks=true,linkcolor=,urlcolor=links}
% Make url text footnotesize
\renewcommand\UrlFont{\footnotesize}
% Make institute text italic and small
\setbeamerfont{institute}{size=\small,shape=\itshape,bg=red,fg=red}
\setbeamerfont{date}{size=\small}
\setbeamerfont{block title}{size=\normalsize} % shape=\itshape
\setbeamerfont{block body}{size=\footnotesize}


% Title page setup
\title[FRE7241 Lecture\#1]{FRE7241 Algorithmic Portfolio Management}
\subtitle{Lecture\#1, Fall 2014}
% \subject{Getting Started With R}
\institute[NYU Polytechnic]{NYU Polytechnic School of Engineering}
\titlegraphic{\includegraphics[scale=0.8]{engineering_long_color}}
\author[Jerzy Pawlowski]{Jerzy Pawlowski \texorpdfstring{(\textit{\color{blue}{\footnotesize{jp3900@nyu.edu}}})}{}}
% \email{jp3900@poly.edu}
\date{November 4, 2014}
% \date{\today}
% \pgfdeclareimage[height=0.5cm]{university-logo}{engineering_long_white}
% \logo{\pgfuseimage{engineering_long_white}}


%%%%%%%%%%%%%%%
\begin{document}


%%%%%%%%%%%%%%%
\maketitle


%%%%%%%%%%%%%%%
% \begin{frame}[t]{Outline}
% You might wish to add the option [pausesections]
%   \tableofcontents
% \end{frame}


%%%%%%%%%%%%%%%
\section{Introduction}


%%%%%%%%%%%%%%%
\subsection{About FRE7241 Algorithmic Portfolio Management}
\begin{frame}[t]{\subsecname}

\begin{block}{Course Description}
The course explores asset pricing and risk factor models, portfolio optimization, and active portfolio management strategies illustrated through examples in the \texttt{R} programming language.\\
The course teaches how to investigate and apply active portfolio management strategies using the \texttt{R} programming language.  
The aim will be to learn by doing and to learn through examples.
\end{block}
\pause

\begin{block}{Course Prerequisites}
No prior knowledge of the \texttt{R} language is required.  But students should have a familiarity with basic statistics, time series analysis, and with a procedural programming language.
\end{block}
\pause

\begin{block}{Grading}
Grading will be based on homework assignments and in-class tests.\\
Homeworks will be due two weeks after they're announced (unless stated otherwise).\\
To receive credit, all homework and test code should run directly in an \texttt{R} session.
\end{block}
\pause

\begin{block}{Teaching Assistant}
The TA is Dong Huang (\color{blue}{dh1716@nyu.edu})\\
All homeworks should be mailed to the TA.
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{FRE7241 Textbook}
\begin{frame}[t]{\subsecname}

\begin{block}{Course Slides}
The course will be mostly self-contained, using detailed course slides.\\
The course will also utilize data and tutorials which are freely available on the internet.
\end{block}
\pause

\begin{block}{Textbook}
  There will be no required textbook, but a recommended textbook is:\\
  \hskip1em\fullcite{rupperttexbook}\\
  You can also download for free:\\
  \hskip1em\url{http://cran.r-project.org/doc/contrib/Farnsworth-EconometricsInR.pdf}
\end{block}
\pause

\begin{block}{Supplementary Textbooks}
  \hskip1em\fullcite{kleibertexbook}\\
  \hskip1em\fullcite{website:kleiber}\\
  \hskip1em\fullcite{isltexbook}\\
  \hskip1em\fullcite{website:isl}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Other Required Course Materials}
\begin{frame}[t]{\subsecname}
\begin{block}{}
  \begin{itemize}[]
    \item Students will be required to install and use the \texttt{R} Interpreter and the \texttt{RStudio} Integrated Development Environment (\emph{IDE}) on their computers,
    \item Students will be required to become proficient with the \texttt{RStudio} IDE,
    \item Students are encouraged to bring their laptop computers to class and run the \texttt{R} Interpreter during the lecture,
  \end{itemize}
\end{block}

\end{frame}



%%%%%%%%%%%%%%%
\section{Getting Started With \texttt{R}}


%%%%%%%%%%%%%%%
\subsection{What is \texttt{R}?}
\begin{frame}[t]{\subsecname}
\vspace{-1em}
\begin{block}{}
\begin{columns}[T]
  \column{0.7\textwidth}
    \begin{itemize}
      \item Is an open-source software environment for statistical computing and graphics,
      \item Is an interpreted language,
      \item Is a functional language,
      \item Supports object-oriented programming with classes and methods,
      \item Is extended through user-created packages,
      \item Is written in \texttt{R} itself and in \texttt{C/C++}.
    \end{itemize}
    \hskip1em\url{http://www.r-project.org/}\\
    \hskip1em\url{http://en.wikipedia.org/wiki/R_(programming_language)}\\
%    \hskip1em\url{http://blog.revolutionanalytics.com/2011/08/what-language-is-r-written-in.html}\\
  \column{0.3\textwidth}
    \includegraphics[height=0.2\textwidth]{Rlogo.jpg}
\end{columns}
\end{block}
\pause

\begin{block}{}
\begin{columns}[T]
  \column{0.7\textwidth}
    The \texttt{R} software and its libraries are released under the GNU General Public License\\
    \hskip1em\url{http://www.r-project.org/Licenses}\\
  \column{0.3\textwidth}
    \includegraphics[height=0.2\textwidth]{GPLv3_Logo.png}
\end{columns}
\end{block}
\pause

\begin{block}{}
\begin{columns}[T]
  \column{0.7\textwidth}
    Many other \texttt{R} software are released under the Creative Commons Attribution-ShareAlike License\\
    \hskip1em\url{http://creativecommons.org}\\
  \column{0.3\textwidth}
    \includegraphics[height=0.1\textwidth]{CC_License.png}
\end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Installing \texttt{R} and \texttt{RStudio}}
\begin{frame}[t]{\subsecname}

\begin{block}{}
\begin{columns}[T]
  \column{0.7\textwidth}
    Download \texttt{R} Interpreter from \texttt{CRAN} (Comprehensive \texttt{R} Archive Network)\\
    \hskip1em\url{http://cran.r-project.org/}
    \vskip1ex
    Click on:\\
    \href{C:/Program Files/R/R-3.1.0/bin/x64/RGui.exe}{C:/Program Files/R/R-3.1.0/bin/x64/RGui.exe}\\
    to invoke the \texttt{RGui} interface,
  \column{0.3\textwidth}
    \includegraphics[height=0.2\textwidth]{Rlogo.jpg}
\end{columns}
\end{block}
\pause

\begin{block}{}
\begin{columns}[T]
  \column{0.7\textwidth}
    Download \texttt{RStudio} IDE (Integrated Development Environment)\\
    \hskip1em\url{http://www.rstudio.com/ide}\\
  \column{0.3\textwidth}
    \includegraphics[height=0.2\textwidth]{RStudio_logo.png}
\end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Using \texttt{RStudio}}
\begin{frame}[t]{\subsecname}

% Snapshot of \texttt{RStudio} GUI
\includegraphics[height=0.6\textwidth]{RStudio.png}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{\texttt{RStudio} Support}
\begin{frame}[t]{\subsecname}

\begin{block}{}
\texttt{RStudio} has extensive online help, Q\&A database, and documentation\\
\hskip1em\url{https://support.rstudio.com/hc/en-us}\\
\vskip1ex
\hskip1em\url{https://support.rstudio.com/hc/en-us/sections/200107586-Using-RStudio}\\
\vskip1ex
\hskip1em\url{https://support.rstudio.com/hc/en-us/sections/200148796-Advanced-Topics}\\
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Stack Exchange}
\begin{frame}[t]{\subsecname}

\begin{columns}[T]
  \column{0.5\textwidth}
    \begin{block}{Stack Exchange}
      Stack Exchange is a family of Q\&A forums in a variety of fields\\
      \hskip1em\url{http://stackexchange.com/}\\
      \hskip1em\url{http://stackexchange.com/sites\#technology}\\
      \hskip1em\url{http://quant.stackexchange.com/}\\
    \end{block}
    \begin{block}{Stack Overflow}
      Stack Overflow is a Q\&A forum for computer programming, and is part of Stack Exchange\\
%  Stack Overflow is a Q\&A forum for programmers (covers many different languages)\\
      \hskip1em\url{http://stackoverflow.com}\\
      \hskip1em\url{http://stackoverflow.com/questions/tagged/r}\\
      \hskip1em\url{http://stackoverflow.com/tags/r/info}\\
    \end{block}
  \column{0.5\textwidth}
    \includegraphics[height=0.9\textwidth]{stack_exchange2.png}
\end{columns}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Other \texttt{R} Online Help}
\begin{frame}[t]{\subsecname}

\begin{block}{\texttt{R}-help Mailing List}
  \texttt{R}-help is a very comprehensive Q\&A mailing list\\
  \hskip1em\url{https://stat.ethz.ch/mailman/listinfo/r-help}\\
  \texttt{R}-help has archives of past Q\&A - search it before you ask\\
  \hskip1em\url{https://stat.ethz.ch/pipermail/r-help/}\\
  GMANE allows searching the \texttt{R}-help archives using a usenet newsgroup style GUI\\
  \hskip1em\url{http://news.gmane.org/gmane.comp.lang.r.general}\\
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{\texttt{R} Blogs and Experts}
\begin{frame}[fragile,t]{\subsecname}

\begin{block}{R-Bloggers}
R-Bloggers is an aggregator of blogs dedicated to \texttt{R}\\
\hskip1em\url{http://www.r-bloggers.com/}\\
Tal Galili is the author of R-Bloggers and has his own excellent blog\\
\hskip1em\url{http://www.r-statistics.com/}\\
\end{block}
\pause

\begin{block}{Dirk Eddelbuettel}
Dirk is a $Top Answerer$ for \texttt{R} questions on Stackoverflow, the author of the \texttt{Rcpp} package, and the CRAN Finance View\\
\hskip1em\url{http://dirk.eddelbuettel.com/}\\
\hskip1em\url{http://dirk.eddelbuettel.com/code/}\\
\hskip1em\url{http://dirk.eddelbuettel.com/blog/}\\
\hskip1em\url{http://www.rinfinance.com/}\\
\end{block}
\pause

\begin{block}{Romain François}
Romain is an \texttt{R} Enthusiast and \texttt{Rcpp} Hero\\
\hskip1em\url{http://romainfrancois.blog.free.fr/}\\
\hskip1em\url{http://romainfrancois.blog.free.fr/index.php?tag/graphgallery}\\
\hskip1em\url{http://blog.r-enthusiasts.com/}\\
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\begin{frame}[fragile,t]{More \subsecname}

\begin{block}{Revolution Analytics Blog}
\texttt{R} blog by Revolution Analytics software vendor\\
\hskip1em\url{http://blog.revolutionanalytics.com/}\\
\end{block}
\pause

\begin{block}{\texttt{RStudio} Blog}
\texttt{R} blog by \texttt{RStudio}\\
\hskip1em\url{http://blog.rstudio.org/}\\
\end{block}

\end{frame}



%%%%%%%%%%%%%%%
\section{Probability and Statistics}


%%%%%%%%%%%%%%%
\subsection{Pseudo-Random Numbers}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.4\textwidth}
      Random number generators produce the same deterministic sequence of numbers after their \texttt{seed} value is reset,
      \vskip1ex
      The function \texttt{set.seed()} initializes the random number generator by specifying the \texttt{seed} value,
      \vskip1ex
      The function \texttt{runif()} produces random numbers from the uniform distribution,
      \vskip1ex
      The function \texttt{rnorm()} produces random numbers from the normal distribution,
      \vskip1ex
      The function \texttt{pnorm()} calculates the cumulative normal distribution,
      \vskip1ex
      The function \texttt{qnorm()} calculates the inverse cumulative normal distribution,
    \column{0.6\textwidth}
      \vspace{-1em}
        <<>>=
set.seed(1121)  # initialize the random number generator
runif(3)  # three random numbers from the uniform distribution
runif(3)  # produce another three numbers
set.seed(1121)  # re-initialize the random number generator
runif(3)  # produce another three numbers

# produce random number from standard normal distribution
rnorm(1)
# produce five random numbers from standard normal distribution
rnorm(5)
# produce five random numbers from the normal distribution
rnorm(n=5, mean=1, sd=2)  # match arguments by name
# calculate cumulative standard normal distribution
c(pnorm(-2), pnorm(2))
# calculate inverse cumulative standard normal distribution
c(qnorm(0.75), qnorm(0.25))
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Statistical Estimators}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.4\textwidth}
      A data \emph{sample} is a set of data selected from a statistical population (distribution),
      \vskip1ex
      Let $\{x_{1},\ldots ,x_{n}\}$ be a data \emph{sample} from a given distribution,
      \vskip1ex
      A \emph{statistic} is a function of a data \emph{sample}:  $f( x_{1},\ldots ,x_{n} )$,
      \vskip1ex
      A \emph{statistic} is itself a \emph{random variable},
      \vskip1ex
      A statistical \emph{estimator} is a \emph{statistic} that provides an estimate of a \emph{distribution} parameter,
      \vskip1ex
      For example:
      \begin{displaymath}
        \bar{x}=\frac{1}{n}{\sum_{i=1}^{n}x_{i}}
      \end{displaymath}
      Is an \emph{estimator} of the \emph{mean} of the \emph{distribution},
    \column{0.6\textwidth}
      \vspace{-1em}
      <<echo=3:30>>=
rm(list=ls())
set.seed(1121)  # initialize the random number generator
# sample from Standard Normal Distribution
rand_sample <- rnorm(1000)

mean(rand_sample)  # sample mean

median(rand_sample)  # sample median

sd(rand_sample)  # sample standard deviation
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Estimators of Moments}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.4\textwidth}
      The estimators of moments of a probability distribution are given by:
      \vskip1ex
      Mean: $\bar{x}=\frac{1}{k} \sum_{i=1}^{k} x_{i}$
      \vskip1ex
      Variance: $\hat{\sigma}^2=\frac{1}{k-1} \sum_{i=1}^{k} (x_{i}-\bar{x})^2$
      \vskip1ex
      Skewness:
      \begin{displaymath}
        \hat{s}=\frac{k}{(k-1)(k-2)} \sum_{i=1}^{k} (\frac{x_{i}-\bar{x}}{\hat{\sigma}})^3
      \end{displaymath}
      Kurtosis:
      \begin{displaymath}
        \hat{k}=\frac{k(k+1)}{(k-1)^3} \sum_{i=1}^{k} (\frac{x_{i}-\bar{x}}{\hat{\sigma}})^4
      \end{displaymath}
      The normal distribution has zero skewness and kurtosis equal to 3,
    \column{0.6\textwidth}
      \vspace{-1em}
        <<echo=2:30>>=
rm(list=ls())
ts_rets <- diff(log(EuStockMarkets[, 1]))  # DAX returns
len_rets <- length(ts_rets)  # number of observations
mean_rets <- mean(ts_rets)  # calculate mean
sd_rets <- sd(ts_rets)  # calculate standard deviation
# calculate skew
len_rets*(sum(((ts_rets - mean_rets)/sd_rets)^3))/
  ((len_rets-1)*(len_rets-2))
# calculate kurtosis
len_rets*(len_rets+1)*(sum(((ts_rets - mean_rets)/sd_rets)^4))/
  ((len_rets-1)^3)
ts_rets <- rnorm(len_rets, sd=2)  # random normal returns
mean_rets <- mean(ts_rets); sd_rets <- sd(ts_rets)
# calculate skew
len_rets*(sum(((ts_rets - mean_rets)/sd_rets)^3))/
  ((len_rets-1)*(len_rets-2))
# calculate kurtosis
len_rets*(len_rets+1)*(sum(((ts_rets - mean_rets)/sd_rets)^4))/
  ((len_rets-1)^3)
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Function for Calculating Moments}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.3\textwidth}
      \texttt{R} provides an easy way to write functions,
      \vskip1ex
      Function arguments can be matched by position or by name,
      \vskip1ex
      If the function arguments are missing then the default value is used,
      \vskip1ex
      Functions return the value of the last expression that is evaluated,
      \vskip1ex
      If a function name is called alone then \texttt{R} displays the function code,
    \column{0.7\textwidth}
      \vspace{-1em}
        <<>>=
ts_rets <- diff(log(EuStockMarkets[, 1]))  # DAX returns
# define function CalcSkew to calculate the skew
CalcSkew <- function(ts.data=rnorm(1000)) {  # default is normal
# Calculates the skew of a time series of returns.
  len_data <- length(ts.data)  # number of observations
  mean_rets <- mean(ts.data)
  sd_rets <- sd(ts.data)
# the last statement is what is returned
  len_data*sum(((ts.data - mean_rets)/sd_rets)^3)/((len_data-1)*(len_data-2))
}  # end CalcSkew
# calculate skewness of DAX returns
CalcSkew(ts.data=ts_rets)  # match arguments by name
CalcSkew(ts_rets)  # match arguments by position
CalcSkew()  # use default value of arguments
CalcSkew  # show the function code
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Normal Probability Distributions}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      Plots of several Normal distributions with different values of $\sigma,$
        <<norm_dist_mult,echo=3:30,fig.show='hide'>>=
rm(list=ls())
par(mar=c(7, 2, 1, 2), mgp=c(2, 1, 0), cex.lab=0.8, cex.axis=0.8, cex.main=0.8, cex.sub=0.5)
v.xval <- seq(-4, 4, length=100)
v.sigma <- c(0.5, 1, 1.5, 2)  # sigma values
# create plot colors
colors <- c("red", "black", "blue", "green")
# create legend labels
v.labels <- paste("sigma", v.sigma, sep='=')
# plot an empty chart
plot(v.xval, dnorm(v.xval, sd=v.sigma[1]), 
     type="n", xlab="", ylab="", 
     main="Normal Distributions")
# add lines to plot
for (in_dex in 1:4) {
  lines(v.xval, dnorm(v.xval, sd=v.sigma[in_dex]), 
        lwd=2, col=colors[in_dex])
}
# add legend
legend("topright", inset=0.05, title="Sigmas", 
       v.labels, cex=0.8, lwd=2, lty=c(1, 1, 1, 1), 
       col=colors)
      @
    \column{0.5\textwidth}
      \includegraphics[width=0.5\paperwidth,valign=t]{figure/norm_dist_mult-1}
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Chi-squared Distribution}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      Let $Z_{1},\ldots ,Z_{k}$ be independent standard normal random variables,
      \vskip1ex
      Let $X=\sum_{i=1}^{k}Z_{i}^{2}$, \hskip1em then $X\sim \chi _{k}^{2}$,
        <<chisq_dist_mult,echo=3:30,fig.show='hide'>>=
rm(list=ls())
par(mar=c(7, 2, 1, 2), mgp=c(2, 1, 0), cex.lab=0.8, cex.axis=0.8, cex.main=0.8, cex.sub=0.5)
v.xval <- seq(0, 20, length=100)
v.df <- c(2, 5, 8, 11)  # df values
# create plot colors
colors <- c("red", "black", "blue", "green")
# create legend labels
v.labels <- paste("df", v.df, sep='=')
# plot an empty chart
plot(v.xval, dchisq(v.xval, df=v.df[1]), 
     type="n", xlab="", ylab="", 
     main="Chi-squared Distributions")
# add lines to plot
for (in_dex in 1:4) {
  lines(v.xval, dchisq(v.xval, df=v.df[in_dex]), 
        lwd=2, col=colors[in_dex])
}
# add legend
legend("topright", inset=0.05, 
       title="Degrees of freedom", v.labels, 
       cex=0.8, lwd=2, lty=c(1, 1, 1, 1), 
       col=colors)
      @
    \column{0.5\textwidth}
      \includegraphics[width=0.5\paperwidth,valign=t]{figure/chisq_dist_mult-1}
      \vspace{-4em}
      $X$ is distributed according to the \emph{chi-squared} distribution with $k$ degrees of freedom, given by:
% \normalsize
      \begin{displaymath}
        P(x) = \frac{x^{k/2-1}\,e^{-x/2}}{2^{k/2}\, \Gamma(k/2)}
      \end{displaymath}
% \footnotesize
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Student's $t$-distribution}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      Let $Z_{1},\ldots ,Z_{k}$ be independent standard normal random variables,
      \vskip1ex
      Let $s^2=\sum_{i=1}^{\nu}Z_{i}^{2}$, \hskip1em $t=\frac{\sum_{i=1}^{\nu}Z_{i}}{s}$,
        <<t_dist_mult,echo=3:30,fig.show='hide'>>=
rm(list=ls())
par(mar=c(7, 2, 1, 2), mgp=c(2, 1, 0), cex.lab=0.8, cex.axis=0.8, cex.main=0.8, cex.sub=0.5)
v.xval <- seq(-5, 5, length=100)
v.df <- c(3, 6, 9)  # df values
# create plot colors
colors <- c("black", "red", "blue", "green")
# create legend labels
v.labels <- c('normal', paste("df", v.df, sep='='))
# plot chart of normal distribution
plot(v.xval, dnorm(v.xval), type="l", 
     lwd=2, xlab="", ylab="", 
     main="t-distributions")
# add lines to plot
for (in_dex in 1:3) {
  lines(v.xval, dt(v.xval, df=v.df[in_dex]), 
        lwd=2, col=colors[in_dex+1])
}
# add legend
legend("topright", inset=0.05, 
       title="Degrees\n of freedom", v.labels, 
       cex=0.8, lwd=2, lty=c(1, 1, 1, 1), 
       col=colors)
      @
    \column{0.5\textwidth}
      \includegraphics[width=0.5\paperwidth,valign=t]{figure/t_dist_mult-1}
      \vspace{-4em}
      $t$ is distributed according to the $t$-distribution with $\nu$ degrees of freedom, given by:
      \begin{displaymath}
        P(x) = \frac{\Gamma((\nu+1)/2)}{\sqrt{\pi \nu}\,\Gamma(\nu/2)}\, (1 + x^2/\nu)^{-(\nu+1)/2}
      \end{displaymath}
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Poisson Probability Distribution}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      The \emph{Poisson} distribution gives the probability of the number of events in intervals of space or time (the amount of mail received each day),
      \vskip1ex
      The Poisson probability function is given by:
      \begin{displaymath}
        P(k; \lambda) = \frac{{\lambda^k}{\cdot}{e^{-\lambda}}}{k!}
      \end{displaymath}
      The parameter $\lambda$ determines the average number of events per interval,
        \vspace{-1em}
        <<poiss_dist,echo=3:30,fig.show='hide'>>=
rm(list=ls())
par(mar=c(7, 2, 1, 2), mgp=c(2, 1, 0), cex.lab=0.8, cex.axis=0.8, cex.main=0.8, cex.sub=0.5)
poisson_events <- 0:11  # Poisson events
poisson_freq <- dpois(poisson_events, lambda=4)
names(poisson_freq) <- as.character(poisson_events)
poisson_freq
poisson_func <- function(x, lambda)  # Poisson function
                    {exp(-lambda)*lambda^x/factorial(x)}
curve(expr=poisson_func(x, lambda=4), xlim=c(0, 11), main="Poisson distribution",
      xlab="No. of events", ylab="Frequency of events", lwd=2, col="red")
legend(x="topright", legend="Poisson density", title="", 
       inset=0.05, cex=0.8, bg="white", lwd=4, lty=1, col="red")
      @
    \column{0.5\textwidth}
      \includegraphics[width=0.5\paperwidth,valign=t]{figure/poiss_dist-1}
  \end{columns}
\end{block}

\end{frame}



%%%%%%%%%%%%%%%
\section{Hypothesis Testing}


%%%%%%%%%%%%%%%
\subsection{Hypothesis Testing}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.45\textwidth}
      \emph{Hypothesis Testing} is designed to test the validity of a \emph{null hypothesis},
      \vskip1ex
      A \emph{Hypothesis Test} consists of:
      \begin{itemize}
        \item a \emph{null hypothesis},
        \item a  test \emph{statistic} (based on a sample),
        \item a \emph{significance level} $\alpha$, determining whether to accept or reject the \emph{null hypothesis},
        \item a \emph{p}-value (probability of observing the value of the test statistic, assuming the null hypothesis is \texttt{TRUE}),
      \end{itemize}
      If the \emph{p}-value is less than the \emph{significance level} $\alpha$, then the \emph{null hypothesis} is rejected,
      \vskip1ex
      The objective of \emph{Hypothesis Testing} is to invalidate the \emph{null hypothesis},
      \vskip1ex
      In statistics we cannot \emph{prove} that a hypothesis is \texttt{TRUE}; we can only conclude that it's very unlikely to be \texttt{FALSE},
    \column{0.55\textwidth}
      \vspace{-1em}
      <<>>=
### Perform two-tailed test that sample is 
### from Standard Normal Distribution (mean=0, SD=1)
# generate vector of samples and store in data frame
test_frame <- data.frame(samples=rnorm(1000))

# significance level, two-tailed test, critical value=2*SD
signif_level <- 2*(1-pnorm(2))
signif_level
# get p-values for all the samples
test_frame$p_values <- sapply(test_frame$samples, pnorm)
test_frame$p_values <- 2*(0.5-abs(test_frame$p_values-0.5))
# compare p_values to significance level
test_frame$result <- test_frame$p_values > signif_level
sum(!test_frame$result)  # number of null rejections
# show null rejections
head(test_frame[!test_frame$result, ])
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Visualizing Hypothesis Testing Using Package \texttt{ggplot2}}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      <<hyp_test_ggp2,echo=3:30,fig.show='hide'>>=
rm(list=ls())
par(oma=c(1, 1, 1, 1), mgp=c(2, 0.5, 0), mar=c(5, 1, 1, 1), cex.lab=0.8, cex.axis=0.8, cex.main=0.8, cex.sub=0.5)
library(ggplot2)  # load ggplot2

qplot(  # simple ggplot2
    main="Standard Normal Distribution", 
    c(-4, 4), 
    stat="function", 
    fun=dnorm, 
    geom="line", 
    xlab=NULL, ylab=NULL
    ) +  # end qplot

theme(  # modify plot theme
    plot.title=element_text(vjust=-1.0), 
    plot.background=element_blank()
    ) +  # end theme

geom_vline(  # add vertical line
  aes(xintercept=c(-2.0, 2.0)), 
  colour="red", 
  linetype="dashed"
  )  # end geom_vline
      @
    \column{0.5\textwidth}
      \hspace*{-1em}
      \includegraphics[width=0.5\paperwidth,valign=t]{figure/hyp_test_ggp2-1}
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Visualizing Hypothesis Testing Using \texttt{ggplot2} (cont.)}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      <<hyp_test_ggp2_2,echo=3:30,fig.show='hide'>>=
rm(list=ls())
par(oma=c(1, 1, 1, 1), mgp=c(2, 0.5, 0), mar=c(5, 1, 1, 1), cex.lab=0.8, cex.axis=0.8, cex.main=0.8, cex.sub=0.5)
### create ggplot2 with shaded area
x_var <- -400:400/100
norm_frame <- data.frame(x_var=x_var, 
                       d.norm=dnorm(x_var))
norm_frame$shade <- ifelse(
                  abs(norm_frame$x_var) >= 2, 
                  norm_frame$d.norm, NA)
ggplot(  # main function
  data=norm_frame, 
  mapping=aes(x=x_var, y=d.norm)
  ) +  # end ggplot
# plot line
  geom_line() + 
# plot shaded area
  geom_ribbon(aes(ymin=0, ymax=shade), fill="red") + 
# no axis labels
  xlab("") + ylab("") + 
# add title
  ggtitle("Standard Normal Distribution") +
# modify plot theme
  theme(
        plot.title=element_text(vjust=-1.0), 
        plot.background=element_blank()
  )  # end theme
      @
    \column{0.5\textwidth}
      \hspace*{-1em}
      \includegraphics[width=0.5\paperwidth,valign=t]{figure/hyp_test_ggp2_2-1}
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\section{Univariate Statistical Models}


%%%%%%%%%%%%%%%
\subsection{Shapiro-Wilk Test of Normality}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      The \emph{Shapiro-Wilk} test is designed to test the \emph{null hypothesis} that a sample: $\{x_{1},\ldots ,x_{n}\}$ is from a normally distributed population,
      \vskip1ex
      The test statistic is:
      \begin{displaymath}
        W= \frac {(\sum_{i=1}^{n} a_{i} x_{(i)})^2} {\sum_{i=1}^{n} (x_{i}-\bar{x})^2}
      \end{displaymath}
      Where the: $\{a_{1},\ldots ,a_{n}\}$ are proportional to the \emph{order statistics} of random variables from the normal distribution,
      \vskip1ex
      The \emph{k}-th \emph{order statistic} is equal to the \emph{k}-th smallest value,
      \vskip1ex
      The \emph{Shapiro-Wilk} statistic follows its own distribution, and is less than or equal to one,
      \vskip1ex
      The \emph{Shapiro-Wilk} statistic is close to one for samples from normal distributions,
      \vskip1ex
      The \emph{p}-value for DAX returns is extremely small, and we conclude that the \emph{null hypothesis} is \texttt{FALSE}, and the DAX returns are not from a normally distributed population,
    \column{0.5\textwidth}
      \vspace{-1em}
      <<>>=
# calculate DAX percentage returns
rets_dax <- diff(log(EuStockMarkets[, 1]))

# Shapiro-Wilk test for normal distribution
shapiro.test(rnorm(length(rets_dax)))

# Shapiro-Wilk test for DAX returns
shapiro.test(rets_dax)

# Shapiro-Wilk test for uniform distribution
shapiro.test(runif(length(rets_dax)))
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Jarque-Bera Test of Normality}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      The \emph{Jarque-Bera} test is designed to test the \emph{null hypothesis} that a sample: $\{x_{1},\ldots ,x_{n}\}$ is from a normally distributed population,
      \vskip1ex
      The test statistic is:
      \begin{displaymath}
        JB= \frac{n}{6} (\hat{s}^2 + \frac{1}{4} (\hat{k} - 3)^2)
      \end{displaymath}
      Where the skewness and kurtosis are defined as:
      \begin{align}{\notag}
        \hat{s} = \frac{1}{n} \sum_{i=1}^{n} (\frac{x_{i}-\bar{x}}{\hat{\sigma}})^3
      &&
        \hat{k} = \frac{1}{n} \sum_{i=1}^{n} (\frac{x_{i}-\bar{x}}{\hat{\sigma}})^4
      \end{align}
      The \emph{Jarque-Bera} statistic asymptotically follows the \emph{chi-squared} distribution with two degrees of freedom,
      \vskip1ex
      The \emph{Jarque-Bera} statistic is small for samples from normal distributions,
      \vskip1ex
      The \emph{p}-value for DAX returns is extremely small, and we conclude that the \emph{null hypothesis} is \texttt{FALSE}, and the DAX returns are not from a normally distributed population,
    \column{0.5\textwidth}
      \vspace{-1em}
      <<echo=2:30>>=
rets_dax <- diff(log(EuStockMarkets[, 1]))
library(tseries)  # load package tseries

# Jarque-Bera test for normal distribution
jarque.bera.test(rnorm(length(rets_dax)))

# Jarque-Bera test for DAX returns
jarque.bera.test(rets_dax)

# Jarque-Bera test for uniform distribution
jarque.bera.test(runif(length(rets_dax)))
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Autocorrelation Function}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      The \emph{Autocorrelation Function} is the correlation coefficient of a time series with its lagged values:
      \begin{displaymath}
        \rho_{k} = \frac{1}{\sigma^2} {\sum_{i=k+1}^{n} (x_{i}-\bar{x})(x_{i-k}-\bar{x})}
      \end{displaymath}
      The package \texttt{forecast} contains functions for univariate time series forecasting,
        <<eustx_acf,echo=4:30,fig.height=8,eval=TRUE,fig.show='hide'>>=
par(oma=c(15, 1, 1, 1), mgp=c(2, 0.5, 0), mar=c(1, 1, 1, 1), cex.lab=0.8, cex.axis=0.8, cex.main=0.8, cex.sub=0.5)
# calculate DAX percentage returns
rets_dax <- diff(log(EuStockMarkets[, 1]))
library(forecast)  # load forecast
par(mfrow=c(2,1))  # set plot panels
# autocorrelation from "stats"
acf(rets_dax, lag=5, xlab=NA)
# autocorrelation from "forecast"
Acf(rets_dax, lag=5, xlab=NA)
      @
      The horizontal dashed lines are the confidence intervals corresponding to the 95\% significance level,
      \vskip1ex
      The DAX time series does not have statistically significant autocorrelations,
    \column{0.5\textwidth}
      \vspace{-1em}
      \includegraphics[width=0.5\paperwidth,valign=t]{figure/eustx_acf-1}
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Filtering Time Series}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-2em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      <<dax_filter,echo=3:30,fig.show='hide'>>=
rm(list=ls())
library(zoo)  # load zoo
library(ggplot2)  # load ggplot2
library(gridExtra)  # load gridExtra
# coerce DAX time series to zoo
zoo.dax <- as.zoo(EuStockMarkets)[, 1]
index(zoo.dax) <-  # index to class 'Dates'
  as.Date(365*(index(zoo.dax)-1970))
# filter past values only (sides=1)
dax.filt <- filter(zoo.dax, 
                   filter=rep(1/5,5), sides=1)
dax.filt <- zoo(coredata(dax.filt), 
                order.by=index(zoo.dax))
dax.filt <- merge(zoo.dax, dax.filt)
dax.filt <- na.omit(dax.filt)
colnames(dax.filt) <- c("DAX", "DAX filtered")
dax.data <- window(dax.filt, 
                   start=as.Date("1997-01-01"), 
                   end=as.Date("1998-01-01"))
autoplot(  # plot ggplot2
    dax.data, main="Filtered DAX", facets=NULL
      ) +  # end autoplot
xlab("") + ylab("") +
theme(  # modify plot theme
    legend.position=c(0.1, 0.5), 
    plot.title=element_text(vjust=-2.0), 
    plot.margin=unit(c(-0.5, 0.0, -0.5, 0.0), "cm"), 
    plot.background=element_blank(),
    axis.text.y=element_blank()
    )  # end theme
# end ggplot2
      @
    \column{0.5\textwidth}
      \hspace*{-1em}
      \includegraphics[width=0.5\paperwidth,valign=t]{figure/dax_filter-1}
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Autocorrelation Function for Filtered Time Series}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      Filtering a time series creates spurious autocorrelations,
      <<dax_filter_acf,echo=2:30,fig.height=8,fig.show='hide'>>=
par(oma=c(15, 1, 1, 1), mgp=c(0, 0.5, 0), mar=c(1, 1, 1, 1), cex.lab=0.8, cex.axis=0.8, cex.main=0.8, cex.sub=0.5)
dax.diff <- na.omit(diff(log(dax.filt)))
par(mfrow=c(2,1))  # set plot panels
Acf(dax.diff[, 1], lag=20, xlab=NA, ylab=NA)
title(main="DAX", line=-1)
Acf(dax.diff[, 2], lag=20, xlab=NA, ylab=NA)
title(main="DAX filtered", line=-1)
      @
    \column{0.5\textwidth}
      \vspace{-2em}
      \includegraphics[width=0.5\paperwidth,valign=t]{figure/dax_filter_acf-1}
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Partial Autocorrelation Function}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      The \emph{partial autocorrelation} of lag $k$ is the autocorrelation after all the autocorrelations of lag $1,..., k-1$ have been removed,
        <<eustx_pacf,echo=2:30,fig.height=8,eval=TRUE,fig.show='hide'>>=
par(oma=c(15, 1, 1, 1), mgp=c(0, 0.5, 0), mar=c(1, 1, 1, 1), cex.lab=0.8, cex.axis=0.8, cex.main=0.8, cex.sub=0.5)
par(mfrow=c(2,1))  # set plot panels
# autocorrelation from "stats"
Acf(dax.diff[, 2], lag=20, xlab=NA, ylab=NA)
title(main="DAX filtered autocorrelations", line=-1)
# autocorrelation from "forecast"
Pacf(dax.diff[, 2], lag=20, xlab=NA, ylab=NA)
title(main="DAX filtered partial autocorrelations", 
      line=-1)
      @
    \column{0.5\textwidth}
      \vspace{-2em}
      \includegraphics[width=0.5\paperwidth,valign=t]{figure/eustx_pacf-1}
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Improved Autocorrelation Function}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      The function \texttt{acf()} from the base package \texttt{stats} returns the lag-zero autocorrelation,
      \vskip1ex
      We can easily create a wrapper function for \texttt{acf()} that omits the lag-zero autocorrelation,
      <<echo=7:30>>=
# calculate DAX percentage returns
rets_dax <- diff(log(EuStockMarkets[, 1]))
library(zoo)  # load zoo
library(ggplot2)  # load ggplot2
library(gridExtra)  # load gridExtra
library(forecast)  # load forecast
# autocorrelation from "stats"
acf.dax <- acf(rets_dax, plot=FALSE)
str(acf.dax)  # get the structure of the "acf" object
dim(acf.dax$acf)
dim(acf.dax$lag)
head(acf.dax$acf)
      @
    \column{0.5\textwidth}
      If a return value is wrapped in the function \texttt{invisible()} then it isn't printed automatically when the function is called,
      <<echo=1:30>>=
my.acf <- function (ts.data, xlab, 
                    ylab, main, ...)
# wrapper for base acf()
{
  acf.data <- acf(x=ts.data, plot=FALSE, ...)
  acf.data$acf <-  # remove first element
    array(data=acf.data$acf[-1], 
          dim=c(dim(acf.data$acf)[1]-1,1,1))
  acf.data$lag <-  # remove first element
    array(data=acf.data$lag[-1], 
          dim=c(dim(acf.data$lag)[1]-1,1,1))
  plot(acf.data, xlab=xlab, ylab=ylab, 
       main=main)
  return(invisible(acf.data))
}  # end my.acf
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{U.S. Macroeconomic Data}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      The package \texttt{Ecdat} contains the \texttt{Macrodat} U.S. macroeconomic data,
      \vskip1ex
      "\texttt{lhur}" is the unemployment rate (average of months in quarter),
      \vskip1ex
      "\texttt{fygm3}" 3 month treasury bill interest rate (last month in quarter)
      <<macro_data,echo=1:30,fig.show='hide'>>=
library(Ecdat)  # load Ecdat
colnames(Macrodat)  # United States Macroeconomic Time Series
zoo.macro <- as.zoo(  # coerce to "zoo"
          Macrodat[, c("lhur", "fygm3")])
colnames(zoo.macro) <- c("unemprate", "3mTbill")
# ggplot2 in multiple panes
autoplot(  # generic ggplot2 for "zoo"
  object=zoo.macro, main="US Macro",
  facets=Series ~ .
  ) + xlab("") + # end autoplot
theme(  # modify plot theme
  legend.position=c(0.1, 0.5),
  plot.title=element_text(vjust=-2.0),
  plot.margin=unit(c(-0.5, 0.0, -0.5, 0.0), "cm"),
  plot.background=element_blank(),
  axis.text.y=element_blank()
)  # end theme
      @
    \column{0.5\textwidth}
      \hspace*{-1em}
      \includegraphics[width=0.5\paperwidth,valign=t]{figure/macro_data-1}
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Autocorrelation in Macroeconomic Data}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      Many examples of economic data display a high degree of autocorrelation,
      <<macro_corr,echo=3:30,fig.height=8,fig.show='hide'>>=
par(oma=c(15, 1, 1, 1), mgp=c(0, 0.5, 0), mar=c(1, 1, 1, 1), cex.lab=0.8, cex.axis=0.8, cex.main=0.8, cex.sub=0.5)
par(mfrow=c(2,1))  # set plot panels
diff.macro <- na.omit(diff(zoo.macro))

acf.unemprate <- 
  my.acf(diff.macro[, "unemprate"], lag.max=10,
  xlab="", ylab="", main="")
title(main="average quarterly unemployment rate", 
      line=-1)

acf.3mTbill <- 
  my.acf(diff.macro[, "3mTbill"], lag.max=10,
  xlab="", ylab="", main="")
title(main="3 month T-bill EOQ", line=-1)
      @
    \column{0.5\textwidth}
      \vspace{-2em}
      \includegraphics[width=0.5\paperwidth,valign=t]{figure/macro_corr-1}
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Ljung-Box Test of Autocorrelation}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      The \emph{Ljung-Box} tests the \emph{null hypothesis} that autocorrelations are equal to zero,
      \vskip1ex
      The test statistic is:
      \begin{displaymath}
        Q = n(n+2) \sum_{k=1}^{maxlag} \frac{{\hat\rho}_{k}^2}{n-k}
      \end{displaymath}
      Where $n$ is the sample size, and the ${\hat\rho}_{k}$ are sample autocorrelations,
      \vskip1ex
      The \emph{Ljung-Box} statistic follows the \emph{chi-squared} distribution with \emph{maxlag} degrees of freedom,
      \vskip1ex
      The \emph{Ljung-Box} statistic is small for uncorrelated time series,
      \vskip1ex
      The \emph{p}-value for DAX returns is large, and we conclude that the \emph{null hypothesis} is \texttt{TRUE}, and the DAX returns are uncorrelated,
      \vskip1ex
      The \emph{p}-value for changes in macro data is extremely small, and we conclude that the \emph{null hypothesis} is \texttt{FALSE}, and the macro data are are autocorrelated,
    \column{0.5\textwidth}
      \vspace{-1em}
      <<echo=2:30>>=
# Ljung-Box test for DAX data
# 'lag' is the number of autocorrelation coefficients
Box.test(rets_dax, lag=10, type="Ljung")
# changes in unemployment rate are autocorrelated
Box.test(diff.macro[, "unemprate"], 
         lag=10, type="Ljung")
# changes in 3 month T-bill rate are autocorrelated
Box.test(diff.macro[, "3mTbill"], 
         lag=10, type="Ljung")
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Autoregressive Processes}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
      \column{0.5\textwidth}
        An \emph{autoregressive} time series process is defined by the formula:
        \begin{displaymath}
          x_{i} = c + {\varphi}_{1} x_{i-1} + {\varphi}_{2} x_{i-2} + \ldots + {\varphi}_{p} x_{i-p} + {\varepsilon}_{i}
        \end{displaymath}
        Where the ${\varepsilon}_{i}$ are independent random variables with zero mean and constant variance,
        \vskip1ex
        The function \texttt{arima.sim()} simulates an ARIMA process,
        \vspace{-1em}
      <<ar_process,echo=4:30,fig.height=7,fig.show='hide'>>=
# ARIMA processes
library(ggplot2)  # load ggplot2
library(gridExtra)  # load gridExtra
daily.index <- Sys.Date() + 0:999  # daily series over one year
zoo.ar <- zoo(  # AR time series of returns
  x=arima.sim(n=1000, model=list(ar=0.2)),
  order.by=daily.index)  # zoo.ar
zoo.ar <- cbind(zoo.ar, cumsum(zoo.ar))
colnames(zoo.ar) <- c("AR returns", "AR prices")
r1 <- range(zoo.ar[,1])
r2 <- range(zoo.ar[,2])
m.factor <- abs(r2[1]-r2[2])/abs(r1[1]-r1[2])
zoo.ar[,1] <- m.factor*zoo.ar[,1]
autoplot(object=zoo.ar, # plot AR returns
  main="Autoregressive process (phi=0.2)", 
  facets=Series ~ .) + xlab("") + ylab("") + 
theme(legend.position=c(0.1, 0.5), 
  plot.title=element_text(vjust=-2.0), 
  plot.margin=unit(c(-0.5, 0.0, -0.5, 0.0), "cm"), 
  plot.background=element_blank(),
  axis.text.y=element_blank())
      @
    \column{0.5\textwidth}
      \vspace{-1em}
      \hspace*{-1em}
      \includegraphics[width=0.5\paperwidth,valign=t]{figure/ar_process-1}
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Examples of Autoregressive Processes}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
      \column{0.5\textwidth}
      <<ar_param,echo=1:30,fig.height=7,fig.show='hide'>>=
v.phis <- c(0.01, 0.4, 0.8)  # AR coefficients
zoo.ar <- sapply(  # create three AR time series
  v.phis, function(phi)
          arima.sim(n=1000, model=list(ar=phi)))
zoo.ar <- zoo(x=zoo.ar, order.by=daily.index)
zoo.ar <- cumsum(zoo.ar)  # returns to prices
colnames(zoo.ar) <- paste("autocorr", v.phis)
r1 <- range(zoo.ar[,1])
r2 <- range(zoo.ar[,2])
r3 <- range(zoo.ar[,3])
m.factor <- abs(r3[1]-r3[2])/abs(r1[1]-r1[2])
zoo.ar[,1] <- m.factor*zoo.ar[,1]
m.factor <- abs(r3[1]-r3[2])/abs(r2[1]-r2[2])
zoo.ar[,2] <- m.factor*zoo.ar[,2]
autoplot(zoo.ar, main="AR prices", 
         facets=Series ~ .) + xlab("") + 
theme(legend.position=c(0.1, 0.5), 
  plot.title=element_text(vjust=-2.0), 
  plot.margin=unit(c(-0.5, 0.0, -0.5, 0.0), "cm"), 
  plot.background=element_blank(),
  axis.text.y=element_blank())
      @
    \column{0.5\textwidth}
      \vspace{-1em}
      \hspace*{-1em}
      \includegraphics[width=0.5\paperwidth,valign=t]{figure/ar_param-1}
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Autocorrelation in Autoregressive Processes}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      An \emph{autoregressive} process of order \emph{one} \emph{AR}(1) is defined by the formula:
      \begin{displaymath}
        x_{i} = c + {\varphi}_{1} x_{i-1} + {\varepsilon}_{i}
      \end{displaymath}
      An \emph{AR}(1) process has an exponentially declining ACF and a non-zero PACF at lag one,
      <<ar_acf,echo=3:30,fig.height=8,fig.show='hide'>>=
par(oma=c(15, 1, 1, 1), mgp=c(0, 0.5, 0), mar=c(1, 1, 1, 1), cex.lab=0.8, cex.axis=0.8, cex.main=0.8, cex.sub=0.5)
par(mfrow=c(2,1))  # set plot panels
# ACF of AR(1) process
my.acf(na.omit(diff(zoo.ar[, 3])), lag.max=10, 
       xlab="", ylab="", main="ACF of AR(1) process")

# PACF of AR(1) process
pacf(na.omit(diff(zoo.ar[, 3])), lag.max=10,
     xlab="", ylab="", main="PACF of AR(1) process")
      @
    \column{0.5\textwidth}
      \vspace{-1em}
      \hspace*{-1em}
      \includegraphics[width=0.5\paperwidth,valign=t]{figure/ar_acf-1}
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Identification of Autoregressive Processes}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      An \emph{AR}(3) process of order \emph{three} is defined by the formula:
      \begin{displaymath}
        x_{i} = c + {\varphi}_{1} x_{i-1} + {\varphi}_{2} x_{i-2} + {\varphi}_{3} x_{i-3} + {\varepsilon}_{i}
      \end{displaymath}
      Autoregressive processes \emph{AR}(n) of order \emph{n} have an exponentially declining ACF and a non-zero PACF up to lag \emph{n},
      <<ar_pacf,echo=3:30,fig.height=8,fig.show='hide'>>=
par(oma=c(15, 1, 1, 1), mgp=c(0, 0.5, 0), mar=c(1, 1, 1, 1), cex.lab=0.8, cex.axis=0.8, cex.main=0.8, cex.sub=0.5)
par(mfrow=c(2,1))  # set plot panels
zoo.ar3 <- zoo(  # AR(3) time series of returns
  x=arima.sim(n=1000, model=list(ar=c(0.1, 0.3, 0.1))),
  order.by=daily.index)  # zoo.ar
# ACF of AR(3) process
my.acf(zoo.ar3, lag.max=10, 
       xlab="", ylab="", main="ACF of AR(3) process")

# PACF of AR(3) process
pacf(zoo.ar3, lag.max=10,
     xlab="", ylab="", main="PACF of AR(3) process")
      @
    \column{0.5\textwidth}
      \vspace{-1em}
      \hspace*{-1em}
      \includegraphics[width=0.5\paperwidth,valign=t]{figure/ar_pacf-1}
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Fitting Autoregressive Models}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.4\textwidth}
      The function \texttt{arima()} from the base package \texttt{stats} fits a specified ARIMA model to a univariate time series,
      \vskip1ex
      The function \texttt{auto.arima()} from the package \texttt{forecast} automatically fits an ARIMA model to a univariate time series,
    \column{0.6\textwidth}
      \vspace{-1em}
      <<echo=1:30>>=
zoo.ar3 <- arima.sim(n=10000, 
            model=list(ar=c(0.1, 0.3, 0.1)))
arima(zoo.ar3, order = c(5,0,0))  # fit AR(5) model
auto.arima(zoo.ar3)  # fit ARIMA model
      @
  \end{columns}
\end{block}

\end{frame}



%%%%%%%%%%%%%%%
\section{Regression Analysis}


%%%%%%%%%%%%%%%
\subsection{Formula Objects}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.4\textwidth}
      Formulas in \texttt{R} are defined using the "\textasciitilde{}" operator followed by a series of terms separated by the "\texttt{+}" operator,
      \vskip1ex
      Formulas can be defined as separate objects, manipulated, and passed to functions,
      \vskip1ex
      For example the formula "\texttt{z} \textasciitilde{} \texttt{model}" means the response (independent) variable \texttt{z} is explained by the \texttt{model},
      \vskip1ex
      The formula "\texttt{z \textasciitilde{} x + y}" represents a linear model: \texttt{z = ax  + by + c},
      \vskip1ex
      If a vector or list is passed to \texttt{paste()}, together with a \texttt{collapse} string, then \texttt{paste()} concatenates the elements into a string, separated by the \texttt{collapse} string,
      \vskip1ex
      The formula "\texttt{y \textasciitilde{} x - 1}" or "\texttt{y \textasciitilde{} x + 0}" represents a linear model with zero intercept: $y = ax$,
      \vskip1ex
      The function \texttt{update()} modifies existing \texttt{formulas},
    \column{0.6\textwidth}
      \vspace{-1em}
      <<>>=
# formula of linear model with zero intercept
lin_formula <- z ~ x + y - 1
lin_formula

# collapsing a character vector into a text string
paste0("x", 1:5)
paste(paste0("x", 1:5), collapse="+")

# creating formula from text string
lin_formula <- as.formula(  # coerce text strings to formula
              paste("y ~ ", 
                paste(paste0("x", 1:5), collapse="+")
                )  # end paste
            )  # end as.formula
class(lin_formula)
lin_formula
# modify the formula using "update"
update(lin_formula, log(.) ~ . + beta)
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Simple Regression Example}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.4\textwidth}
      The function \texttt{lm()} from the base package \texttt{stats} fits a linear model (regression) into the data,
      \vskip1ex
      \texttt{lm()} returns an object of class \texttt{lm()}, which is a list containing the results of fitting the model,
      \vskip1ex
      The \texttt{lm()} list includes:
      \begin{itemize}
        \item call - the model formula,
        \item coefficients - the fitted model coefficients,
        \item residuals - the model residuals (response minus fitted values),
      \end{itemize}
    \column{0.6\textwidth}
      \vspace{-1em}
        <<echo=2:30>>=
set.seed(1121)  # initialize random number generator
indep_var <- 0.1*1:30  # define independent variable
# dependent variable equals linear form plus noise
depend_var <- 3 + 2*indep_var + rnorm(30)
# specify regression formula
reg_formula <- depend_var ~ indep_var
reg_model <- lm(reg_formula)  # perform regression
class(reg_model)  # regressions have class lm
attributes(reg_model)
eval(reg_model$call$formula)  # the regression formula
reg_model$coefficients  # the regression formula coefficients
coef(reg_model)
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Regression Summary}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.4\textwidth}
      The function \texttt{summary.lm()} produces a list of summary statistics for a regression model,
      \vskip1ex
      The \texttt{summary} list includes:
      \begin{itemize}
        \item coefficients: matrix with estimated coefficients, their \emph{t}-statistics, and \emph{p}-values,
        \item r.squared: fraction of response variance explained by the model,
        \item adj.r.squared: r.squared adjusted for higher model complexity,
        \item fstatistic: \emph{F}-statistic - ratio of variance explained by model divided by unexplained variance,
      \end{itemize}
    \column{0.6\textwidth}
      \vspace{-1em}
        <<>>=
reg_model_sum <- summary(reg_model)  # copy regression summary
reg_model_sum  # print the summary to console
attributes(reg_model_sum)$names  # get summary elements
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Interpreting the Regression Statistics}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.4\textwidth}
      The regression \texttt{summary} is a list, and its elements can be accessed individually,
      \vskip1ex
      The \emph{null} hypothesis is that the regression coefficients are \emph{zero},
      \vskip1ex
      A small \emph{p}-value is often interpreted as meaning that the coefficients are very unlikely to be zero (given the data),
      \vskip1ex
      The \emph{t}-statistic and the \emph{F}-statistic assume that the errors in the data are drawn from independent normal distributions,
      \vskip1ex
      But financial data is very far from normal, so the \emph{p}-values shouldn't be automatically interpreted as meaning that the coefficients are non-zero,
    \column{0.6\textwidth}
      \vspace{-1em}
        <<>>=
reg_model_sum$coefficients
reg_model_sum$r.squared
reg_model_sum$adj.r.squared
reg_model_sum$fstatistic
anova(reg_model)
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Plotting a Scatterplot}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.4\textwidth}
      Calling the generic function \texttt{plot()} on the regression formula produces a scatterplot of two-dimensional data,
      \vskip1ex
      Calling \texttt{abline()} on the regression model plots a straight line corresponding to the coefficients,
      \vskip1ex
        <<scatter_plot,echo=2:30,fig.show='hide'>>=
par(oma=c(1, 2, 1, 0), mgp=c(2, 1, 0), mar=c(5, 1, 1, 1), cex.lab=0.8, cex.axis=1.0, cex.main=0.8, cex.sub=0.5)
# plot scatterplot using formula
plot(reg_formula)
title(main="Simple Regression", line=-1)
# add reg line
abline(reg_model, col="red")
      @
    \column{0.6\textwidth}
      \includegraphics[width=0.5\paperwidth,valign=t]{figure/scatter_plot-1}
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Plotting Regression Objects}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.4\textwidth}
      \texttt{lm} objects have their own plot method, designed to plot diagnostic tests,
        <<plot_reg,echo=3:30,fig.show='hide'>>=
# set plot paramaters - margins and font scale
par(oma=c(1, 0, 1, 0), mgp=c(2, 1, 0), mar=c(2, 1, 2, 1), cex.lab=0.8, cex.axis=1.0, cex.main=0.8, cex.sub=0.5)
par(mfrow=c(2, 2))  # plot 2x2 panels
plot(reg_model)
      @
    \column{0.6\textwidth}
      \includegraphics[width=0.5\paperwidth,valign=t]{figure/plot_reg-1}
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Durbin-Watson Test of Autocorrelation of Regression Residuals}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      The \emph{Durbin-Watson} test is designed to test the \emph{null hypothesis} that the autocorrelations of regression residuals are equal to zero,
      \vskip1ex
      The test statistic is:
      \begin{displaymath}
        DW = \frac {\sum_{i=2}^{n} (\varepsilon_{i} - \varepsilon_{i-1})^2} {\sum_{i=1}^{n} \varepsilon_{i}^2}
      \end{displaymath}
      Where $\varepsilon_{i}$ are the regression residuals,
      \vskip1ex
      The value of the \emph{Durbin-Watson} statistic \emph{DW} is close to zero for large positive autocorrelations, and close to four for large negative autocorrelations,
      \vskip1ex
      The \emph{DW} is close to two for autocorrelations close to zero,
      \vskip1ex
      The \emph{p}-value for the \texttt{my\_reg} regression is large, and we conclude that the \emph{null hypothesis} is \texttt{TRUE}, and the regression residuals are uncorrelated,
    \column{0.5\textwidth}
      \vspace{-1em}
      <<echo=2:30>>=
# Durbin-Watson test for DAX data
library(lmtest)  # load lmtest

# perform Durbin-Watson test
dwtest(reg_model)
      @
  \end{columns}
\end{block}

\end{frame}




%%%%%%%%%%%%%%%
\section{Homework Assignment}


%%%%%%%%%%%%%%%
\subsection{Homework Assignment}
\begin{frame}[t]{\secname}
\vspace{-1em}
\begin{block}{Required}
  \begin{itemize}[]
    \item Install the \texttt{R} Interpreter and \texttt{RStudio},
    \item Write \texttt{R} code that performs the following:
    \begin{itemize}[]
      \item using the function \texttt{paste()} with a \texttt{collapse} string, create the character string "y = x1 + x2 + x3" from characters "x", "y", "=", "+", and the vector 1:3,
      \item create a numeric vector of length 15 containing random normal variates (rnorm),
      \item coerce the vector into a matrix of 5 rows and 3 columns,
      \item get the values of all the elements that are greater than 1.0,
      \item get the indices of all the elements that are greater than 1.0,
      \item calculate the mean and standard deviation of the 3rd row, and the 2nd column,
    \end{itemize}
  \end{itemize}
\end{block}
\pause

\begin{block}{Recommended}
  \begin{itemize}[]
    \item Read chapters 1-3: \fullcite{website:rintro}
    \item Read chapters 1-4: \citetitle{matlofftexbook}
    \item Read: \fullcite{website:googlestyler}
  \end{itemize}
\end{block}

\end{frame}


\end{document}
