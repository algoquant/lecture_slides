% FRE7241_Lecture3
% Define knitr options
% !Rnw weave=knitr
% Set global chunk options
<<knitr_setup,include=FALSE,cache=FALSE>>=
library(knitr)
opts_chunk$set(prompt=TRUE, eval=FALSE, tidy=FALSE, strip.white=FALSE, comment=NA, highlight=FALSE, message=FALSE, warning=FALSE, size="tiny", fig.width=4, fig.height=4)
options(width=80, dev="pdf")
options(digits=3)
thm <- knit_theme$get("acid")
knit_theme$set(thm)
@


% Define document options
\documentclass[9pt]{beamer}
\DeclareMathSizes{8pt}{6pt}{6pt}{5pt}
\mode<presentation>
\usetheme{AnnArbor}
% \usecolortheme{whale}
% Uncover everything in a step-wise fashion
% \beamerdefaultoverlayspecification{<+->}
% mathtools package for math symbols
\usepackage{tikz}
\usetikzlibrary{positioning}
\usepackage{array}
\usepackage{multirow}
\usepackage{mathtools}
\usepackage[latin1]{inputenc}
\usepackage{bbold}
% bbm package for unitary vector or matrix symbol
\usepackage{bbm}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{amsfonts}
\usepackage{hyperref}
\usepackage{fancybox}
\usepackage{url}
\usepackage[backend=bibtex,style=alphabetic]{biblatex} % bibstyle=numeric
\usepackage{listings}
\usepackage{xcolor}
\definecolor{anti_flashwhite}{rgb}{0.95, 0.95, 0.96}
% \bibliographystyle{amsalpha} % doesn't work
\addbibresource{FRE_lectures.bib}
% \addbibresource[location=remote]{http://www.citeulike.org/user/jerzyp}
\renewcommand\bibfont{\footnotesize}
\renewcommand{\pgfuseimage}[1]{\scalebox{0.75}{\includegraphics{#1}}} % scale bib icons
\setbeamertemplate{bibliography item}[text] % set bib icons
% \setbeamertemplate{bibliography item}{} % remove bib icons

% \usepackage{enumerate}
% \let\emph\textbf
% \let\alert\textbf
% Define colors for hyperlinks
\definecolor{links}{HTML}{2A1B81}
\hypersetup{colorlinks=true,linkcolor=,urlcolor=links}
% Make url text scriptsize
\renewcommand\UrlFont{\scriptsize}
% Make institute text italic and small
\setbeamerfont{institute}{size=\small,shape=\itshape}
\setbeamerfont{date}{size=\small}
\setbeamerfont{block title}{size=\normalsize} % shape=\itshape
\setbeamerfont{block body}{size=\footnotesize}


% Title page setup
\title[FRE7241 Lecture\#3]{FRE7241 Algorithmic Portfolio Management}
\subtitle{Lecture\#3, Spring 2022}

\institute[NYU Tandon]{NYU Tandon School of Engineering}
\titlegraphic{\includegraphics[scale=0.2]{image/tandon_long_color.png}}
\author[Jerzy Pawlowski]{Jerzy Pawlowski \emph{\href{mailto:jp3900@nyu.edu}{jp3900@nyu.edu}}}
% \email{jp3900@nyu.edu}
\date{April 12, 2022}
% \date{\today}
% \pgfdeclareimage[height=0.5cm]{university-logo}{engineering_long_white}
% \logo{\pgfuseimage{engineering_long_white}}


%%%%%%%%%%%%%%%
\begin{document}


%%%%%%%%%%%%%%%
\maketitle


%%%%%%%%%%%%%%%
\section{Stock Selection Strategies}


%%%%%%%%%%%%%%%
\subsection{Random Stock Selection}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      A random portfolio is a sub-portfolio of stocks selected at random.
      \vskip1ex
      Random portfolios are used as a benchmark for stock pickers (portfolio managers).
      \vskip1ex
      If a portfolio manager outperforms the median of random portfolios, then they may have stock picking skill.
      <<echo=TRUE,eval=FALSE>>=
# Load the S&P500 stock prices
library(rutils)
load("/Users/jerzy/Develop/lecture_slides/data/sp500_prices.RData")
# Subset (select) the prices after the start date of VTI
vti <- quantmod::Cl(rutils::etfenv$VTI)
vti <- rutils::diffit(vti)/rutils::lagit(vti, lagg=1, pad_zeros=FALSE)
colnames(vti) <- "VTI"
startd <- start(vti)
prices <- prices[startd <= zoo::index(prices)]
# Copy over NA prices using the function zoo::na.locf().
sum(is.na(prices))
prices <- zoo::na.locf(prices, na.rm=FALSE)
prices <- prices[, !is.na(prices[1, ])]
sum(is.na(prices))
dates <- zoo::index(prices)
vti <- vti[dates]
nrows <- NROW(prices)
ncols <- NCOL(prices)
# Normalize the prices so that they start at 1
pricesn <- lapply(prices, function(x) x/as.numeric(x[1]))
pricesn <- rutils::do_call(cbind, pricesn)
head(pricesn[, 1:5])
      @
    \column{0.5\textwidth}
      \vspace{-1em}
      \includegraphics[width=0.4\paperwidth]{figure/portf_random.png}
      <<echo=TRUE,eval=FALSE>>=
# Calculate the equal dollar-weighted average of all stock prices
indeks <- rowMeans(pricesn)
indeks <- xts::xts(indeks, order.by=dates)
colnames(indeks) <- "Index"
# Select a random, equal dollar-weighted portfolio of 5 stocks
nstocks <- 5
set.seed(1121)
samplev <- sample.int(n=ncols, size=nstocks, replace=FALSE)
portf <- pricesn[, samplev]
portf <- rowMeans(portf)
portf <- xts::xts(portf, order.by=dates)
colnames(portf) <- "Random"
# Plot dygraph of stock index and random portfolio
wealth <- cbind(indeks, portf)
colors <- c("blue", "red")
dygraphs::dygraph(wealth, main="Stock Index and Random Portfolio") %>%
  dyOptions(colors=colors, strokeWidth=2) %>%
  dyLegend(show="always", width=500)
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Random Stock Portfolios}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      Most random portfolios underperform the index, so picking a portfolio which outperforms the stock index requires great skill.
      \vskip1ex
      An investor without skill, who selects stocks at random, has a high probability of underperforming the index, because they will most likely miss selecting the best performing stocks.
      \vskip1ex
      Therefore the proper benchmark for a stock picker is the median of random portfolios, not the stock index, which is the mean of all the stock prices.
      \vskip1ex
      Performing as well as the index requires \emph{significant} investment skill, while outperforming the index requires \emph{exceptional} investment skill.
      <<echo=TRUE,eval=FALSE>>=
# Select 10 random equal dollar-weighted sub-portfolios
set.seed(1121)
nportf <- 10
portfs <- sapply(1:nportf, function(x) {
  prices <- pricesn[, sample.int(n=ncols, size=nstocks, replace=FALSE)]
  rowMeans(prices)
})  # end sapply
portfs <- xts::xts(portfs, order.by=dates)
colnames(portfs) <- paste0("portf", 1:nportf)
round(head(portfs[, 1:4]), 3)
round(tail(portfs[, 1:4]), 3)
      @
    \column{0.5\textwidth}
      \vspace{-1em}
      \includegraphics[width=0.4\paperwidth]{figure/portf_randomm.png}
      <<echo=TRUE,eval=FALSE>>=
# Plot dygraph of stock index and random portfolios
colors <- colorRampPalette(c("red", "blue"))(nportf)
colors <- colors[order(order(portfs[NROW(portfs), ]))]
combined <- cbind(indeks, portfs)
colnames(combined)[1] <- "Index"
colnamev <- colnames(combined)
colors <- c("green", colors)
dygraphs::dygraph(combined, main="Stock Index and Random Portfolios") %>%
  dyOptions(colors=colors, strokeWidth=1) %>%
  dySeries(name=colnamev[1], axis="y", label=colnamev[1], strokeWidth=3, col="green") %>%
  dyLegend(show="always", width=500)
      @
  \end{columns}
\end{block}

\end{frame}



%%%%%%%%%%%%%%%
\section{Momentum Strategies}

%%%%%%%%%%%%%%%
\subsection{Stock Portfolio Selection Out-of-Sample}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      The strategy selects the \texttt{10} best performing stocks from the in-sample interval, and invests equal dollar amounts in the out-of-sample interval.
      \vskip1ex
      The out-of-sample performance of the best performing stocks in-sample, is not any better than the index.
      <<echo=TRUE,eval=FALSE>>=
# Define in-sample and out-of-sample intervals
cutoff <- nrows %/% 2
dates[cutoff]
# Calculate the 10 best performing stocks in-sample
perfstat <- sort(drop(coredata(pricesn[cutoff, ])), decreasing=TRUE)
symbolv <- names(head(perfstat, 10))
# Calculate the in-sample portfolio
pricis <- pricesn[1:cutoff, symbolv]
# Normalize the prices so that they are 1 at cutoff+1
pricesn <- lapply(prices, function(x) x/as.numeric(x[cutoff+1]))
pricesn <- rutils::do_call(cbind, pricesn)
# Calculate the out-of-sample portfolio
pricos <- pricesn[(cutoff+1):nrows, symbolv]
# Scale the prices to preserve the in-sample wealth
pricos <- sum(pricis[cutoff, ])*pricos/sum(pricos[1, ])
      @
    \column{0.5\textwidth}
      \vspace{-1em}
      \includegraphics[width=0.4\paperwidth]{figure/portf_stocks_outsample.png}
      <<echo=TRUE,eval=FALSE>>=
# Combine indeks with out-of-sample stock portfolio returns
wealth <- rbind(pricis, pricos)
wealth <- xts::xts(rowMeans(wealth), dates)
wealth <- cbind(indeks, wealth)
colnames(wealth)[2] <- "Portfolio"
# Calculate the out-of-sample Sharpe and Sortino ratios
sqrt(252)*sapply(rutils::diffit(wealth[(cutoff+1):nrows, ]), 
  function(x) c(Sharpe=mean(x)/sd(x), Sortino=mean(x)/sd(x[x<0])))
# Plot out-of-sample stock portfolio returns
dygraphs::dygraph(log(wealth), main="Out-of-sample Log Prices of Stock Portfolio") %>%
  dyOptions(colors=c("blue", "red"), strokeWidth=2) %>%
  dyEvent(dates[cutoff], label="in-sample", strokePattern="solid", color="green") %>%
  dyLegend(width=500)
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Momentum Strategy}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      In a \emph{momentum strategy}, the stock portfolio is rebalanced periodically and held out-of-sample.
      \vskip1ex
      \emph{Momentum strategies} can be \emph{backtested} by specifying the portfolio rebalancing frequency, the formation period, and the holding period:
      \setlength{\leftmargini}{1.0em}
      \begin{itemize}
        \item Specify a portfolio of stocks and their returns,
        \item Specify the \emph{end points} for portfolio rebalancing,
        \item Specify \emph{look-back} intervals for portfolio formation, and \emph{look-forward} intervals for portfolio holding, 
        \item Specify an objective function for calculating the past performance of the stocks,
        \item Calculate the past performance over the \emph{look-back} formation intervals,
        \item Calculate the portfolio weights from the past performance,
        \item Calculate the future returns over the \emph{look-forward} holding intervals,
        \item Calculate the out-of-sample momentum strategy returns by applying the portfolio weights to the future returns,
        \item Calculate the transaction costs and subtract them from the strategy returns.
      \end{itemize}
    \column{0.5\textwidth}
      \vspace{-1em}
      <<echo=TRUE,eval=FALSE>>=
# Calculate the percentage returns
retsp <- rutils::diffit(prices)/rutils::lagit(prices, lagg=1, pad_zeros=FALSE)
# Define momentum parameters
look_back <- 8
objfun <- function(returns) prod(1+returns)
nstocks <- 10
# Calculate a vector of monthly end points
endp <- rutils::calc_endpoints(retsp, interval="months")
endp[2] <- 11
npts <- NROW(endp)
# Perform loop over the end points
pnls <- lapply(2:(npts-1), function(it) {
  # Select the look-back returns
  startp <- endp[max(1, it-look_back)]
  retslb <- retsp[startp:endp[it], ]
  # Calculate the best performing stocks in-sample
  perfstat <- sapply(retslb, objfun)
  perfstat[!is.finite(perfstat)] <- 0
  perfstat <- sort(perfstat, decreasing=TRUE)
  symbolv <- names(head(perfstat, nstocks))
  # Calculate the in-sample portfolio volatility
  retst <- rowMeans(cumprod(1+retslb))
  retst <- rutils::diffit(retst)/rutils::lagit(retst, lagg=1, pad_zeros=FALSE)
  retsportf <- retslb[, symbolv]
  retsportf <- rowMeans(cumprod(1+retsportf))
  retsportf <- rutils::diffit(retsportf)/rutils::lagit(retsportf, lagg=1, pad_zeros=FALSE)
  scalef <- sd(retst)/sd(retsportf)
  # Calculate the out-of-sample portfolio returns
  retsos <- retsp[(endp[it]+1):endp[it+1], symbolv]
  retsos <- rowMeans(cumprod(1+retsos))
  retsos <- rutils::diffit(retsos)/rutils::lagit(retsos, lagg=1, pad_zeros=FALSE)
  # Scale the out-of-sample portfolio returns
  scalef*retsos
})  # end lapply
pnls <- rutils::do_call(c, pnls)
@
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Performance of Momentum Strategy for Stocks}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      The momentum strategy for stocks produces a slightly lower absolute return than the index, but it has a slightly higher Sharpe ratio.
      <<echo=TRUE,eval=FALSE>>=
# Add initial startup interval returns
retsu <- retsp[endp[1]:endp[2], ]
retsu <- rowMeans(cumprod(1+retsu))
retsu <- rutils::diffit(retsu)/
  rutils::lagit(retsu, lagg=1, pad_zeros=FALSE)
pnls <- c(retsu, pnls)
pnls <- cumprod(1+pnls)
pnls <- xts::xts(pnls, order.by=dates)
colnames(pnls) <- "Strategy"
# Calculate the Sharpe and Sortino ratios
wealth <- cbind(indeks, pnls)
sqrt(252)*sapply(rutils::diffit(wealth), 
  function(x) c(Sharpe=mean(x)/sd(x), Sortino=mean(x)/sd(x[x<0])))
      @
    \column{0.5\textwidth}
      \vspace{-1em}
      \includegraphics[width=0.4\paperwidth]{figure/portf_moment_monthly.png}
      <<echo=TRUE,eval=FALSE>>=
# Plot dygraph of stock index and momentum strategy
colors <- c("blue", "red")
dygraphs::dygraph(log(wealth), main="Log Stock Index and Momentum Strategy") %>%
  dyOptions(colors=colors, strokeWidth=2) %>%
  dyLegend(show="always", width=500)
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Momentum Strategy Functional}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      Performing a \emph{backtest} allows finding the optimal \emph{momentum} (trading) strategy parameters, such as the \emph{look-back interval}.
      \vskip1ex
      The function \texttt{backtestmomb()} simulates (backtests) a \emph{momentum strategy} which buys equal dollar amounts of the best performing stocks.
      \vskip1ex
      The function \texttt{backtestmomb()} can be used to find the best choice of \emph{momentum strategy} parameters.
    \column{0.5\textwidth}
      \vspace{-1em}
      <<echo=TRUE,eval=FALSE>>=
backtestmomb <- function(returns,
  objfun=function(returns) (prod(1+returns)/sd(returns)),
  look_back=12, rfreq="months", nstocks=10, bid_offer=0.001,
  endp=rutils::calc_endpoints(returns, interval=rfreq), ...) {
  # Perform loop over end points
  npts <- NROW(endp)
  pnls <- lapply(2:(npts-1), function(it) {
    # Select the look-back returns
    startp <- endp[max(1, it-look_back)]
    retslb <- returns[startp:endp[it], ]
    # Calculate the best performing stocks in-sample
    perfstat <- sapply(retslb, objfun)
    perfstat[!is.finite(perfstat)] <- 0
    perfstat <- sort(perfstat, decreasing=TRUE)
    symbolb <- names(head(perfstat, nstocks))
    # Calculate the in-sample portfolio volatility
    retst <- rowMeans(cumprod(1+retslb))
    retst <- rutils::diffit(retst)/rutils::lagit(retst, lagg=1, pad_zeros=FALSE)
    retsportf <- retslb[, symbolb]
    retsportf <- rowMeans(cumprod(1+retsportf))
    retsportf <- rutils::diffit(retsportf)/rutils::lagit(retsportf, lagg=1, pad_zeros=FALSE)
    scalef <- sd(retst)/sd(retsportf)
    # Calculate the out-of-sample portfolio returns
    retsos <- returns[(endp[it]+1):endp[it+1], symbolb]
    retsos <- rowMeans(cumprod(1+retsos))
    retsos <- rutils::diffit(retsos)/rutils::lagit(retsos, lagg=1, pad_zeros=FALSE)
    # Scale the out-of-sample portfolio returns
    scalef*retsos
  })  # end lapply
  pnls <- rutils::do_call(c, pnls)
  pnls
}  # end backtestmomb
@
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Optimization of Momentum Strategy Parameters}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      The performance of the \emph{momentum} strategy depends on the length of the \emph{look-back interval} used for calculating the past performance.
      \vskip1ex
      Research indicates that the optimal length of the \emph{look-back interval} for momentum is about \texttt{8} to \texttt{12} months.
      \vskip1ex
      The dependence on the length of the \emph{look-back interval} is an example of the \emph{bias-variance tradeoff}.  If the \emph{look-back interval} is too short, the past performance estimates have high \emph{variance}, but if the \emph{look-back interval} is too long, the past estimates have high \emph{bias}.
      \vskip1ex
      Performing many \emph{backtests} on multiple trading strategies risks identifying inherently unprofitable trading strategies as profitable, purely by chance (known as \emph{p-value hacking}).
      \vskip1ex
      But using a different rebalancing frequency in the \emph{backtest} can produce different values for the optimal trading strategy parameters.
      \vskip1ex
      So \emph{backtesting} just redefines the problem of finding (tuning) the optimal trading strategy parameters, into the problem of finding the optimal \emph{backtest} (meta-model) parameters.
      \vskip1ex
      But the advantage of using the \emph{backtest} meta-model is that it can reduce the number of parameters that need to be optimized.
    \column{0.5\textwidth}
      \vspace{-1em}
      \includegraphics[width=0.4\paperwidth]{figure/momentum_stock_profile.png}
      <<echo=TRUE,eval=FALSE>>=
# Perform backtests for vector of look-back intervals
source("/Users/jerzy/Develop/R/backtest_functions.R")
look_backs <- seq(3, 15, by=1)
objfun <- function(returns) prod(1+returns)
pnls <- lapply(look_backs, backtestmomb, returns=retsp, endp=endp, objfun=objfun)
profilev <- sapply(pnls, function(pnl) sum(pnl)/sd(pnl))
# Plot momemntum PnLs
x11(width=6, height=5)
plot(x=look_backs, y=profilev, t="l",
  main="Momemntum PnL as Function of Look-back Interval",
  xlab="look-back (months)", ylab="pnl")
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Momentum Portfolio Weights}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      The portfolio weights of \emph{momentum} strategies can be calculated based on the past performance of the assets in many different ways:
      \begin{itemize}
        \item Invest equal dollar amounts in the top \texttt{n} best performing stocks and short the \texttt{n} worst performing stocks,
        \item Invest dollar amounts proportional to the past performance - purchase stocks with positive performance, and short stocks with negative performance,
        \item Subtract the weights mean so that their sum is equal to $0$: $\sum_{i=1}^n {w_i} = 0$, 
        \item Scale the weights so that the sum of squares is equal to $1$: $\sum_{i=1}^n {w^2_i} = 1$, 
      \end{itemize}
      \vskip1ex
      De-meaning the weights reduces the portfolio market \emph{beta}.
      \vskip1ex
      Scaling the weights reduces the portfolio \emph{leverage}.
    \column{0.5\textwidth}
      \vspace{-1em}
      <<echo=TRUE,eval=FALSE>>=
# Define performance function as Sharpe ratio
objfun <- function(returns) sum(returns)/sd(returns)
# Calculate performance statistics over look-back intervals
perfstat <- sapply(retsp[endp[1]:endp[2]], objfun)
perfstat[!is.finite(perfstat)] <- 0
sum(is.na(perfstat))
# Calculate the best and worst performing stocks
perfstat <- sort(perfstat, decreasing=TRUE)
nstocks <- 10
symbolb <- names(head(perfstat, nstocks))
symbolw <- names(tail(perfstat, nstocks))
# Calculate equal weights for the best and worst performing stocks
weights <- numeric(ncols)
names(weights) <- colnames(retsp)
weights[symbolb] <- 1
weights[symbolw] <- (-1)
# Calculate weights proportional to performance
weights <- perfstat
# Scale weights so sum of squares is equal to 1
weights <- weights/sqrt(sum(weights^2))
# Or scale weights so sum is equal to 1
weights <- weights/sum(weights)
# Calculate the momentum portfolio returns
retsportf <- retsp %*% weights
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{The MTUM Momentum ETF}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      The \emph{MTUM} ETF is an actively managed ETF which follows a momentum strategy for stocks.
      \vskip1ex
      The \emph{MTUM} ETF has a slightly higher absolute return than the \emph{VTI} ETF, but it has a slightly lower Sharpe ratio.
      <<echo=TRUE,eval=FALSE>>=
# Calculate the scaled prices of VTI vs MTUM ETF
wealth <- log(na.omit(rutils::etfenv$prices[, c("VTI", "MTUM")]))
wealth[, 1] <- wealth[, 1]/as.numeric(wealth[1, 1])
wealth[, 2] <- wealth[, 2]/as.numeric(wealth[1, 2])
colnames(wealth) <- c("VTI", "MTUM")
# Calculate the Sharpe and Sortino ratios
sqrt(252)*sapply(rutils::diffit(wealth), 
  function(x) c(Sharpe=mean(x)/sd(x), Sortino=mean(x)/sd(x[x<0])))
# Plot the scaled prices of VTI vs MTUM ETF
dygraphs::dygraph(wealth, main="VTI vs MTUM ETF") %>%
  dyOptions(colors=c("blue", "red"), strokeWidth=2) %>%
  dyLegend(width=500)
      @
    \column{0.5\textwidth}
      \vspace{-1em}
      \includegraphics[width=0.4\paperwidth]{figure/momentum_mtum.png}
  \end{columns}
\end{block}

\end{frame}



%%%%%%%%%%%%%%%
\section{Asset Pricing Models}


%%%%%%%%%%%%%%%
\subsection{The \protect\emph{Alpha} and \protect\emph{Beta} of Stock Returns}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      The \emph{Capital Asset Pricing Model} decomposes asset returns into \emph{systematic} returns (proportional to the market returns) and \emph{idiosyncratic} returns (uncorrelated to market returns):
      \begin{displaymath}
        R - R_f = {\alpha} + \beta (R_m - R_f) + {\varepsilon}
      \end{displaymath}
      The returns of \emph{XLP} and \emph{VTI} are highly correlated because they are driven by common market factors of returns.
      \vskip1ex
      The \emph{t}-statistic (\emph{t}-value) is the ratio of the estimated value divided by its standard error.
      \vskip1ex
      The \emph{p}-value is the probability of obtaining values exceeding the \emph{t}-statistic, assuming the \emph{null hypothesis} is true.
      \vskip1ex
      A small \emph{p}-value means that the regression coefficients are very unlikely to be zero (given the data).
      <<echo=TRUE,eval=TRUE>>=
# Perform regression using formula
model <- lm(XLP ~ VTI, data=rutils::etfenv$returns)
# Get regression coefficients
coef(summary(model))
# Get alpha and beta
coef(summary(model))[, 1]
      @
    \column{0.5\textwidth}
    \vspace{-2em}
      \includegraphics[width=0.4\paperwidth]{figure/reg_rets.png}
      \vspace{-1em}
      <<echo=TRUE,eval=FALSE>>=
# Plot scatterplot of returns with aspect ratio 1
plot(XLP ~ VTI, data=rutils::etfenv$returns,
     xlim=c(-0.1, 0.1), ylim=c(-0.1, 0.1), 
     asp=1, main="Regression XLP ~ VTI")
# Add regression line and perpendicular line
abline(model, lwd=2, col="red")
abline(a=0, b=-1/coef(summary(model))[2, 1], 
       lwd=2, col="blue")
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{The Statistical Significance of \protect\emph{Alpha} and \protect\emph{Beta}}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      The \emph{beta} $\beta$ values of stock returns are very statistically significant, but the \emph{alpha} $\alpha$ values are mostly not significant.
      \vskip1ex
      In addition, the \emph{Durbin-Watson} test shows that the regression residuals are autocorrelated which means that the regression \emph{p}-values may be smaller than the reported values.
    \column{0.5\textwidth}
      \vspace{-1em}
      <<echo=TRUE,eval=TRUE>>=
# Get regression coefficients
coef(summary(model))
# Calculate regression coefficients from scratch
design <- na.omit(rutils::etfenv$returns[, c("XLP", "VTI")])
betav <- drop(cov(design$XLP, design$VTI)/var(design$VTI))
alpha <- drop(mean(design$XLP) - betav*mean(design$VTI))
c(alpha, betav)
# Calculate the residuals
residuals <- (design$XLP - (alpha + betav*design$VTI))
# Calculate the standard deviation of residuals
nrows <- NROW(residuals)
resid_std <- sqrt(sum(residuals^2)/(nrows - 2))
# Calculate the standard errors of beta and alpha
sum2 <- sum((design$VTI - mean(design$VTI))^2)
beta_std <- resid_std/sqrt(sum2)
alpha_std <- resid_std*sqrt(1/nrows + mean(design$VTI)^2/sum2)
c(alpha_std, beta_std)
# Perform the Durbin-Watson test of autocorrelation of residuals
lmtest::dwtest(model)
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{The \protect\emph{Alpha} and \protect\emph{Beta} of ETF Returns}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.55\textwidth}
      The \emph{beta} $\beta$ values of ETF returns are very statistically significant, but the \emph{alpha} $\alpha$ values are mostly not significant.
      \vskip1ex
      Some of the ETFs with significant \emph{alpha} $\alpha$ values are the bond ETFs \emph{IEF} and \emph{TLT} (which have performed very well), and the natural resource ETFs \emph{USO} and \emph{DBC} (which have performed very poorly).
      <<echo=(-(1:1)),eval=TRUE>>=
library(rutils)  # Load rutils
returns <- rutils::etfenv$returns
symbolv <- colnames(returns)
symbolv <- symbolv[symbolv != "VTI"]
# Perform regressions and collect statistics
etf_betas <- sapply(symbolv, function(symbol) {
# Specify regression formula
  formulav <- as.formula(paste(symbol, "~ VTI"))
# Perform regression
  model <- lm(formulav, data=returns)
# Get regression summary
  model_sum <- summary(model)
# Collect regression statistics
  with(model_sum, 
    c(beta=coefficients[2, 1], 
      pbeta=coefficients[2, 4],
      alpha=coefficients[1, 1], 
      palpha=coefficients[1, 4], 
      pdw=lmtest::dwtest(model)$p.value))
})  # end sapply
etf_betas <- t(etf_betas)
# Sort by palpha
etf_betas <- etf_betas[order(etf_betas[, "palpha"]), ]
      @
    \column{0.45\textwidth}
      \vspace{-1em}
      <<echo=TRUE,eval=TRUE>>=
etf_betas
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Capital Asset Pricing Model (\protect\emph{CAPM})}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      The \emph{Capital Asset Pricing Model} decomposes asset returns into \emph{systematic} returns (proportional to the market returns) and \emph{idiosyncratic} returns (uncorrelated to market returns):
      \begin{displaymath}
        R - R_f = {\alpha} + \beta (R_m - R_f) + {\varepsilon}
      \end{displaymath}
      Where $R_m$ are the market returns, and $R_f$ are the risk-free returns.
      \vskip1ex
      The \emph{systematic} returns are proportional to $\beta$.
      \vskip1ex
      The \emph{idiosyncratic} returns are equal to the sum of $\alpha$ plus $\varepsilon$.
      \vskip1ex
      The \emph{alpha} $\alpha$ are the returns in excess of \emph{systematic} returns, that may be attributed to portfolio selection or active manager performance.
      \vskip1ex
      The \emph{idiosyncratic} risk (equal to $\varepsilon$) is uncorrelated to the \emph{systematic} risk, and can be reduced through portfolio diversification.
      \vskip1ex
      The $\beta$ is proportional to the correlation of returns between the asset and the market:
      \begin{displaymath}
        \beta = \frac{\sum_{i=1}^n (R_i-\bar{R}) (R_{i,m}-\bar{R_m})}{\sum_{i=1}^n (R_{i,m}-\bar{R_m})^2} = \rho \frac{\sigma}{\sigma_m}
      \end{displaymath}
      The \emph{CAPM} model states that if an asset has higher $\beta$ risk, then it earns higher \emph{systematic} returns.
    \column{0.5\textwidth}
      \vspace{-1em}
      <<echo=TRUE,eval=TRUE>>=
library(PerformanceAnalytics)
returns <- na.omit(returns[, c("XLP", "VTI")])
# Calculate XLP beta
PerformanceAnalytics::CAPM.beta(Ra=returns$XLP, Rb=returns$VTI)
# Or
betav <- cov(returns)[1, 2]/var(returns$VTI)[1]
# Calculate XLP bull beta
PerformanceAnalytics::CAPM.beta.bull(Ra=returns$XLP, Rb=returns$VTI)
# Calculate XLP bear beta
PerformanceAnalytics::CAPM.beta.bear(Ra=returns$XLP, Rb=returns$VTI)
# Calculate XLP alpha
PerformanceAnalytics::CAPM.alpha(Ra=returns$XLP, Rb=returns$VTI)
# Or
mean(returns$XLP - betav*returns$VTI)
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{The Security Market Line for ETFs}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      According to the \emph{CAPM} model, assets should earn a \emph{systematic} return proportional to their \emph{systematic} risk $\beta$.
      \vskip1ex
      The \emph{Security Market Line} (SML) represents the linear relationship between \emph{systematic} risk $\beta$ and return, for different stocks.
      <<echo=(-1),eval=FALSE>>=
library(PerformanceAnalytics)
etf_betas <- sapply(returns[, colnames(returns)!="VXX"], 
  CAPM.beta, Rb=returns$VTI)
etf_annrets <- sapply(returns[, colnames(returns)!="VXX"], 
  Return.annualized)
# Plot scatterplot
plot(etf_annrets ~ etf_betas, xlab="betas", 
            ylab="ann. rets", xlim=c(-0.25, 1.6))
points(x=1, y=etf_annrets["VTI"], col="red", lwd=3, pch=21)
abline(a=0, b=etf_annrets["VTI"])
label_names <- rownames(etf_betas)[1:13]
# Add labels
text(x=1, y=etf_annrets["VTI"], labels="VTI", pos=2)
text(x=etf_betas[label_names], y=etf_annrets[label_names], 
     labels=label_names, pos=2, cex=0.8)
      @
    \column{0.5\textwidth}
    \vspace{-4em}
      \includegraphics[width=0.5\paperwidth]{figure/capm_scatter-1}\\
    \vspace{-1em}
      A scatterplot of asset returns versus their $\beta$ shows which assets earn a positive $\alpha$, and which don't.
      \vskip1ex
      If an asset lies on the \emph{SML}, then its returns are mostly \emph{systematic}, and its $\alpha$ is equal to zero.
      \vskip1ex
      Assets above the \emph{SML} have a positive $\alpha$, and those below have a negative $\alpha$.
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Beta-adjusted Performance Measurement}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      The \emph{Treynor} ratio measures the excess returns per unit of the \emph{systematic} risk \emph{beta} $\beta$, and is equal to the excess returns (over a risk-free return) divided by the $\beta$:
      \begin{displaymath}
        T_r=\frac{E[R-R_f]}{\beta}
      \end{displaymath}
      The \emph{Treynor} ratio is similar to the \emph{Sharpe} ratio, with the difference that its denominator represents only \emph{systematic} risk, not total risk.
      \vskip1ex
      The \emph{Information} ratio is equal to the excess returns (over a benchmark) divided by the \emph{tracking error} (standard deviation of excess returns):
      \begin{displaymath}
        I_r = \frac{E[R-R_b]} {\sqrt{\sum_{i=1}^n (R_i-R_{i,b})^2}}
      \end{displaymath}
      The \emph{Information} ratio measures the amount of outperformance versus the benchmark, and the consistency of outperformance.
      \vskip1ex
    \column{0.5\textwidth}
      \vspace{-1em}
      <<echo=TRUE,eval=TRUE>>=
library(PerformanceAnalytics)
# Calculate XLP Treynor ratio
TreynorRatio(Ra=returns$XLP, Rb=returns$VTI)
# Calculate XLP Information ratio
InformationRatio(Ra=returns$XLP, Rb=returns$VTI)
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{\protect\emph{CAPM} Summary Statistics}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.55\textwidth}
      \texttt{PerformanceAnalytics::table.CAPM()} calculates the \emph{beta} $\beta$ and \emph{alpha} $\alpha$ values, the \emph{Treynor} ratio, and other performance statistics.
      \vspace{-1em}
      <<echo=TRUE,eval=TRUE>>=
PerformanceAnalytics::table.CAPM(Ra=returns[, c("XLP", "XLF")], 
                                 Rb=returns$VTI, scale=252)
      @
      \vspace{-2em}
      <<echo=TRUE,eval=FALSE>>=
capmstats <- table.CAPM(Ra=returns[, symbolv], 
              Rb=returns$VTI, scale=252)
colnamev <- strsplit(colnames(capmstats), split=" ")
colnamev <- do.call(cbind, colnamev)[1, ]
colnames(capmstats) <- colnamev
capmstats <- t(capmstats)
capmstats <- capmstats[, -1]
colnamev <- colnames(capmstats)
whichv <- match(c("Annualized Alpha", "Information Ratio", "Treynor Ratio"), colnamev)
colnamev[whichv] <- c("Alpha", "Information", "Treynor")
colnames(capmstats) <- colnamev
capmstats <- capmstats[order(capmstats[, "Alpha"], decreasing=TRUE), ]
# Copy capmstats into etfenv and save to .RData file
etfenv <- rutils::etfenv
etfenv$capmstats <- capmstats
save(etfenv, file="/Users/jerzy/Develop/lecture_slides/data/etf_data.RData")
      @
    \column{0.45\textwidth}
      \vspace{-1em}
      <<echo=TRUE,eval=TRUE>>=
rutils::etfenv$capmstats[, c("Beta", "Alpha", "Information", "Treynor")]
      @
  \end{columns}
\end{block}

\end{frame}



%%%%%%%%%%%%%%%
\section{Homework Assignment}


%%%%%%%%%%%%%%%
\subsection{Homework Assignment}
\begin{frame}[t]{\secname}
\vspace{-1em}
\begin{block}{Required}
  \begin{itemize}[]
    \item Study all the lecture slides in \emph{FRE7241\_Lecture\_3.pdf}, and run all the code in \emph{FRE7241\_Lecture\_3.R}
  \end{itemize}
\end{block}
% \begin{block}{Recommended}
%   \begin{itemize}[]
%   \end{itemize}
% \end{block}

\end{frame}


\end{document}
