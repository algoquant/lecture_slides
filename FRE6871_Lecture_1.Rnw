% FRE6871_Lecture1
% Define knitr options
% !Rnw weave=knitr
% Set global chunk options
<<knitr_setup,include=FALSE,cache=FALSE>>=
library(knitr)
opts_chunk$set(prompt=TRUE, eval=FALSE, tidy=FALSE, strip.white=FALSE, comment=NA, highlight=FALSE, message=FALSE, warning=FALSE, size="tiny", fig.width=4, fig.height=4)
options(width=80, dev="pdf")
options(digits=3)
thm <- knit_theme$get("acid")
knit_theme$set(thm)
@


% Define document options
\documentclass[9pt]{beamer}
\DeclareMathSizes{8pt}{6pt}{6pt}{5pt}
\mode<presentation>
\usetheme{AnnArbor}
% \usecolortheme{whale}
% Uncover everything in a step-wise fashion
% \beamerdefaultoverlayspecification{<+->}
% mathtools package for math symbols
% \usepackage{mathtools}
\usepackage[latin1]{inputenc}
\usepackage{hyperref}
\usepackage{fancybox}
\usepackage{url}
\usepackage[backend=bibtex,style=alphabetic]{biblatex} % bibstyle=numeric
\usepackage{listings}
\usepackage{xcolor}
\definecolor{anti_flashwhite}{rgb}{0.95, 0.95, 0.96}
\definecolor{cmd_background}{rgb}{0.2, 0.2, 0.0}
\definecolor{vba_background}{rgb}{0.0, 0.0, 0.9}
% \bibliographystyle{amsalpha} % doesn't work
% \addbibresource{FRE_lectures.bib}
% \addbibresource[location=remote]{http://www.citeulike.org/user/jerzyp}
\renewcommand\bibfont{\footnotesize}
\renewcommand{\pgfuseimage}[1]{\scalebox{0.75}{\includegraphics{#1}}} % scale bib icons
\setbeamertemplate{bibliography item}[text] % set bib icons
% \setbeamertemplate{bibliography item}{} % remove bib icons

% \usepackage{enumerate}
% \let\emph\textbf
% \let\alert\textbf
% Define colors for hyperlinks
\definecolor{links}{HTML}{2A1B81}
\hypersetup{colorlinks=true,linkcolor=,urlcolor=links}
% Make url text scriptsize
\renewcommand\UrlFont{\scriptsize}
% Make institute text italic and small
\setbeamerfont{institute}{size=\small,shape=\itshape}
\setbeamerfont{date}{size=\small}
\setbeamerfont{block title}{size=\normalsize} % shape=\itshape
\setbeamerfont{block body}{size=\footnotesize}


% Title page setup
\title[FRE6871 Lecture\#1]{FRE6871 \texttt{R} in Finance}
\subtitle{Lecture\#1, Spring 2025}

\institute[NYU Tandon]{NYU Tandon School of Engineering}
\titlegraphic{\includegraphics[scale=0.2]{image/tandon_long_color.png}}
\author[Jerzy Pawlowski]{Jerzy Pawlowski \emph{\href{mailto:jp3900@nyu.edu}{jp3900@nyu.edu}}}
% \email{jp3900@nyu.edu}
\date{March 17, 2025}
% \date{\today}
% \pgfdeclareimage[height=0.5cm]{university-logo}{engineering_long_white}
% \logo{\pgfuseimage{engineering_long_white}}


%%%%%%%%%%%%%%%
\begin{document}


%%%%%%%%%%%%%%%
\maketitle



%%%%%%%%%%%%%%%
\section{Introduction}


%%%%%%%%%%%%%%%
\subsection{Welcome Students!}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      My name is Jerzy Pawlowski \href{mailto:jp3900@nyu.edu}{jp3900@nyu.edu}
      \vskip1ex
      I'm an adjunct professor at NYU Tandon because I love teaching and I want to share my professional knowledge with young, enthusiastic students.
      \vskip1ex
      I'm interested in applications of \emph{machine learning} to \emph{systematic investing}.
      \vskip1ex
      I'm an advocate of \emph{open-source software}, and I share it on GitHub:\\
      \href{https://github.com/algoquant/}{\color{blue}{My GitHub account}} 
      \vskip1ex
      In my finance career, I have worked as a hedge fund \emph{portfolio manager}, \emph{CLO banker} (structurer), and \emph{quant risk analyst}.\\
      \href{https://www.linkedin.com/in/jerzypawlowski/}{\color{blue}{My LinkedIn profile}} 
    \column{0.5\textwidth}
    \includegraphics[width=0.5\paperwidth]{image/Jerzy_Pawlowski_linked.png}
    \includegraphics[width=0.5\paperwidth]{image/github_algoquant.png}
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{FRE6871 Course Description and Objectives}
\begin{frame}[t]{\subsecname}
\vspace{-1em}

\begin{block}{Course Description}
  The course will study the applications of the \texttt{R} statistical language to financial data analysis and modeling.
  The applications will include \emph{classification} for credit scoring, \emph{Monte Carlo simulation} for option pricing and credit portfolio modeling, and \emph{Principal Component Analysis} (\emph{PCA}) for interest rate yield curve modeling.
  The course will apply statistical techniques, such as \emph{hypothesis testing}. \emph{linear regression}, \emph{logistic regression}, and \emph{bootstrap simulation}.\\
  \textbf{This course is challenging, so it requires devoting a significant amount of time!}
\end{block}
\pause

\begin{block}{Course Objectives}
  Students will learn through \texttt{R} coding exercises how to:\\
  \hskip1em - Manipulate data structures (vectors, data frames, dates, and time series).\\
  \hskip1em - Download data from external sources, and to scrub and format it.\\
  \hskip1em - Create interactive plots and visualizations.\\
  \hskip1em - Build financial models.\\
  \hskip1em - Perform exception and error handling, and debugging.\\
\end{block}
\pause

\begin{block}{Course Prerequisites}
  The \texttt{R} language is considered to be challenging, so this course requires some programming experience with other languages such as \texttt{C++} or \texttt{Python}.  Students should also have knowledge of basic statistics (random variables, estimators, hypothesis testing, regression, etc.)
  The course \emph{FRE7241 Algorithmic Portfolio Management} is designed as a followup course to \emph{FRE6871}.
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Homeworks and Tests}
\begin{frame}[t]{\subsecname}
\vspace{-1em}

\begin{block}{Homeworks and Tests}
Grading will be based on homeworks and tests.  There will be no final exam.
      \vskip1ex
The tests will be announced several days in advance.
      \vskip1ex
The homeworks and tests will require writing code in \texttt{R}, which should run directly when loaded into an \texttt{R} session, and should produce the required output, \textbf{without any modifications}.
      \vskip1ex
The tests will be closely based on code contained in the lecture slides, so students are encouraged to become very familiar with those slides.
      \vskip1ex
Students must submit their homework and test files only through \emph{Brightspace} (not emails).
      \vskip1ex
Students will be allowed to copy code from the lecture slides, and to copy from books or any online sources, but they will be required to provide references to those external sources (such as links or titles and page numbers).
      \vskip1ex
Students are encouraged to use AI applications, such as ChatGPT, \href{https://copilot.github.com/}{\emph{GitHub Copilot}}, \href{https://docs.posit.co/ide/user/ide/guide/tools/copilot.html}{\emph{Copilot for RStudio}}, etc.
But you must include the name of the AI application in your solution.
      \vskip1ex
Students will be required to bring their laptop computers to class and run the \texttt{R} Interpreter, and the \texttt{RStudio} Integrated Development Environment (\emph{IDE}), during the lecture.
      \vskip1ex
Homeworks will also include reading assignments designed to help prepare for tests.
\end{block}
\pause

\begin{block}{Graduate Assistant}
The graduate assistant (GA) will be Mudit Nigam \href{mailto:mn3439@nyu.edu}{mn3439@nyu.edu}.\\
The GA will answer questions during office hours, or via \emph{Brightspace} forums, not via emails.  Please send emails regarding lecture matters from \emph{Brightspace} (not personal emails).
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Tips for Solving Homeworks and Tests}
\begin{frame}[t]{\subsecname}
\vspace{-1em}
  \begin{block}{Tips for Solving Homeworks and Tests}
    The assignments will mostly require copying code samples from the lecture slides, making some modifications to them, and combining them with other code samples.
    \vskip1ex
    Partial credit will be given even for code that doesn't produce the correct output, but that has elements of code that can be useful for producing the right answer.
    \vskip1ex
    So don't leave test assignments unanswered, and instead copy any code samples from the lecture slides that are related to the solution and make sense.
    \vskip1ex
    Contact the GA during office hours via text or phone, and submit questions to the GA or to me via \emph{Brightspace}.
  \end{block}
\pause
  \begin{block}{Please Submit \emph{Minimal Working Examples} With Your Questions}
    When submitting questions, please provide a \emph{minimal working example} that produces the error in \texttt{R}, with the following items:
      \begin{itemize}
        \item The \emph{complete} \texttt{R} code that produces the error, including the seed value for random numbers,
        \item The version of \texttt{R} (output of the command: \texttt{sessionInfo()}), and the versions of \texttt{R} packages, 
        \item The type and version of your operating system (Windows or OSX),
        \item The dataset file used by the \texttt{R} code,
        \item The text or screenshots of error messages,
      \end{itemize}
    \vskip1ex
    You can read more about producing \emph{minimal working examples} here:
      \url{http://stackoverflow.com/help/mcve}\\
      \url{http://www.jaredknowles.com/journal/2013/5/27/writing-a-minimal-working-example-mwe-in-r}
  \end{block}
\end{frame}


%%%%%%%%%%%%%%%
\subsection{Course Grading Policies}
\begin{frame}[t]{\subsecname}
\vspace{-1em}

\begin{block}{Numerical Scores}
  Homeworks and tests will be graded and assigned numerical scores.  
  Each part of homeworks and tests will be graded separately and assigned a numerical score.\\
  Maximum scores will be given only for complete code, that produces the correct output when it's pasted into an \texttt{R} session, without any modifications. 
  As long as the \texttt{R} code uses the required functions and produces the correct output, it will be given full credit.\\
  Partial credit will be given even for code that doesn't produce the correct output, but that has elements of code that can be useful for producing the right answer.
\end{block}
\pause

\begin{block}{Letter Grades}
  Letter grades for the course will be derived from the percentage scores obtained for all the homeworks and tests.
  The percentage scores will be calculated by adding together the scores of all the homeworks and tests, and dividing them by the sum of the maximum scores. 
  The percentage scores are usually very high - above \texttt{90\%}.  So a very high percentage score will not guarantee an A letter grade, since grading will also depend on the difficulty of the assignments.
\end{block}
\pause

\begin{block}{Plagiarism}
  Plagiarism (copying from other students) and cheating will be punished.\\
  But copying code from lecture slides, books, or any online sources is allowed and encouraged.\\
  Students must provide references to any external sources from which they copy code (such as links or titles and page numbers).
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{FRE6871 Course Materials}
\begin{frame}[t]{\subsecname}
\vspace{-1em}

\begin{block}{Lecture Slides}
The course will be mostly self-contained, using detailed lecture slides containing extensive, working \texttt{R} code examples.\\
The course will also utilize data and tutorials which are freely available on the internet.
\end{block}
\pause

\begin{block}{FRE6871 Recommended Textbooks}
\begin{itemize}[]
  \item \href{https://people.orie.cornell.edu/davidr/SDAFE2/index.html}{\emph{Statistics and Data Analysis for Financial Engineering}} by David Ruppert, introduces regression, cointegration, multivariate time series analysis, \emph{ARIMA}, \emph{GARCH}, \emph{CAPM}, and factor models, with examples in \texttt{R}.
  % \fullcite{ruppertbook}\\
  \item \href{https://press.princeton.edu/books/hardcover/9780691166278/quantitative-risk-management}{\emph{Quantitative Risk Management}} by Alexander J. McNeil, Rudiger Frey, and Paul Embrechts: review of Value at Risk, factor models, ARMA and GARCH, extreme value theory, and credit risk models.
  \item \href{https://www.statlearning.com}{\emph{Introduction to Statistical Learning}} by Gareth James, Daniela Witten, Trevor Hastie, and Robert Tibshirani, introduces machine learning techniques using \texttt{R}, but without deep learning.
  % \fullcite{islbook}
  \item \href{http://adv-r.had.co.nz/}{\emph{Advanced \texttt{R}}} by Hadley Wickham, is the best book for learning the advanced features of \texttt{R}.
  % \fullcite{hadleybook}
  \item \href{http://it-ebooks.info/book/1734/}{\emph{The Art of \texttt{R} Programming}} by Norman Matloff, contains a good introduction to \texttt{R} and to some statistical models.
  % \fullcite{matloffbook}
\end{itemize}

Many textbooks can be downloaded in electronic format from the 
\href{http://library.nyu.edu/}{\emph{NYU Library}}.

\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{FRE6871 Supplementary Textbooks}
\begin{frame}[t]{\subsecname}
\vspace{-1em}

\begin{block}{Supplementary Textbooks}
\begin{itemize}[]
  \item The books \href{http://www.statmethods.net/}{\emph{\texttt{R} in Action}} by Robert Kabacoff and \href{http://www.jaredlander.com/r-for-everyone/}{\emph{\texttt{R} for Everyone}} by Jared Lander, are good introductions to \texttt{R} and to statistical models.
  % \fullcite{kabacoffbook}
  % \fullcite{landerbook}
  
  \item \href{http://eeecon.uibk.ac.at/~zeileis/teaching/AER/index.html}{\emph{Applied Econometrics with \texttt{R}}} by Christian Kleiber and Achim Zeileis, introduces advanced statistical models and econometrics.
  % \fullcite{kleiberbook}
  
  \item \href{http://www.nr.com/}{\emph{Numerical Recipes in \texttt{C++}}} by William Press, Saul Teukolsky, William Vetterling, and Brian Flannery, is a great reference for linear algebra and numerical methods, implemented in working \texttt{C++} code.
  
  \item \href{https://www.amazon.com/hz/wishlist/ls/1C3R818RWTWNW}{\emph{Quant Finance books}} by Jerzy Pawlowski.
  
  \item \href{https://www.amazon.com/hz/wishlist/ls/1R44X8846DX3N}{\emph{Quant Trading books}} by Jerzy Pawlowski.

  % \fullcite{numrecipesbook}
\end{itemize}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{FRE6871 Supplementary Materials}
\begin{frame}[t]{\subsecname}

\begin{block}{}
  \begin{columns}[T]
    \column{0.7\textwidth}
      \texttt{Notepad++} is a free source code editor for \texttt{MS Windows}, that supports several programming languages, including \texttt{R}.
      \vskip1ex
      \texttt{Notepad++} has a very convenient and fast \emph{search and replace} function, that allows \emph{search and replace} in multiple files.\\
      \hskip1em\url{http://notepad-plus-plus.org/}
    \column{0.3\textwidth}
      \includegraphics[height=0.5\textwidth]{image/npp.jpg}
  \end{columns}
\end{block}

\end{frame}



%%%%%%%%%%%%%%%
\section{\texttt{R} Help and Documentation}


%%%%%%%%%%%%%%%
\subsection{Internal \texttt{R} Help and Documentation}
\begin{frame}[fragile,t]{\subsecname}

\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      The function \texttt{help()} displays documentation on a function or subject,\\
      \vskip1ex
      Preceding the keyword with a single \texttt{"?"} is equivalent to calling \texttt{help()}.
    \column{0.5\textwidth}
      \vspace{-1em}
% tidy=FALSE prevents translation of "?getwd" into "`?`(getwd)"
      <<echo=TRUE,eval=FALSE>>=
# Display documentation on function "getwd"
help(getwd)
# Equivalent to "help(getwd)"
?getwd
      @
  \end{columns}
\end{block}

\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      The function \texttt{help.start()} displays a page with links to internal documentation.
      \vskip1ex
      \texttt{R} documentation is also available in \texttt{RGui} under the help tab.
      \vskip1ex
      The \emph{pdf} files with \texttt{R} documentation are also available directly under:\\
%      \texttt{\color{blue}{C:/Program Files/R/R-3.1.2/bin/x64}}\\
      \href{C:/Program Files/R/R-3.1.2/doc/manual/}{C:/Program Files/R/R-3.1.2/doc/manual/}\\
      (the exact path will depend on the \texttt{R} version.)
    \column{0.5\textwidth}
      \vspace{-1em}
      <<echo=TRUE,eval=FALSE>>=
# Open the hypertext documentation
help.start()
      @
      \vskip1ex
      \includegraphics[height=0.2\textwidth]{image/Rlogo.png}
  \end{columns}
\end{block}

\begin{block}{}
  \href{http://cran.r-project.org/doc/manuals/r-release/R-intro.pdf}{Introduction to \texttt{R}}
  by Venables and \texttt{R} Core Team.
  % \fullcite{website:rintro}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{\texttt{R} Online Help and Documentation}
\begin{frame}[t]{\subsecname}
\vspace{-1em}

\begin{block}{\texttt{R} Cheat Sheets}
  The 
  \href{https://posit.co/resources/cheatsheets/}{\texttt{R} Cheat Sheets} 
  are a fast way to find what you want.
\end{block}

\begin{block}{\texttt{R} Programming \texttt{Wikibook}}
  \texttt{Wikibooks} are crowdsourced textbooks\\
  \hskip1em\url{http://en.wikibooks.org/wiki/R_Programming/}\\
\end{block}

\begin{block}{\texttt{R FAQ}}
  Frequently Asked Questions about \texttt{R}\\
  \hskip1em\url{http://cran.r-project.org/doc/FAQ/R-FAQ.html}\\
\end{block}

\begin{block}{\texttt{R}-seek Online Search Tool}
  \texttt{R}-seek allows online searches specific to the \texttt{R} language\\
  \hskip1em\url{http://www.rseek.org/}
\end{block}

\begin{block}{\texttt{R}-help Mailing List}
  \texttt{R}-help is a very comprehensive Q\&A mailing list\\
  \hskip1em\url{https://stat.ethz.ch/mailman/listinfo/r-help}\\
  \texttt{R}-help has archives of past Q\&A - search it before you ask\\
  \hskip1em\url{https://stat.ethz.ch/pipermail/r-help/}\\
  GMANE allows searching the \texttt{R}-help archives using a usenet newsgroup style GUI\\
  \hskip1em\url{http://news.gmane.org/gmane.comp.lang.r.general}\\
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{\texttt{R} Code Style Guidelines}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}

\begin{block}{}
   \textbf{Please follow the \texttt{R} code style from the lecture slides.}\\
  Please follow the 
  \href{https://google.github.io/styleguide/Rguide.html}{\color{blue}{\emph{Google \texttt{R} Style Guide}}} to make your \texttt{R} code more readable.
\end{block}

\begin{block}{Please also follow these \texttt{R} code style rules:}
  - Use the left arrow \texttt{"<-"} for assignment, not the equals sign \texttt{"="} (to insert \texttt{"<-"} into code, use the \emph{Alt-hyphen} shortcut in Windows, or the \emph{Option-hyphen} shortcut on the Mac),\\
  - Use \emph{nouns} for variable names and \emph{verbs} for function names,\\
  - Use a combination of lowercase letters, numbers, and underscores \texttt{"\_"} for names of variables and functions,\\
  - Add underscores \texttt{"\_"} to names to avoid conflicts with the names of existing \texttt{R} functions and variables,\\
  - Do not use dots \texttt{"."} in names, except in the names of function \emph{methods} (even though \texttt{R} uses them for variables as well),\\
  - Use underscores \texttt{"\_"} in file names, instead of spaces,\\
  - Always put a space after a comma, never before it: \texttt{"x, y"} not \texttt{"x , y"},\\
  - Do not put spaces inside or outside parentheses: \texttt{"if (x > 0)"} not \texttt{"if ( x > 0 )"},\\
  - Surround infix operators (\texttt{==, +, -, <-,} etc.) with spaces: \texttt{"x > 0"} not \texttt{"x>0"} (even though I don't always follow that rule, to save whitespace),\\
  - Add a comment after the closing curly bracket: \texttt{"\}  \# end my\_fun"},
\end{block}
  
\begin{block}{}
  You can reformat \texttt{R} code chunks using the 
  \href{http://styler.r-lib.org/}{\color{blue}{\emph{styler}}} 
  macros in the \emph{RStudio Addins} drop-down menu.\\
  You can also reformat whole files with \texttt{R} code by using the 
  \href{http://styler.r-lib.org/}{\color{blue}{\emph{styler}}} 
  package. 
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Stack Exchange}
\begin{frame}[t]{\subsecname}

\begin{columns}[T]
  \column{0.5\textwidth}
    \begin{block}{Stack Overflow}
      Stack Overflow is a Q\&A forum for computer programming, and is part of Stack Exchange\\
%  Stack Overflow is a Q\&A forum for programmers (covers many different languages)\\
      \hskip1em\url{http://stackoverflow.com}\\
      \hskip1em\url{http://stackoverflow.com/questions/tagged/r}\\
      \hskip1em\url{http://stackoverflow.com/tags/r/info}\\
    \end{block}

    \begin{block}{Stack Exchange}
      Stack Exchange is a family of Q\&A forums in a variety of fields\\
      \hskip1em\url{http://stackexchange.com/}\\
      \hskip1em\url{http://stackexchange.com/sites\#technology}\\
      \hskip1em\url{http://quant.stackexchange.com/}\\
    \end{block}
  \column{0.5\textwidth}
    \includegraphics[height=0.9\textwidth]{image/stack_exchange2.png}
\end{columns}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{\protect\emph{RStudio} Support}
\begin{frame}[t]{\subsecname}

\begin{block}{}
\emph{RStudio} has extensive online help, Q\&A database, and documentation\\
\hskip1em\url{https://support.rstudio.com/hc/en-us}\\
\vskip1ex
\hskip1em\url{https://support.rstudio.com/hc/en-us/sections/200107586-Using-RStudio}\\
\vskip1ex
\hskip1em\url{https://support.rstudio.com/hc/en-us/sections/200148796-Advanced-Topics}\\
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{\texttt{R} Online Books and References}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}

\begin{block}{Hadley Wickham book \emph{Advanced \texttt{R}}}
The best book for learning the advanced features of \texttt{R}:
\hskip1em\url{http://adv-r.had.co.nz/}
\end{block}

\begin{block}{Cookbook for \texttt{R} by Winston Chang from \emph{RStudio}}
Good plotting, but not interactive:
\hskip1em\url{http://www.cookbook-r.com/}
\end{block}

\begin{block}{Efficient \texttt{R} programming by Colin Gillespie and Robin Lovelace}
Good tips for fast \texttt{R} programming:
\hskip1em\url{https://csgillespie.github.io/efficientR/programming.html}
\end{block}

\begin{block}{Endmemo web book}
Good, but not interactive:
\hskip1em\url{http://www.endmemo.com/program/R/}
\end{block}

\begin{block}{Quick-R by Robert Kabacoff}
Good, but not interactive:
\hskip1em\url{http://www.statmethods.net/}
\end{block}

\begin{block}{\texttt{R} for Beginners by Emmanuel Paradis}
Good, basic introduction to \texttt{R}:
\hskip1em\url{http://cran.r-project.org/doc/contrib/Paradis-rdebuts_en.pdf}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{\texttt{R} Online Interactive Courses}
\begin{frame}[fragile,t]{\subsecname}

\begin{block}{Datacamp Interactive Courses}
  Datacamp introduction to \texttt{R}:
  \hskip1em\url{https://www.datacamp.com/courses/introduction-to-r/}
  \vskip1ex
  Datacamp list of free courses:
  \hskip1em\url{https://www.datacamp.com/community/open-courses}
  \vskip1ex
  Datacamp basic statistics in \texttt{R}:
  \hskip1em\url{https://www.datacamp.com/community/open-courses/basic-statistics}
  \vskip1ex
  Datacamp computational finance in \texttt{R}:
  \hskip1em\url{https://www.datacamp.com/community/open-courses/computational-finance-and-financial-econometrics-with-r}
  \vskip1ex
  Datacamp machine learning in \texttt{R}:
  \hskip1em\url{https://www.datacamp.com/community/open-courses/kaggle-r-tutorial-on-machine-learning}
\end{block}

\begin{block}{Try \texttt{R}}
  Interactive \texttt{R} tutorial, but rather basic:
  \hskip1em\url{http://tryr.codeschool.com/}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{\texttt{R} Blogs and Experts}
\begin{frame}[fragile,t]{\subsecname}

\begin{block}{R-Bloggers}
R-Bloggers is an aggregator of blogs dedicated to \texttt{R}\\
\hskip1em\url{http://www.r-bloggers.com/}\\
Tal Galili is the author of R-Bloggers and has his own excellent blog\\
\hskip1em\url{http://www.r-statistics.com/}\\
\end{block}

\begin{block}{Dirk Eddelbuettel}
Dirk is a \emph{Top Answerer} for \texttt{R} questions on Stackoverflow, the author of the \texttt{Rcpp} package, and the CRAN Finance View\\
\hskip1em\url{http://dirk.eddelbuettel.com/}\\
\hskip1em\url{http://dirk.eddelbuettel.com/code/}\\
\hskip1em\url{http://dirk.eddelbuettel.com/blog/}\\
\hskip1em\url{http://www.rinfinance.com/}\\
\end{block}

\begin{block}{Romain Frangois}
Romain is an \texttt{R} Enthusiast and \texttt{Rcpp} Hero\\
\hskip1em\url{http://romainfrancois.blog.free.fr/}\\
\hskip1em\url{http://romainfrancois.blog.free.fr/index.php?tag/graphgallery}\\
\hskip1em\url{http://blog.r-enthusiasts.com/}\\
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\begin{frame}[fragile,t]{More \subsecname}

\begin{block}{Revolution Analytics Blog}
\texttt{R} blog by Revolution Analytics software vendor\\
\hskip1em\url{http://blog.revolutionanalytics.com/}\\
\end{block}

\begin{block}{\emph{RStudio} Blog}
\texttt{R} blog by \emph{RStudio}\\
\hskip1em\url{http://blog.rstudio.org/}\\
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{\protect\emph{GitHub} for Hosting Software Projects Online}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      \emph{GitHub} is an internet-based online service for hosting repositories of software projects.
      \vskip1ex
      \emph{GitHub} provides version control using \emph{git} (desved by Linus Torvalds).
      \vskip1ex
      Most \texttt{R} projects are now hosted on \emph{GitHub}.
      \vskip1ex
      \emph{Google} uses \emph{GitHub} to host its \emph{tensorflow} library for machine learning:\\
      \hskip1em\url{https://github.com/tensorflow/tensorflow}
      \vskip1ex
      All the \emph{FRE-7241} and \emph{FRE-6871} lectures are hosted on \emph{GitHub}:\\
      \hskip1em\url{https://github.com/algoquant/lecture_slides}\\
      \hskip1em\url{https://github.com/algoquant}
      \vskip1ex
      Hosting projects on \emph{Google} is a great way to advertize your skills and network with experts.
    \column{0.5\textwidth}
    \includegraphics[width=0.5\paperwidth]{image/github_algoquant.png}
  \end{columns}
\end{block}

\end{frame}



%%%%%%%%%%%%%%%
\section{Getting Started With \texttt{R}}


%%%%%%%%%%%%%%%
\subsection{What is \texttt{R}?}
\begin{frame}[t]{\subsecname}
\vspace{-1em}
\begin{block}{}
\begin{columns}[T]
  \column{0.7\textwidth}
    \begin{itemize}
      \item An open-source software environment for statistical computing and graphics.
      \item An interpreted language, that allows interactive code development.
      \item A functional language where every operator is an \texttt{R} function.
      \item A very expressive language that can perform complex operations with very few lines of code.
      \item A language with metaprogramming facilities that allow programming on the language.
      \item A language written in \texttt{C/C++}, which can easily call other \texttt{C/C++} programs.
      \item Can be easily extended with \emph{packages} (function libraries), providing the latest developments like \emph{Machine Learning}.
      \item Supports object-oriented programming with \emph{classes} and \emph{methods}.
      \item Vectorized functions written in \texttt{C/C++}, allow very fast execution of loops over vector elements.
    \end{itemize}
  \column{0.3\textwidth}
    \href{http://www.r-project.org/}{\includegraphics[height=0.2\textwidth]{image/Rlogo.png} Project}
    \vskip1ex
    \href{http://en.wikipedia.org/wiki/R_(programming_language)}{\includegraphics[height=0.2\textwidth]{image/Rlogo.png} Wikipedia}
%    \hskip1em\url{http://blog.revolutionanalytics.com/2011/08/what-language-is-r-written-in.html}\\
\end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Differences Between \texttt{R} and \texttt{Python}}
\begin{frame}[t]{\subsecname}
\vspace{-1em}
\begin{block}{}
\begin{columns}[T]
  \column{0.7\textwidth}
    \texttt{R} was designed for statistics and data science, while \texttt{Python} was designed as a general-purpose programming language.\\
    \begin{itemize}
      \item \texttt{R} was designed for statistics and data science - \texttt{Python} wasn't.
      \item \texttt{R} has native date and time objects built in - \texttt{Python} doesn't.
      \item \texttt{R} has native dataframe objects built in - \texttt{Python} doesn't.
      \item \texttt{R} has native vector and matrix objects built in - \texttt{Python} doesn't.
      \item \texttt{R} is designed to be easily extended with \texttt{C++} code - \texttt{Python} isn't.
    \end{itemize}
  \column{0.3\textwidth}
    \href{http://blog.ephorie.de/why-r-for-data-science-and-not-python}{Why R is Better Than Python}
    \vskip1ex
    \href{http://blog.ephorie.de/why-r-for-data-science-and-not-python}{Why R is Better Than Python}
\end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Why is \texttt{R} More Difficult Than Other Languages?}
\begin{frame}[t]{\subsecname}
\vspace{-1em}
\begin{block}{}
\begin{columns}[T]
  \column{0.7\textwidth}
    \texttt{R} is more difficult than other languages because:
    \begin{itemize}
      \item \texttt{R} is a \emph{functional} language, which makes its syntax unfamiliar to users of procedural languages like \texttt{C/C++}.
      \item The huge number of user-created \emph{packages} makes it difficult to tell which are the best for particular applications.
      \item \texttt{R} can produce very cryptic \emph{warning} and \emph{error} messages, because it's a programming environment, so it performs many operations quietly, but those can sometimes fail.
      \item Fixing errors usually requires analyzing the complex structure of the \texttt{R} programming environment.
    \end{itemize}
    This course is designed to teach the most useful elements of \texttt{R} for financial analysis, through case studies and examples,
  \column{0.3\textwidth}
    \includegraphics[height=0.2\textwidth]{image/Rlogo.png}
\end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{What are the Best Ways to Use \texttt{R}?}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      If used properly, \texttt{R} can be fast and interactive:
      \begin{itemize}
        \item Avoid using \texttt{apply()} and \texttt{for()} loops for large datasets.
        \item Pre-allocate memory for new objects.
        \item Avoid using too many \texttt{R} function calls (every command in \texttt{R} is a function).
        \item Use \texttt{R} as an interface to libraries written in \texttt{C++}, \texttt{Java}, and \texttt{JavaScript}.
        \item Use \texttt{R} functions which are \emph{compiled} \texttt{C++} code, instead of using interpreted \texttt{R} code.
        \item Write \texttt{C++} functions in \emph{Rcpp} and \emph{RcppArmadillo}.
        \item Use package \emph{data.table} for high performance data management.
        \item Use package \emph{shiny} for interactive charts of live models running in \texttt{R}.
        \item Use package \emph{dygraphs} for interactive time series plots.
        \item Use package \emph{knitr} for \emph{RMarkdown} documents.
      \end{itemize}
    \column{0.5\textwidth}
      \vspace{-1em}
      \includegraphics[width=0.45\paperwidth]{image/Jeremy_Clarkson_Linus_Torvalds.jpg}
      \vspace{-1em}
      <<echo=TRUE,eval=FALSE>>=
# Calculate cumulative sum of a vector
vecv <- runif(1e5)
# Use compiled function
cumsumv <- cumsum(vecv)
# Use for loop
cumsumv2 <- vecv
for (i in 2:NROW(vecv))
  cumsumv2[i] <- (vecv[i] + cumsumv2[i-1])
# Compare the outputs of the two methods
all.equal(cumsumv, cumsumv2)
# Microbenchmark the two methods
library(microbenchmark)
summary(microbenchmark(
  cumsum=cumsum(vecv), # Vectorized
  loop_alloc={cumsumv2 <- vecv # Allocate memory to cumsumv3
    for (i in 2:NROW(vecv))
cumsumv2[i] <- (vecv[i] + cumsumv2[i-1])
  },
  loop_nalloc={cumsumv3 <- vecv[1] # Doesn't allocate memory to cumsumv3
    for (i in 2:NROW(vecv))
cumsumv3[i] <- (vecv[i] + cumsumv3[i-1])
  }, times=10))[, c(1, 4, 5)]
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{The \texttt{R} License}
\begin{frame}[t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.7\textwidth}
      \texttt{R} is open-source software released under the GNU General Public License:
      \vskip1ex
      \hskip1em\url{http://www.r-project.org/Licenses}\\
    \column{0.3\textwidth}
      \includegraphics[height=0.2\textwidth]{image/GPLv3_Logo.png}
  \end{columns}
\end{block}

\begin{block}{}
  \begin{columns}[T]
    \column{0.7\textwidth}
      Some other \texttt{R} packages are released under the Creative Commons Attribution-ShareAlike License:
      \vskip1ex
      \hskip1em\url{http://creativecommons.org}\\
    \column{0.3\textwidth}
      \includegraphics[height=0.1\textwidth]{image/CC_License.png}
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Installing \texttt{R} and \protect\emph{RStudio}}
\begin{frame}[t]{\subsecname}

\begin{block}{}
  Students will be required to bring their laptop computers to all the lectures, and to run the \texttt{R} Interpreter and \textbf{RStudio} RStudio during the lecture,
  \vskip1ex
  Laptop computers will be necessary for following the lectures, and for performing tests,
\end{block}

\begin{block}{}
  \begin{columns}[T]
    \column{0.7\textwidth}
      Students will be required to install and to become proficient with the \texttt{R} Interpreter,\\
      Students can download the \texttt{R} Interpreter from \texttt{CRAN} (Comprehensive \texttt{R} Archive Network):\\
      \hskip1em\url{http://cran.r-project.org/}
      \vskip1ex
      To invoke the \texttt{RGui} interface, click on:\\
      \href{C:/Program Files/R/R-3.1.2/bin/x64/RGui.exe}{C:/Program Files/R/R-3.1.2/bin/x64/RGui.exe}\\
    \column{0.3\textwidth}
      \includegraphics[height=0.2\textwidth]{image/Rlogo.png}
  \end{columns}
\end{block}

\begin{block}{}
  \begin{columns}[T]
    \column{0.7\textwidth}
      Students will be required to install and to become proficient with the \emph{RStudio} Integrated Development Environment (\emph{IDE}),\\
      \hskip1em\url{http://www.rstudio.com/products/rstudio/}
    \column{0.3\textwidth}
      \includegraphics[height=0.2\textwidth]{image/RStudio.png}
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Using \protect\emph{RStudio}}
\begin{frame}[t]{\subsecname}

% Snapshot of \emph{RStudio} GUI
\includegraphics[height=0.6\textwidth]{image/RStudio_screen.png}

\end{frame}



%%%%%%%%%%%%%%%
\section{The \texttt{R} Environment}


%%%%%%%%%%%%%%%
\subsection{A First \texttt{R} Session}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}

\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      Variables are created by an assignment operation, and they don't have to be declared.
      \vskip1ex
      The standard assignment operator in \texttt{R} is the arrow symbol \texttt{"<-"}.
      \vskip1ex
      \texttt{R} interprets text in quotes ("") as character strings.
      \vskip1ex
      Text that is not in quotes ("") is interpreted as a \emph{symbol} or \emph{expression}.
      \vskip1ex
      Typing a \emph{symbol} or \emph{expression} evaluates it.
      \vskip1ex
      \texttt{R} uses the hash "\texttt{\#}" sign to mark text as comments.
      \vskip1ex
      All text after the hash "\texttt{\#}" sign is treated as a comment, and is not executed as code.
    \column{0.5\textwidth}
      \vspace{-1em}
      <<echo=TRUE,eval=TRUE>>=
# "<-" and "=" are valid assignment operators
myvar <- 3

# typing a symbol or expression evaluates it
myvar

# text in quotes is interpreted as a string
myvar <- "Hello World!"

# typing a symbol or expression evaluates it
myvar

myvar  # text after hash is treated as comment
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Exploring an \texttt{R} Session}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}

\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      The function \texttt{getwd()} returns a vector of length \texttt{1}, with the first element containing a string with the name of the current working directory (\texttt{cwd}).
      \vskip1ex
      The function \texttt{setwd()} accepts a character string as input (the name of the directory), and sets the working directory to that string.
      \vskip1ex
      \texttt{R} is a functional language, and \texttt{R} commands are functions, so they must be followed by parentheses \texttt{"()"}.
    \column{0.5\textwidth}
      \vspace{-1em}
      <<echo=TRUE,eval=FALSE>>=
getwd()  # get cwd
setwd("/Users/jerzy/Develop/R")  # Set cwd
getwd()  # get cwd
      @
  \end{columns}
\end{block}

\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      Get system date and time
      \vskip4ex
      Just the date
    \column{0.5\textwidth}
      \vspace{-1em}
      <<echo=TRUE,eval=TRUE>>=
Sys.time()  # get date and time

Sys.Date()  # get date only
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{The \texttt{R} Workspace}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}

\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      The workspace is the current \texttt{R} working environment, which includes all user-defined objects and the command history.
      \vskip1ex
      The function \texttt{ls()} returns names of objects in the \texttt{R} workspace.
      \vskip1ex
      The function \texttt{rm()} removes objects from the \texttt{R} workspace.
      \vskip1ex
      The workspace can be saved into and loaded back from an \texttt{.RData} file (compressed binary file format).
      \vskip1ex
      The function \texttt{save.image()} saves the whole workspace.
      \vskip1ex
      The function \texttt{save()} saves just the selected objects.
      \vskip1ex
      The function \texttt{load()} reads data from \texttt{.RData} files, and \emph{invisibly} returns a vector of names of objects created in the workspace.
    \column{0.5\textwidth}
      \vspace{-1em}
      <<echo=(-(1:2)),eval=FALSE>>=
rm(list=ls())
setwd("/Users/jerzy/Develop/lecture_slides/data")
var1 <- 3  # Define new object
ls()  # List all objects in workspace
# List objects starting with "v"
ls(pattern=glob2rx("v*"))
# Delete all objects in workspace starting with "v"
rm(list=ls(pattern=glob2rx("v*")))
save.image()  # Save workspace to file .RData in cwd
rm(var1)  # Remove object
ls()  # List objects
load(".RData")
ls()  # List objects
var2 <- 5  # Define another object
save(var1, var2,  # Save selected objects
     file="/Users/jerzy/Develop/lecture_slides/data/my_data.RData")
rm(list=ls())  # Delete all objects in workspace
ls()  # List objects
loadv <- load(file="/Users/jerzy/Develop/lecture_slides/data/my_data.RData")
loadv
ls()  # List objects
      @
  \end{columns}
\end{block}
% \pause

\end{frame}


%%%%%%%%%%%%%%%
\begin{frame}[fragile,t]{\subsecname \hskip0.5em (cont.)}
\vspace{-1em}

\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      When you quit \texttt{R} you'll be prompted "Save workspace image?"\\
      \vskip1ex
      If you answer $YES$ then the workspace will be saved into the \texttt{.RData} file in the \texttt{cwd},\\
      \vskip1ex
      When you start \texttt{R} again, the workspace will be automatically loaded from the existing \texttt{.RData} file,\\
    \column{0.5\textwidth}
      \vspace{-1em}
      <<echo=TRUE,eval=FALSE>>=
        q()  # quit R session
      @
  \end{columns}
\end{block}

\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      The function \texttt{history()} displays recent commands,\\
      \vskip1ex
      You can also save and load the command history from a file.
    \column{0.5\textwidth}
      \vspace{-1em}
      <<echo=TRUE,eval=FALSE>>=
history(5)  # Display last 5 commands
savehistory(file="myfile")  # Default is ".Rhistory"
loadhistory(file="myfile")  # Default is ".Rhistory"
      @
  \end{columns}
\end{block}
% \pause

\end{frame}


%%%%%%%%%%%%%%%
\subsection{\texttt{R} Session Info}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      The function \texttt{sessionInfo()} returns information about the current \texttt{R} session,
      \begin{itemize}
        \item \texttt{R version},
        \item \texttt{OS platform},
        \item \texttt{locale} settings,
        \item list of packages that are loaded and attached to the search path,
        \item list of packages that are loaded, but \emph{not} attached to the search path,
      \end{itemize}
    \column{0.5\textwidth}
      \vspace{-1em}
      <<echo=TRUE,eval=TRUE>>=
sessionInfo()  # get R version and other session info
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Environment Variables}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      \texttt{R} uses environment variables to store information about its environment, such as paths to directories containing files used by \texttt{R} (startup, history, OS).
      \vskip1ex
      For example the environment variables:
      \begin{itemize}
        \item \texttt{R\_USER} and \texttt{HOME} store the \texttt{R} user Home directory,
        \item \texttt{R\_HOME} stores the root directory of the \texttt{R} installation,
      \end{itemize}
      The functions \texttt{Sys.getenv()} and \texttt{Sys.setenv()} display and set the values environment variables.
      \vskip1ex
      \texttt{Sys.getenv("env\_var")} displays the environment variable \texttt{"env\_var"}.
      \vskip1ex
      \texttt{Sys.setenv("env\_var=value")} sets the environment variable \texttt{"env\_var"} equal to \texttt{"value"}.
    \column{0.5\textwidth}
      \vspace{-1em}
      <<echo=TRUE,eval=FALSE>>=
Sys.getenv()[5:7]  # List some environment variables

Sys.getenv("HOME")  # get R user HOME directory

Sys.setenv(Home="/Users/jerzy/Develop/data")  # Set HOME directory

Sys.getenv("HOME")  # get user HOME directory

Sys.getenv("R_HOME")  # get R_HOME directory

R.home()  # get R_HOME directory

R.home("etc")  # get "etc" sub-directory of R_HOME
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Global \protect\emph{Options} Settings}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      \texttt{R} uses a list of global \emph{options} which affect how \texttt{R} computes and displays results.
      \vskip1ex
      The function \texttt{options()} either sets or displays the values of global \emph{options}.
      \vskip1ex
      \texttt{options("globop")} displays the current value of option \texttt{"globop"}.
      \vskip1ex
      \texttt{getOption("globop")} displays the current value of option \texttt{"globop"}.
      \vskip1ex
      \texttt{options(globop=value)} sets the option \texttt{"globop"} equal to \texttt{"value"}.
    \column{0.5\textwidth}
      \vspace{-1em}
      <<echo=TRUE,eval=FALSE>>=
# ?options  # Long list of global options
# Interpret strings as characters, not factors
getOption("stringsAsFactors")  # Display option
options("stringsAsFactors")  # Display option
options(stringsAsFactors=FALSE)  # Set option
# number of digits printed for numeric values
options(digits=3)
# control exponential scientific notation of print method
# positive "scipen" values bias towards fixed notation
# negative "scipen" values bias towards scientific notation
options(scipen=100)
# maximum number of items printed to console
options(max.print=30)
# Warning levels options
# negative - warnings are ignored
options(warn=-1)
# zero - warnings are stored and printed after top-confl function has completed
options(warn=0)
# One - warnings are printed as they occur
options(warn=1)
# two or larger - warnings are turned into errors
options(warn=2)
# Save all options in variable
optionv <- options()
# Restore all options from variable
options(optionv)
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Constructing File Paths}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      Names of \emph{file paths} can be constructed using the function \texttt{paste()}.
      \vskip1ex
      The function \texttt{file.path()} is similar to \texttt{paste()}, but it also automatically uses the correct file separator for the computer platform.
      \vskip1ex
      The function \texttt{normalizePath()} performs tilde-expansions and displays file paths in user-readable format.
    \column{0.5\textwidth}
      \vspace{-1em}
      <<echo=TRUE,eval=TRUE>>=
# R startup (site) directory
paste(R.home(), "etc", sep="/")

file.path(R.home(), "etc")  # better way

# perform tilde-expansions and convert to readable format
normalizePath(file.path(R.home(), "etc"), winslash="/")

normalizePath(R.home("etc"), winslash="/")
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{\texttt{R} System Directories under \protect\emph{Windows}}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      \texttt{R} uses several different directories to search, read, and store files:
      \begin{itemize}
        \item \emph{Windows} user \texttt{personal} directory: \texttt{"\textasciitilde{}"} (\texttt{"\%USERPROFILE\%/Documents"}),
        \item \texttt{R} user \texttt{HOME} directory (\texttt{R\_USER} and \texttt{Home}),
        \item \texttt{cwd} current working directory - the default directory for storing and retrieving user files (such as \texttt{.Rhistory}, \texttt{.RData}, etc.),
        \item \texttt{R\_HOME} root directory of the \texttt{R} installation,
        \item \texttt{R} startup (site) directory: \texttt{R\_HOME/etc/},
      \end{itemize}
      By default, the \texttt{R} user \texttt{HOME} directory is the \emph{Windows} user \texttt{personal} directory.
      \vskip1ex
      The \texttt{cwd} is set to the directory from which \texttt{R} is invoked, or the \texttt{R} user \texttt{HOME} directory.
    \column{0.5\textwidth}
      \vspace{-1em}
      <<echo=TRUE,eval=FALSE>>=
normalizePath("~", winslash="/")  # Windows user HOME directory

Sys.getenv("HOME")  # R user HOME directory

setwd("/Users/jerzy/Develop/R")
getwd()  # current working directory

# R startup (site) directory
normalizePath(file.path(R.home(), "etc"), winslash="/")

# R executable directory
normalizePath(file.path(R.home(), "bin/x64"), winslash="/")

# R documentation directory
normalizePath(file.path(R.home(), "doc/manual"), winslash="/")
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{File and Directory Listing Functions}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      \vskip1ex
      The functions \texttt{list.files()} and \texttt{dir()} return a vector of names of files in a given directory.
      \vskip1ex
      The function \texttt{list.dirs()} listv the directories in a given directory.
      \vskip1ex
      The function \texttt{Sys.glob()} listv files matching names obtained from wildcard expansion.
    \column{0.5\textwidth}
      \vspace{-1em}
      <<echo=TRUE,eval=FALSE>>=
sample(dir(), 5)  # get 5 file names - dir() lists all files
sample(dir(pattern="csv"), 5)  # List files containing "csv"
sample(list.files(R.home()), 5)  # All files in R_HOME directory
sample(list.files(R.home("etc")), 5)  # All files in "etc" sub-directory of R_HOME directory
sample(list.dirs(), 5)  # Directories in cwd
list.dirs(R.home("etc"))  # Directories in "etc" sub-directory
sample(Sys.glob("*.csv"), 5)
Sys.glob(R.home("etc"))
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Invoking an \texttt{R} Session in \protect\emph{Windows}}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      An \texttt{R} session can run in several different ways:
      \begin{itemize}
        \item In an \texttt{R} terminal (by invoking \texttt{R.exe} or \texttt{Rterm.exe}),
        \item In an \texttt{R} RGui (by invoking \texttt{RGui.exe}),
        \item In an \emph{RStudio} session (or some other IDE),
      \end{itemize}
      The initial value of the \texttt{cwd} depends on how the \texttt{R} session is invoked.\\
      If \texttt{R} is invoked:
      \begin{itemize}
        \item from the \emph{Windows} menu, then \texttt{cwd} is set to the \texttt{R} user \texttt{HOME} directory,
        \item by clicking on a file (\texttt{*.R}, \texttt{.RData}, etc.), then \texttt{cwd} is set to the file's directory,
        \item by typing \texttt{R.exe} or \texttt{Rterm.exe} in the command shell (after setting the \texttt{PATH}), then \texttt{cwd} is set to the directory where the command was typed,
      \end{itemize}
    \column{0.5\textwidth}
      \vspace{-1em}
      <<echo=TRUE,eval=TRUE>>=
getwd()  # get cwd
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{\texttt{R} Session Startup}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      At startup \texttt{R} sources (reads) several types of files, in the following order:
      \begin{itemize}
        \item \texttt{Renviron} files defining environment variables,
        \item \texttt{Rprofile} files containing code executed at \texttt{R} startup,
        \item \texttt{RData} files containing data to be loaded at \texttt{R} startup,
      \end{itemize}
      \texttt{R} sources files from several directories, in the following order:
      \begin{itemize}
        \item \texttt{R} startup directory: \texttt{Renviron.site} and \texttt{Rprofile.site} files,
        \item \texttt{cwd} directory: \texttt{.Renviron}, \texttt{.Rprofile}, and \texttt{.RData} files,
        \item \texttt{HOME} user directory (only if no files found in \texttt{cwd}),
      \end{itemize}
      The above startup process can be customized by setting environment variables.
    \column{0.5\textwidth}
      \vspace{-1em}
      <<echo=(-1),eval=FALSE>>=
setwd("/Users/jerzy/Develop/R")
# help(Startup)  # Description of R session startup mechanism

# files in R startup directory directory
dir(normalizePath(file.path(R.home(), "etc"), winslash="/"))

# *.R* files in cwd directory
getwd()
dir(getwd(), all.files=TRUE, pattern="\\.R")
dir(getwd(), all.files=TRUE, pattern=glob2rx("*.R*"))
      @
  \end{columns}
\end{block}

\end{frame}



%%%%%%%%%%%%%%%
\section{Data Objects}


%%%%%%%%%%%%%%%
\subsection{Data Objects in \texttt{R}}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      All data objects in \texttt{R} are \emph{vectors}, or consist of \emph{vectors}.
      \vskip1ex
      Single numbers and character strings are vectors of length \texttt{"1"}.
      \vskip1ex
      \emph{Atomic} vectors are \emph{homogeneous} objects whose elements are all of the same \emph{mode} (type).
      \vskip1ex
      \emph{Lists} and \emph{data frames} are \emph{recursive} (heterogeneous) objects, whose elements can be vectors of different \emph{mode}.
      \vskip1ex
      The functions \texttt{is.atomic()} and \texttt{is.recursive()} return logical values depending on whether their arguments are \emph{atomic} or \emph{recursive}.
      \vskip1ex
      \renewcommand\arraystretch{1.5} % scale table rows
      \renewcommand\tabcolsep{8pt} % set table column width - 6pt is default
      \centering{{\color{blue}{\texttt{R} Data Objects}}}\\[1ex]
      \begin{tabular}{c||c|c|}
        & \text{\emph{Atomic}} & \text{\emph{Recursive}} \\
        \hline
        \hline
        \text{1-dim} & Vectors & Lists \\
        \hline
        \text{2-dim} & Matrices & Data frames \\
        \hline
        \text{n-dim} & Arrays & NA \\
      \end{tabular}
    \column{0.5\textwidth}
      \vspace{-1em}
        <<echo=TRUE,eval=TRUE>>=
# Single numbers are vectors of length 1
1
# Character strings are vectors of length 1
"a"
# Strings without quotes are variable names
a  # Variable "a" doesn't exist
# List elements can have different mode
list(aa=c("a", "b"), bb=1:5)
data.frame(aa=c("a", "b"), bb=1:2)
is.atomic(data.frame(aa=c("a", "b"), bb=1:2))
is.recursive(data.frame(aa=c("a", "b"), bb=1:2))
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Type, Mode, and Class of Objects}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      The \emph{type}, \emph{mode}, and \emph{class} are \texttt{character} strings representing various object properties.
      \vskip1ex
      The \emph{type} of an atomic object represents how it's stored in memory (\texttt{logical}, \texttt{character}, \texttt{integer}, \texttt{double}, etc.)
      \vskip1ex
      The \emph{mode} of an atomic object is the kind of data it represents (\texttt{logical}, \texttt{character}, \texttt{numeric}, etc.)
      \vskip1ex
      The \emph{mode} of an object often coincides with its \emph{type} (except for \texttt{integer} and \texttt{double} types).
      \vskip1ex
      Recursive objects (\texttt{listv}, \texttt{data frames}) have both \emph{type} and \emph{mode} equal to the recursive type (\texttt{list}).
      \vskip1ex
      The \emph{class} of an object is given by either an explicit \emph{class} attribute, or is derived from the object \emph{mode} and its \texttt{dim} attribute (implicit \emph{class}).
      \vskip1ex
      The function \texttt{class()} returns the explicit or implicit \emph{class} of an object.
      \vskip1ex
      The object \emph{class} is used for method dispatching in the \texttt{S3} object-oriented programming system in \texttt{R}.
    \column{0.5\textwidth}
      \vspace{-1em}
      <<echo=TRUE,eval=TRUE>>=
myvar <- "hello"
c(typeof(myvar), mode(myvar), class(myvar))

myvar <- 1:5
c(typeof(myvar), mode(myvar), class(myvar))

myvar <- runif(5)
c(typeof(myvar), mode(myvar), class(myvar))

myvar <- matrix(1:10, 2, 5)
c(typeof(myvar), mode(myvar), class(myvar))

myvar <- matrix(runif(10), 2, 5)
c(typeof(myvar), mode(myvar), class(myvar))

myvar <- list(aa=c("a", "b"), bb=1:5)
c(typeof(myvar), mode(myvar), class(myvar))

myvar <- data.frame(aa=c("a", "b"), bb=1:2)
c(typeof(myvar), mode(myvar), class(myvar))
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{\texttt{R} Object Attributes}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      \texttt{R} objects can have different attributes, such as: \texttt{names}, \texttt{dimnames}, \texttt{dimensions}, \emph{class}, etc.
      \vskip1ex
      The attributes of an object is a named \texttt{list} of \texttt{symbol=value} pairs.
      \vskip1ex
      The function \texttt{attributes()} returns the attributes of an object.
      \vskip1ex
      The attributes of an \texttt{R} object can be modified using the \texttt{"attributes() <-"} assignment.
      \vskip1ex
      The function \texttt{structure()} adds attributes (specified as \texttt{symbol=value} pairs) to an object, and returns it.
      \vskip1ex
      A \texttt{vector} that is assigned an attribute other than \texttt{names} is not treated as a \texttt{vector}.
      \vskip1ex
      The function \texttt{is.vector()} returns \texttt{TRUE} if its argument is a vector, and returns \texttt{FALSE} otherwise.
    \column{0.5\textwidth}
      \vspace{-1em}
      <<echo=TRUE,eval=TRUE>>=
# A simple vector has no attributes
attributes(5:10)
myvar <- c(pi=pi, euler=exp(1), gamma=-digamma(1))
# Named vector has "names" attribute
attributes(myvar)
myvar <- 1:10
is.vector(myvar)  # Is the object a vector?
attributes(myvar) <- list(my_attr="my_attr")
myvar
is.vector(myvar)  # Is the object a vector?
myvar <- 0
attributes(myvar) <- list(class="Date")
myvar  # "Date" object
structure(0, class="Date")  # "Date" object
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Modifying \protect\emph{class} Attributes}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      Objects without an explicit \emph{class} don't have a \emph{class} attribute, and the function \texttt{class()} returns the implicit \emph{class}.
      \vskip1ex
      The \emph{class} of an object can be modified using the \texttt{"class() <-"} assignment.
      \vskip1ex
      An object can have a main \emph{class}, and also an inherited \emph{class} (the \emph{class} attribute can be a vector of strings).
      \vskip1ex
      The function \texttt{unclass()} removes the explicit class attribute from an object.
    \column{0.5\textwidth}
      \vspace{-1em}
      <<echo=TRUE,eval=TRUE>>=
myvar <- matrix(runif(10), 2, 5)
class(myvar)  # Has implicit class
# But no explicit "class" attribute
attributes(myvar)
c(typeof(myvar), mode(myvar), class(myvar))
# Assign explicit "class" attribute
class(myvar) <- "my_class"
class(myvar)  # Has explicit "class"
# Has explicit "class" attribute
attributes(myvar)
is.matrix(myvar)  # Is the object a matrix?
is.vector(myvar)  # Is the object a vector?
attributes(unclass(myvar))
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Implicit Class of Objects}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      If an object has no explicit \emph{class}, then its implicit \emph{class} is derived from its \emph{mode} and \texttt{dim} attribute (except for \texttt{integer} vectors which have the implicit class \texttt{"integer"} derived from their \emph{type}).
      \vskip1ex
      If an \emph{atomic} object has a \texttt{dim} attribute, then its implicit \emph{class} is \texttt{matrix} or \texttt{array}.
      \vskip1ex
      \texttt{Data frames} have no explicit \texttt{dim} attribute, but \texttt{dim()} returns a value, so they have an implicit \texttt{dim} attribute.
    \column{0.5\textwidth}
      \vspace{-1em}
      <<echo=TRUE,eval=TRUE>>=
# Integer implicit class derived from type
myvar <- vector(mode="integer", length=10)
c(typeof(myvar), mode(myvar), class(myvar))
# Numeric implicit class derived from mode
myvar <- vector(mode="numeric", length=10)
c(typeof(myvar), mode(myvar), class(myvar))
# Adding dim attribute changes implicit class to matrix
dim(myvar) <- c(5, 2)
c(typeof(myvar), mode(myvar), class(myvar))
# Data frames have implicit dim attribute
myvar <- data.frame(aa=c("a", "b"), bb=1:2)
c(typeof(myvar), mode(myvar), class(myvar))
attributes(myvar)
dim(myvar)
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Object Coercion}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      \emph{Coercion} means changing the \emph{type}, \emph{mode}, or \emph{class} of an object, often without changing the underlying data.
      \vskip1ex
      Changing the \emph{mode} of an object can change its \emph{class} as well, but not always.
      \vskip1ex
      Objects can be explicitly coerced using the \texttt{"as.*"} coercion functions.
      \vskip1ex
      Most coercion functions strip the \emph{attributes} from the object.
      \vskip1ex
      Implicit coercion occurs when objects with different \texttt{modes} are combined into a vector, forcing the elements to have the same \emph{mode}.
      \vskip1ex
      Implicit coercion can cause bugs that are difficult to trace.
      \vskip1ex
      The rule is that coercion is into larger types (\texttt{numeric} objects are coerced into \texttt{character} strings).
      \vskip1ex
      Coercion can introduce bad data, such as \texttt{NA} values.
    \column{0.5\textwidth}
      \vspace{-1em}
      <<echo=TRUE,eval=TRUE>>=
myvar <- 1:5
c(typeof(myvar), mode(myvar), class(myvar))
mode(myvar) <- "character"  # Coerce to "character"
myvar
c(typeof(myvar), mode(myvar), class(myvar))
# Explicitly coerce to "character"
myvar <- as.character(1:5)
c(typeof(myvar), mode(myvar), class(myvar))
matv <- matrix(1:10, 2, 5)  # Create matrix
# Explicitly coerce to "character"
matv <- as.character(matv)
c(typeof(matv), mode(matv), class(matv))
# Coercion converted matrix to vector
c(is.matrix(matv), is.vector(matv))
as.logical(0:3)  # Explicit coercion to "logical"
as.numeric(c(FALSE, TRUE, TRUE, TRUE))
c(1:3, "a")  # Implicit coercion to "character"
# Explicit coercion to "numeric"
as.numeric(c(1:3, "a"))
      @
  \end{columns}
\end{block}

\end{frame}



%%%%%%%%%%%%%%%
\section{Atomic Data Objects}


%%%%%%%%%%%%%%%
\subsection{Basic \texttt{R} Objects}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      The quotation marks \texttt{""} (or \texttt{''}) around a character string tell \texttt{R} that it's a string, not a variable name.
      \vskip1ex
      Vectors are the basic building blocks of \texttt{R} objects.
      \vskip1ex
      There are no scalars in \texttt{R}, and single values are stored as vectors of length \texttt{"1"}.
      \vskip1ex
      A character string is also a vector with a single element, with the first element of the vector containing the string of text.
      \vskip1ex
      The colon binary operator \texttt{':'} produces a vector.
      \vskip1ex
      The function \texttt{c()} combines objects into a vector.
      \vskip1ex
      The \texttt{"[1]"} symbol means the return value is a vector.
      \vskip1ex
      The function \texttt{is.vector()} returns \texttt{TRUE} if its argument is a vector, and returns \texttt{FALSE} otherwise.
    \column{0.5\textwidth}
      \vspace{-1em}
      <<echo=TRUE,eval=FALSE>>=
"Hello World!"  # Type some text
# hello is a variable name, because it's not in quotes
hello  # R interprets "hello" as a variable name
is.vector(1)  # Single number is a vector
is.vector("a")  # String is a vector
4:8  # Create a vector
# Create vector using c() combine function
c(1, 2, 3, 4, 5)
# Create vector using c() combine function
c("a", "b", "c")
# Create vector using c() combine function
c(1, "b", "c")
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Character Strings}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      Character \texttt{strings} are sequences of characters (and vectors of length one).
      \vskip1ex
      The function \texttt{nchar()} returns the length of a string.
      \vskip1ex
      Special characters in strings:\\
      \texttt{"\textbackslash{}t"} for TAB,\\
      \texttt{"\textbackslash{}n"} for new-line,\\
      "\texttt{\textbackslash{}}\texttt{\textbackslash{}}" for a (single) backslash character
      \vskip1ex
      The function \texttt{cat()} concatenates strings and echos them to console, without returning any values.
      \vskip1ex
      The function \texttt{cat()} is useful in user-defined functions.
    \column{0.5\textwidth}
      \vspace{-1em}
      <<echo=TRUE,eval=TRUE>>=
stringv <- "Some string"
stringv
stringv[1]
stringv[2]

NROW(stringv)  # length of vector
nchar(stringv)  # length of string

# Concatenate and echo to console
cat("Hello", "World!")
cat("Enter\ttab")
cat("Enter\nnewline")
cat("Enter\\backslash")
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Manipulating Strings}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      The function \texttt{paste()} concatenates its arguments into a string, coerces them to characters if needed, and returns the string.
      \vskip1ex
      If a vector or list is passed to \texttt{paste()}, together with a \texttt{collapse} string, then \texttt{paste()} concatenates the elements into a string, separated by the \texttt{collapse} string.
      \vskip1ex
      The function \texttt{strsplit()} splits the elements of a character vector.
      \vskip1ex
      Splitting on the \texttt{"."} character requires surrounding it with brackets: \texttt{"[.]"}, or using argument \texttt{fixed=TRUE}.
      \vskip1ex
      The function \texttt{substring()} extracts or replaces substrings in a character string.
      \vskip1ex
      The recycling rule extends the length to match the longest object.
    \column{0.5\textwidth}
      \vspace{-1em}
      <<echo=TRUE,eval=TRUE>>=
stringv1 <- "Hello"  # Define a character string
stringv2 <- "World!"  # Define a character string
paste(stringv1, stringv2, sep=" ")  # Concatenate and return value
cat(stringv1, stringv2)  # Concatenate and echo to console
paste("a", 1:4, sep="-")  # Convert, recycle and concatenate
paste(c("a1", "a2", "a3"), collapse="+")  # Collapse vector to string
paste(list("a1", "a2", "a3"), collapse="+")
paste("Today is", Sys.time())  # Coerce and concatenate strings
paste("Today is", format(Sys.time(), "%B-%d-%Y"))
strsplit("Hello World", split="r")  # Split string
strsplit("Hello.World", split="[.]")  # Split string
strsplit("Hello.World", split=".", fixed=TRUE)  # Split string
substring("Hello World", 3, 6)  # Extract characters from 3 to 6
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Regular Expressions in \texttt{R}}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      \texttt{R} has Regex functions for pattern matching and replacement.
      \vskip1ex
      The function \texttt{gsub()} replaces all matches of a pattern in a string.
      \vskip1ex
      The function \texttt{grep()} searches for matches of a pattern in a string.
      \vskip1ex
      The function \texttt{glob2rx()} converts globbing wildcard patterns into regular expressions.
    \column{0.5\textwidth}
      \vspace{-1em}
      <<echo=TRUE,eval=TRUE>>=
gsub("is", "XX", "is this gratis?")  # Replace "is" with "XX"

grep("b", c("abc", "xyz", "cba d", "bbb"))  # Get indexes

grep("b", c("abc", "xyz", "cba d", "bbb"), value=TRUE)  # Get values

glob2rx("abc.*")  # Convert globs into regex
glob2rx("*.doc")
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Vectors}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      Vectors are the basic building blocks of \texttt{R} objects.
      \vskip1ex
      There are no scalars in \texttt{R}, and single values are stored as vectors of length \texttt{"1"}.
      \vskip1ex
      The function \texttt{c()} combines values into a vector.
      \vskip1ex
      The function \texttt{is.vector()} returns \texttt{TRUE} if its argument is a vector, and returns \texttt{FALSE} otherwise.
      \vskip1ex
      The object \texttt{letters} is a constant and a vector,
     \column{0.5\textwidth}
      \vspace{-1em}
      <<echo=TRUE,eval=TRUE>>=
is.vector(1)  # Single number is a vector
is.vector("a")  # String is a vector
vecv <- c(8, 6, 5, 7)  # Create vector
vecv
vecv[2]  # Extract second element
# Extract all elements, except the second element
vecv[-2]
# Create Boolean vector
c(FALSE, TRUE, TRUE)
# Extract second and third elements
vecv[c(FALSE, TRUE, TRUE)]
letters[5:10]  # Vector of letters
c("a", letters[5:10])  # Combine two vectors of letters
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\begin{frame}[fragile,t]{Creating \subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      The colon operator (\texttt{":"}) provides a simple way of creating a numeric vector.
      \vskip1ex
      The function \texttt{vector()} returns a vector of the specified \emph{mode}.
      \vskip1ex
      The functions \texttt{seq()}, \texttt{seq\_len()}, and \texttt{seq\_along()} return a sequence (vector) of numbers.
      \vskip1ex
      The function \texttt{rep()} replicates an object multiple times.
      \vskip1ex
      The functions \texttt{character()} and \texttt{numeric()} return zero-length vectors of the specified \emph{mode} (not to be confused with a \texttt{NULL} object).
      \vskip1ex
      Zero length vectors are not the same as \texttt{NULL} objects.
    \column{0.5\textwidth}
      \vspace{-1em}
      <<echo=TRUE,eval=TRUE>>=
0:10  # Vector of integers from 0 to 10
vector()  # Create empty vector
vector(mode="numeric", length=10)  # Numeric vector of zeros
seq(10)  # Sequence from 1 to 10
seq(along=(-5:5))  # Instead of 1:NROW(obj)
seq_along(c("a", "b", "c"))  # Instead of 1:NROW(obj)
seq(from=0, to=1, len=11)  # Decimals from 0 to 1.0
seq(from=0, to=1, by=0.1)  # Decimals from 0 to 1.0
seq(-2,2, len=11)  # 10 numbers from -2 to 2
rep(100, times=5)  # Replicate a number
character(5)  # Create empty character vector
numeric(5)  # Create empty numeric vector
numeric(0)  # Create zero-length vector
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\begin{frame}[fragile,t]{Arithmetic and Logical Operations on \subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      Vectors can be multiplied and squared element by element, as if they were single elements.
      \vskip1ex
      When vectors are manipulated as if they were single elements, then \texttt{R} automatically performs a loop over the vector elements, and applies the operation element-wise.
      \vskip1ex
      This is a very powerful feature of \texttt{R} called \emph{vectorized arithmetic}.
      \vskip1ex
      \emph{Vectorized arithmetic} avoids writing loops and simplifies notation.
      \vskip1ex
      Vectors can be combined together and appended.
    \column{0.5\textwidth}
      \vspace{-1em}
      <<echo=TRUE>>=
2*4:8  # Multiply a vector
2*(4:8)  # Multiply a vector
4:8/2  # Divide a vector
(0:10)/10  # Divide vector - decimals from 0 to 1.0
vecv <- c(8, 6, 5, 7)  # Create vector
vecv
# Boolean vector TRUE if element is equal to second one
vecv == vecv[2]
# Boolean vector TRUE for elements greater than six
vecv > 6
2*vecv  # Multiply all elements by 2
vecv^2  # Square all elements
c(11, 5:10)  # Combine two vectors
c(vecv, 2.0)  # Append number to vector
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\begin{frame}[fragile,t]{Naming and Manipulating \subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      Vector elements can be assigned \texttt{names} using a list of symbol-value pairs.
      \vskip1ex
      The function \texttt{names()} returns the \texttt{names} attribute of an object.
      \vskip1ex
      The \texttt{names} attribute of a vector can be modified by assigning to the \texttt{names()} function ("\texttt{names() <-}" assignment).
      \vskip1ex
      The function \texttt{unname()} removes the \texttt{names} attribute.
      \vskip1ex
      The function \texttt{structure()} adds attributes (specified as \texttt{symbol=value} pairs) to an object, and returns it.
    \column{0.5\textwidth}
      \vspace{-1em}
      <<echo=TRUE,eval=TRUE>>=
vecv <- # Create named vector
  c(pi_const=pi, euler=exp(1), gamma=-digamma(1))
vecv
names(vecv)  # Get names of elements
vecv["euler"]  # Get element named "euler"
names(vecv) <- c("pie","eulery","gammy")  # Rename elements
vecv
unname(vecv)  # Remove names attribute
letters[5:10]  # Vector of letters
c("a", letters[5:10])  # Combine two vectors of letters
# Create named vector
structure(sample(1:5), names=paste0("el", 1:5))
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\begin{frame}[fragile,t]{Subsetting \subsecname}
\vspace{-1em}

\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      Vector elements can be \emph{subset} (indexed, referenced) using the \texttt{"[]"} operator.
      \vskip1ex
      Vectors can be \emph{subset} using vectors of:
      \begin{itemize}
        \item positive integers,
        \item negative integers,
        \item characters (names),
        \item Boolean vectors,
      \end{itemize}
      \vskip1ex
      Negative integers remove the vector elements.
      \vskip1ex
      Subsetting with \emph{zero} returns a zero-length vector.
      \vskip1ex
      A named vector can be \emph{subset} using element names.
    \column{0.5\textwidth}
      \vspace{-1em}
      <<echo=TRUE,eval=TRUE>>=
vecv  # Named vector
# Extract second element
vecv[2]
# Extract all elements, except the second element
vecv[-2]
# Extract zero elements - returns zero-length vector
vecv[0]
# Extract second and third elements
vecv[c(FALSE, TRUE, TRUE)]
# Extract elements using their names
vecv["eulery"]
# Extract elements using their names
vecv[c("pie", "gammy")]
# Subset whole vector
vecv[] <- 0
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\begin{frame}[fragile,t]{Filtering \subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      \emph{Filtering} means extracting elements from a vector that satisfy a logical condition.
      \vskip1ex
      When logical comparison operators are applied to vectors, they produce \texttt{Boolean} vectors.
      \vskip1ex
      \texttt{Boolean} vectors can then be applied to subset the original vectors, to extract their elements.
      \vskip1ex
      The function \texttt{which()} returns the indices of the \texttt{TRUE} elements of a \texttt{Boolean} \texttt{vector} or \texttt{array}.
    \column{0.5\textwidth}
      \vspace{-1em}
      <<echo=TRUE,eval=TRUE>>=
vecv <- runif(5)
vecv
vecv > 0.5  # Boolean vector
# Boolean vector of elements equal to the second one
vecv == vecv[2]
# Extract all elements equal to the second one
vecv[vecv == vecv[2]]
vecv < 1  # Boolean vector of elements less than one
# Extract all elements greater than one
vecv[vecv > 1]
vecv[vecv > 0.5]  # Filter elements > 0.5
which(vecv > 0.5)  # Index of elements > 0.5
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Factors}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      Factors are similar to vectors, but their elements can only take values from a set of \emph{levels}.
      \vskip1ex
      Factors are designed for categorical data which can only take certain values.
      \vskip1ex
      The function \texttt{factor()} converts a vector into a factor.
      \vskip1ex
      Factors have two attributes: \emph{class} (equal to \texttt{"factor"}) and \texttt{levels} (the allowed values).
      \vskip1ex
      Although factors aren't vectors, the data underlying a factor is an integer vector, called an \emph{encoding vector}.
      \vskip1ex
      The function \texttt{as.numeric()} extracts the encoding vector (indices) of a factor.
      \vskip1ex
      The function \texttt{as.vector()} coerces a factor to a character vector.
    \column{0.5\textwidth}
      \vspace{-1em}
      <<echo=TRUE,eval=TRUE>>=
# Create factor vector
factv <- factor(c("b", "c", "d", "a", "c", "b"))
factv
factv[3]
# Get factor attributes
attributes(factv)
# Get allowed values
levels(factv)
# Get encoding vector
as.numeric(factv)
is.vector(factv)
# Coerce vector to factor
as.factor(1:5)
# Coerce factor to character vector
as.vector(as.factor(1:5))
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Tables of Categorical Data}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      The function \texttt{unique()} calculates the unique elements of an object.
      \vskip1ex
      The function \texttt{levels()} extracts the \texttt{levels} attribute of a factor (the allowed values).
      \vskip1ex
      A contingency table is a matrix that contains the frequency distribution of variables (factors) contained in a set of data.
      \vskip1ex
      The function \texttt{table()} calculates the frequency distribution of categorical data.
      \vskip1ex
      \texttt{sapply()} applies a function to a vector or a list of objects and returns a vector or a list.
    \column{0.5\textwidth}
      \vspace{-1em}
      <<echo=TRUE,eval=TRUE>>=
# Print factor vector
factv
# Get unique elements of factv
unique(factv)
# Get levels attribute of factv
levels(factv)
# Calculate the factor elements from its levels
levels(factv)[as.numeric(factv)]
# Get contingency (frequency) table
table(factv)
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Classifying Continuous Numeric Data Into Categories}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      Numeric data that represents a \emph{magnitude}, \emph{intensity}, or \emph{score} can be classified into categorical data, given a vector of \emph{breakpoints}.
      \vskip1ex
      The \emph{breakpoints} create intervals that correspond to different \emph{categories}.
      \vskip1ex
      The \emph{categories} combine elements that have a similar numeric \emph{magnitude}.
      \vskip1ex
      \texttt{findInterval()} returns the indices of the intervals specified by \texttt{"vec"} that contain the elements of \texttt{"x"}.
      \vskip1ex
      If there's an exact match, then \texttt{findInterval()} returns the same index as function \texttt{match()}.
      \vskip1ex
      If there's no exact match, then \texttt{findInterval()} finds the element of \texttt{"vec"} that is closest to, but not greater than, the element of \texttt{"x"}.
      \vskip1ex
      If all the elements of \texttt{"vec"} are greater than the element of \texttt{"x"}, then \texttt{findInterval()} returns \texttt{zero}.
      \vskip1ex
      \texttt{args()} displays the formal arguments of a function.
    \column{0.5\textwidth}
      \vspace{-1em}
      <<echo=TRUE,eval=TRUE>>=
# Display the formal arguments of findInterval
args(findInterval)
# Get index of the element of "vec" that matches 5
findInterval(x=5, vec=c(3, 5, 7))
match(5, c(3, 5, 7))
# No exact match
findInterval(x=6, vec=c(3, 5, 7))
match(6, c(3, 5, 7))
# Indices of "vec" that match elements of "x"
findInterval(x=1:8, vec=c(3, 5, 7))
# Return only indices of inside intervals
findInterval(x=1:8, vec=c(3, 5, 7), all.inside=TRUE)
# make rightmost interval inclusive
findInterval(x=1:8, vec=c(3, 5, 7), rightmost.closed=TRUE)
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Classifying Numeric Data Into Categories Example}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      Temperature can be categorized into "cold", "warm", "hot", etc.
      \vskip1ex
      A named numeric vector of \emph{breakpoints} can be used to convert a temperature into one of the \emph{categories}.
      \vskip1ex
      \emph{Breakpoints} correspond to \emph{categories} of the data.
      \vskip1ex
      The first \emph{breakpoint} should correspond to the lowest \emph{category}, and should have a value less than any of the data.
    \column{0.5\textwidth}
      \vspace{-1em}
      <<echo=TRUE,eval=TRUE>>=
# Named numeric vector of breakpoints
breakv <- c(freezing=0, very_cold=30, cold=50, pleasant=60, warm=80, hot=90)
breakv
tempv <- runif(10, min=10, max=100)
feels_like <- names(breakv[findInterval(x=tempv, vec=breakv)])
names(tempv) <- feels_like
tempv
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Converting Numeric Data Into Factors Using \texttt{cut()}}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      The function \texttt{cut()} converts a numeric vector into a vector of factors, representing the intervals to which the numeric values belong.
      \vskip1ex
      \texttt{cut()} divides the range of values into intervals, based on a vector of breaks.
      \vskip1ex
      \texttt{cut()} then assigns factors to the numeric values, representing the intervals to which the numeric values belong.
      \vskip1ex
      The parameter \texttt{breaks} is a numeric vector of break points that divide the range of values into intervals.
      \vskip1ex
      The argument \texttt{"labels"} is a vector of labels for the intervals.
      \vskip1ex
      The argument \texttt{"right"} is a Boolean indicating if the intervals should be closed on the right (and open on the left), or vice versa.
      \vskip1ex
      \texttt{cut()} can produce the same classification as \texttt{findInterval()}, but \texttt{findInterval()} is faster than \texttt{cut()}, because it's a compiled function.
      \column{0.5\textwidth}
      \vspace{-1em}
      <<echo=(-(1:1)),eval=TRUE>>=
library(microbenchmark)
datav <- sample(0:6) + 0.1
datav
cut(x=datav, breaks=c(2, 4, 6, 8))
rbind(datav, cut(x=datav, breaks=c(2, 4, 6, 8)))
# cut() replicates findInterval()
cut(x=1:8, breaks=c(3, 5, 7), labels=1:2, right=FALSE)
findInterval(x=1:8, vec=c(3, 5, 7))
# findInterval() is a compiled function, so it's faster than cut()
vecv <- rnorm(1000)
summary(microbenchmark(
  find_interval=findInterval(x=vecv, vec=c(3, 5, 7)),
  cut=cut(x=vecv, breaks=c(3, 5, 7)),
  times=10))[, c(1, 4, 5)]  # end microbenchmark summary
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Plotting Histograms of Frequency Data}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      The function \texttt{hist()} calculates and plots a histogram, and returns its data \emph{invisibly}.
      \vskip1ex
      The parameter \texttt{breaks} is the number of cells of the histogram.
      \vskip1ex
      If the argument \texttt{freq} is \texttt{TRUE} then the frequencies (counts) are plotted, and if it's \texttt{FALSE} then the probability density is plotted (with total area equal to $1$).
      \vskip1ex
      The function \texttt{density()} calculates a kernel estimate of the probability density for a sample of data.
      \vskip1ex
      The function \texttt{lines()} draws a line through specified points.
      <<echo=TRUE,eval=FALSE>>=
# Calculate VTI percentage returns
retp <- na.omit(rutils::etfenv$returns$VTI)
# Plot histogram
x11(width=6, height=5)
par(mar=c(1, 1, 1, 1), oma=c(2, 2, 2, 0))
madv <- mad(retp)
histp <- hist(retp, breaks=100, 
  main="", xlim=c(-5*madv, 5*madv), 
  xlab="", ylab="", freq=FALSE)
      @
    \column{0.5\textwidth}
    \vspace{-1em}
    \includegraphics[width=0.45\paperwidth]{figure/hist_vti.png}
    \vspace{-1em}
      <<echo=TRUE,eval=FALSE>>=
# Draw kernel density of histogram
lines(density(retp), col="red", lwd=2)
# Add density of normal distribution
curve(expr=dnorm(x, mean=mean(retp), sd=sd(retp)), 
      add=TRUE, type="l", lwd=2, col="blue")
title(main="VTI Return Distribution", line=0)
# Add legend
legend("topright", inset=0.05, cex=0.8, title=NULL,
  leg=c("VTI", "Normal"), bty="n",
  lwd=6, bg="white", col=c("red", "blue"))
# Total area under histogram
sum(diff(histp$breaks) * histp$density)
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Matrices}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}

\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      The function \texttt{matrix()} creates a matrix from a vector, and the matrix dimensions.
      \vskip1ex
      By default \texttt{matrix()} creates matrices column-wise, unless the argument \texttt{byrow=TRUE} is used.
      \vskip1ex
      The elements of matrices can be subset (referenced) using the \texttt{"[]"} operator.
      \vskip1ex
      The functions \texttt{nrow()} and \texttt{ncol()} return the number of rows and columns of a matrix.
      \vskip1ex
      The functions \texttt{NROW()} and \texttt{NCOL()} also return the number of rows or columns of a matrix, but they can also be applied to vectors, and treat vectors as single column matrices.
    \column{0.5\textwidth}
      \vspace{-1em}
      <<echo=TRUE,eval=TRUE>>=
matv <- matrix(5:10, nrow=2, ncol=3)  # Create a matrix
matv  # By default matrices are constructed column-wise
# Create a matrix row-wise
matrix(5:10, nrow=2, byrow=TRUE)
matv[2, 3]  # Extract third element from second row
matv[2, ]  # Extract second row
matv[, 3]  # Extract third column
matv[, c(1,3)]  # Extract first and third column
matv[, -2]  # Remove second column
# Subset whole matrix
matv[] <- 0
# Get the number of rows or columns
nrow(vecv); ncol(vecv)
NROW(vecv); NCOL(vecv)
nrow(matv); ncol(matv)
NROW(matv); NCOL(matv)
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Matrix Attributes}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      Arrays are vectors with a dimension attribute.
      \vskip1ex
      Matrices are two-dimensional arrays.
      \vskip1ex
      The dimension attribute of a matrix is an integer vector of length 2 (nrow, ncol).
      \vskip1ex
      The \texttt{dimnames} attribute is a list, with vector elements containing row and column names.
      \vskip1ex
      A named matrix can be subset using row and column names.
    \column{0.5\textwidth}
      \vspace{-1em}
      <<echo=TRUE,eval=TRUE>>=
attributes(matv)  # Get matrix attributes
dim(matv)  # Get dimension attribute
class(matv)  # Get class attribute
rownames(matv) <- c("row1", "row2")  # Rownames attribute
colnames(matv) <- c("col1", "col2", "col3")  # Colnames attribute
matv
matv["row2", "col3"]  # Third element from second row
names(matv)  # Get the names attribute
dimnames(matv)  # Get dimnames attribute
attributes(matv)  # Get matrix attributes
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Matrix Subsetting}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      Matrices can be subset in a similar way as Vectors, either by indices (integers), by characters (names), or \texttt{Boolean} vectors.
      \vskip1ex
      Subsetting a matrix to a single row or column produces a vector, unless the parameter \texttt{"drop=FALSE"} is used.
      \vskip1ex
      Subsetting with the parameter \texttt{"drop=FALSE"} prevents the implicit coercion and preserves the matrix \emph{class}.
      \vskip1ex
      This is an example of implicit coercion in \texttt{R}, which can cause difficult to trace bugs.
    \column{0.5\textwidth}
      \vspace{-1em}
      <<echo=TRUE,eval=TRUE>>=
matv  # matrix with column names
matv[1, ]  # Subset rows by index
matv[, "col1"]  # Subset columns by name
matv[, c(TRUE, FALSE, TRUE)]  # Subset columns Boolean vector
matv[1, ]  # Subsetting can produce a vector!
class(matv); class(matv[1, ])
is.matrix(matv[1, ]); is.vector(matv[1, ])
matv[1, , drop=FALSE]  # Drop=FALSE preserves matrix
class(matv[1, , drop=FALSE])
is.matrix(matv[1, , drop=FALSE]); is.vector(matv[1, , drop=FALSE])
      @
  \end{columns}
\end{block}

\end{frame}



%%%%%%%%%%%%%%%
\section{Operators}


%%%%%%%%%%%%%%%
\subsection{Logical Operators}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      \texttt{R} has the following logical operators:
      \begin{itemize}
        \item \texttt{"<"} less than,
        \item \texttt{"<="} less than or equal to,
        \item \texttt{">"} greater than,
        \item \texttt{">="} greater than or equal to,
        \item \texttt{"=="} exactly equal to,
        \item \texttt{"!="} not equal to,
        \item \texttt{"!x"} Not \texttt{x},
        \item \texttt{"x \& y"} \texttt{x} AND \texttt{y},
        \item \texttt{"x | y"} \texttt{x} OR \texttt{y},
      \end{itemize}
      These operators are applied to vectors element-wise.
    \column{0.5\textwidth}
      \vspace{-1em}
        <<echo=(-(1:1))>>=
rm(list=ls())
TRUE | FALSE
TRUE | NA
vec1 <- c(2, 4, 6)
vec1 < 5  # Element-wise comparison
(vec1 < 5) & (vec1 > 3)
vec1[(vec1 < 5) & (vec1 > 3)]
vec2 <- c(-10, 0, 10)
vec1 < vec2
c(FALSE, TRUE, FALSE) & c(TRUE, TRUE, FALSE)
c(FALSE, TRUE, FALSE) | c(TRUE, TRUE, FALSE)
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Long Form Logical Operators}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      \texttt{R} also has two long form logical operators:
      \begin{itemize}
        \item \texttt{"x \&\& y"} \texttt{x} AND \texttt{y},
        \item \texttt{"x || y"} \texttt{x} OR \texttt{y},
      \end{itemize}
      These operators differ from the short form operators in two ways:
      \begin{itemize}
        \item They only evaluate single Boolean values, not Boolean vectors,
        \item They short-circuit (stop evaluation as soon as the expression is determined),
      \end{itemize}
      {\color{red}{Rule of Thumb}}
      \begin{itemize}
        \item Use \texttt{"\&\&"} and \texttt{"||"} in if-clauses,
      \end{itemize}
    \column{0.5\textwidth}
      \vspace{-1em}
        <<echo=(-(1:1))>>=
rm(list=ls())
FALSE && TRUE
FALSE || TRUE
echo_true <- function() {cat("echo_true\t"); TRUE}
echo_false <- function() {cat("echo_false\t"); FALSE}
echo_true() | echo_false()
echo_true() || echo_false()  # echo_false() isn't evaluated at all!
vecv <- c(2, 4, 6)
# Works (does nothing) using '&&'
if (is.matrix(vecv) && (vecv[2, 3] > 0)) {
  vecv[2, 3] <- 1
}
# No short-circuit so fails (produces an error)
if (is.matrix(vecv) & (vecv[2, 3] > 0)) {
  vecv[2, 3] <- 1
}
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Arithmetic Operators}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      Arithmetic \emph{operators} perform arithmetic operations on \texttt{numeric} or \texttt{complex} vectors,
      \begin{itemize}
        \item "\texttt{+}" performs addition,
        \item "\texttt{-}" performs subtraction,
        \item "\texttt{*}" performs multiplication,
        \item "\texttt{/}" performs division,
        \item "\texttt{\textasciicircum{}}" and "\texttt{**}" perform exponentiation,
      \end{itemize}
    \column{0.5\textwidth}
      \vspace{-1em}
      <<echo=TRUE,eval=FALSE>>=
?Arithmetic
4.7 * 0.5  # Multiplication
4.7 / 0.5  # Division
# Exponentiation
2**3
2^3
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Comparing Objects With \texttt{identical()} and \texttt{all.equal()}}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      The function \texttt{identical()} tests if two objects are exactly the same, and always returns a single logical \texttt{TRUE} or \texttt{FALSE} (never \texttt{NA} or logical \texttt{vectors}).
      \vskip1ex
      For atomic arguments \texttt{identical()} often gives the same result as the \texttt{"=="} operator, but it's not synonymous with it in general.
      \vskip1ex
      The \texttt{"=="} operator applies the \emph{recycling rule} to vector arguments and returns logical \texttt{vectors}, but \texttt{identical()} doesn't and returns a single logical value.
      \vskip1ex
      The function \texttt{all.equal()} tests the equality of two objects to within the square root of the \emph{machine precision}.
      \vskip1ex
      The variable \texttt{.Machine} contains information about the numerical characteristics of the computer \texttt{R} is running on, such as the largest \texttt{double} and \texttt{integer} numbers, and the \emph{machine precision}.
    \column{0.5\textwidth}
      \vspace{-1em}
      <<echo=TRUE,eval=FALSE>>=
numv <- 2
numv==2
identical(numv, 2)

identical(numv, NULL)
# This doesn't work:
# numv==NULL
is.null(numv)

vecv <- c(2, 4, 6)
vecv==2
identical(vecv, 2)

# numv is equal to "1.0" within machine precision
numv <- 1.0 + 2*sqrt(.Machine$double.eps)
all.equal(numv, 1.0)

# Info machine precision of computer R is running on
# ?.Machine
# Machine precision
.Machine$double.eps
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Lookup and Matching Using \texttt{which()} and \texttt{match()}}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      The function \texttt{which()} returns the indices of the \texttt{TRUE} elements of a \texttt{Boolean} \texttt{vector} or \texttt{array}.
      \vskip1ex
      If the argument is an \texttt{array} and \texttt{arr.ind=TRUE}, then \texttt{which()} returns a matrix with rows containing the indices of the \texttt{TRUE} elements.
      \vskip1ex
      The functions \texttt{which.max()} and \texttt{which.min()} return the index of the minimum or maximum of a \texttt{numeric} or \texttt{Boolean} vector.
      \vskip1ex
      \texttt{match()} returns the index of the vector element that \emph{exactly} matches its first argument.
      \vskip1ex
      If it doesn't find an exact match then it returns \texttt{NA}.
      \vskip1ex
      The expressions \texttt{match(x, vecv)} and \texttt{min(which(vecv == x))} produce the same result, but \texttt{match()} can be faster for large vectors.
    \column{0.5\textwidth}
      \vspace{-1em}
      <<echo=TRUE,eval=FALSE>>=
vecv <- sample(1e3, 1e3)
matv <- matrix(vecv, ncol=4)
which(vecv == 5)
match(5, vecv)
# Equivalent but slower than above
(1:NROW(vecv))[vecv == 5]
which(vecv < 5)
# Find indices of TRUE elements of Boolean matrix
which((matv == 5)|(matv == 6), arr.ind=TRUE)
# Equivalent but slower than above
arrayInd(which((matv == 5)|(matv == 6)),
         dim(matv), dimnames(matv))
# Find index of largest element
which.max(vecv)
which(vecv == max(vecv))
# Find index of smallest element
which.min(vecv)
# Benchmark match() versus which()
all.equal(match(5, vecv), min(which(vecv == 5)))
library(microbenchmark)
summary(microbenchmark(
  match=match(5, vecv),
  which=min(which(vecv == 5)),
  times=10))[, c(1, 4, 5)]  # end microbenchmark summary
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Lookup and Matching Using \texttt{\%in\%} and \texttt{any()}}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      The binary operator \texttt{\%in\%} returns a \texttt{Boolean} \texttt{vector} with \texttt{TRUE} values corresponding to elements that have matches.
      \vskip1ex
      \texttt{\%in\%} is a wrapper for \texttt{match()} defined as follows: 
      \texttt{"\%in\%" <- function(x, table) match(x, table, nomatch=0) > 0}.
      \vskip1ex
      \texttt{\%in\%} never returns \texttt{NA}, so it's preferred in \texttt{if()} statements.
      \vskip1ex
      \texttt{any()} returns \texttt{TRUE} if at least one element of a \texttt{Boolean} vector is \texttt{TRUE}, and \texttt{FALSE} otherwise.
      \vskip1ex
      The function \texttt{pmatch()} performs partial matching of strings.
    \column{0.5\textwidth}
      \vspace{-1em}
      <<echo=TRUE,eval=FALSE>>=
# Does 5 belong in vecv?
5 %in% vecv
match(5, vecv, nomatch=0) > 0
# Does (-5) belong in vecv?
(-5) %in% vecv
c(5, -5) %in% vecv
match(-5, vecv)
# Equivalent to "5 %in% vecv"
any(vecv == 5)
# Equivalent to "(-5) %in% vecv"
any(vecv == (-5))
# Any negative values in vecv?
any(vecv < 0)
# Example of use in if() statement
if (any(vecv < 2))
  cat("vector contains small values\n")
# Partial matching of strings
pmatch("med", c("mean", "median", "mode"))
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Finding Closest Match Using \texttt{findInterval()}}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      The function \texttt{match()} returns the index of the vector element that \emph{exactly} matches its first argument.
      \vskip1ex
      If \texttt{match()} doesn't find an exact match then it returns \texttt{NA}.
      \vskip1ex
      The function \texttt{findInterval()} returns the indices of the intervals specified by \texttt{"vec"} that contain the elements of \texttt{"x"}.
      \vskip1ex
      If there's an exact match, then \texttt{findInterval()} returns the same index as function \texttt{match()}.
      \vskip1ex
      If there's no exact match, then \texttt{findInterval()} finds the element of \texttt{"vec"} that is closest to, but not greater than, the element of \texttt{"x"}.
    \column{0.5\textwidth}
      \vspace{-1em}
      <<echo=TRUE,eval=FALSE>>=
# Display the formal arguments of findInterval
args(findInterval)
# Get index of the element of "vec" that matches 5
findInterval(x=5, vec=c(3, 5, 7))
match(5, c(3, 5, 7))
# No exact match
findInterval(x=6, vec=c(3, 5, 7))
match(6, c(3, 5, 7))
# Indices of "vec" that match elements of "x"
findInterval(x=1:8, vec=c(3, 5, 7))
# Return only indices of inside intervals
findInterval(x=1:8, vec=c(3, 5, 7), all.inside=TRUE)
# Make rightmost interval inclusive
findInterval(x=1:8, vec=c(3, 5, 7), rightmost.closed=TRUE)
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Assignment Operators}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      The standard assignment operator in \texttt{R} is \texttt{"<-"}.
      \vskip1ex
      Both \texttt{"<-"} and \texttt{"="} are valid assignment operators in \texttt{R}.
      \vskip1ex
      The \texttt{"<-"} operator may cause an error if \texttt{R} confuses it with the \texttt{"<"} logical operator.
      \vskip1ex
      But they differ in \emph{scope} and  \emph{precedence} (\texttt{"<-"} has higher precedence than \texttt{"="}).
      \vskip1ex
      The \texttt{"="} operator is used for named arguments in function calls.
      \vskip1ex
      When variables are assigned within an argument list using the \texttt{"="} operator, their \emph{scope} is limited to the function.
      \vskip1ex
      {\color{red}{Rule of Thumb}}:\\
      Use \texttt{"<-"} in \texttt{R} scripts and inside functions,\\
      Use \texttt{"="} only in function calls.
    \column{0.5\textwidth}
      \vspace{-1em}
            <<echo=TRUE,eval=FALSE>>=
numv1 <- 3  # "<-" and "=" are valid assignment operators
numv1
numv1 = 3
numv1
2<-3  # "<" operator confused with "<-"
2 < -3  # Add space or brackets to avoid confusion
# "=" assignment within argument list
median(x=1:10)
x  # x doesn't exist outside the function
# "<-" assignment within argument list
median(x <- 1:10)
x  # x exists outside the function
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{The \texttt{assign()} Function}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      The \texttt{assign()} function assigns a value to an object in a specified \emph{environment}, by referencing it using a character string (name).
      \vskip1ex
      \texttt{assign()} can be used to either assign values to existing variables, or to create new variables.
      \vskip1ex
      \texttt{assign()} looks for the object name in the specified \emph{environment}, and assigns a value to it.
      \vskip1ex
      If \texttt{assign()} can't find the object name, then it creates it.
      \vskip1ex
      \texttt{assign()} expects a character string as its argument.
      \vskip1ex
      If a object name is passsed to \texttt{assign()}, then it evaluates that object to get the string it contains.
      \vskip1ex
      If the object doesn't contain a string, then \texttt{assign()} produces an error.
    \column{0.5\textwidth}
      \vspace{-1em}
            <<echo=TRUE,eval=FALSE>>=
myvar <- 1  # Create new object
assign(x="myvar", value=2)  # Assign value to existing object
myvar
rm(myvar)  # Remove myvar
assign(x="myvar", value=3)  # Create new object from name
myvar
# Create new object in new environment
envv <- new.env()  # Create new environment
assign("myvar", 3, envir=envv)  # Assign value to name
ls(envv)  # List objects in "envv"
envv$myvar
rm(list=ls())  # Delete all objects in workspace
symboln <- "myvar"  # Define symbol containing string "myvar"
assign(symboln, 1)  # Assign value to "myvar"
ls()
myvar
assign("symboln", "new_var")
assign(symboln, 1)  # Assign value to "new_var"
ls()
symboln <- 10
assign(symboln, 1)  # Can't assign to non-string
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Applying \texttt{assign()} to Lists of Names}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      \texttt{assign()} allows creating new objects from listv or vectors of names (character strings), such as column names.
      \vskip1ex
    \column{0.5\textwidth}
      \vspace{-1em}
            <<echo=TRUE,eval=FALSE>>=
rm(list=ls())  # Delete all objects in workspace
# Create individual vectors from column names of EuStockMarkets
for (colname in colnames(EuStockMarkets)) {
# Assign column values to column names
  assign(colname, EuStockMarkets[, colname])
}  # end for
ls()
head(DAX)
head(EuStockMarkets[, "DAX"])
identical(DAX, EuStockMarkets[, "DAX"])
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Retrieving Objects Using \texttt{get()}}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      The function \texttt{get()} accepts a character string and returns the value of the corresponding object in a specified \emph{environment}.
      \vskip1ex
      \texttt{get()} retrieves objects that are referenced using character strings, instead of their names.
      \vskip1ex
      The functions \texttt{get()} and \texttt{assign()} allow retrieving and assigning values to objects that are referenced using character strings.
      \vskip1ex
      The function \texttt{mget()} accepts a vector of strings and returns a list of the corresponding objects.
    \column{0.5\textwidth}
      \vspace{-1em}
            <<echo=TRUE,eval=FALSE>>=
# Create new environment
envv <- new.env()
# Pass string as name to create new object
assign("myvar1", 2, envir=envv)
# Create new object using $ string referencing
envv$myvar2 <- 1
# List objects in new environment
ls(envv)
# Reference an object by name
envv$myvar1
# Reference an object by string name using get
get("myvar1", envir=envv)
# Retrieve and assign value to object
assign("myvar1",
       2*get("myvar1", envir=envv),
       envir=envv)
get("myvar1", envir=envv)
# Return all objects in an environment
mget(ls(envv), envir=envv)
# Delete environment
rm(envv)
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Metaprogramming in \texttt{R}}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      A powerful feature of \texttt{R} is \emph{non-standard evaluation} (aka \emph{metaprogramming} or \emph{programming on the language}).
      \vskip1ex
      Unevaluated \emph{expressions} are objects that represent \texttt{R} formulas and commands.
      \vskip1ex
      \emph{Metaprogramming} allows creating and manipulating unevaluated \texttt{R} \emph{expressions} and then executing them as needed.
      \vskip1ex
      The book \href{http://adv-r.had.co.nz/}{\emph{Advanced \texttt{R}}} by Hadley Wickham provides a good explanation of 
      \href{http://adv-r.had.co.nz/Computing-on-the-language.html}{\emph{metaprogramming} in \texttt{R}} and 
      \href{http://adv-r.had.co.nz/Expressions.html}{\texttt{R} \emph{expressions}}.
      \vskip1ex
      \texttt{R} interprets character strings that are not in quotes "" as \emph{symbols} or \emph{expressions}.
      \vskip1ex
      The function \texttt{as.symbol()} converts a character string into a \emph{symbol} object.
      \vskip1ex
      The function \texttt{parse()} converts a character string into an unevaluated \emph{expression} object.
      \vskip1ex
      The function \texttt{eval()} evaluates a \emph{symbol} or \emph{expression} in a specified \emph{environment}.
    \column{0.5\textwidth}
      \vspace{-1em}
            <<echo=TRUE,eval=FALSE>>=
rm(list=ls())  # Delete all objects in workspace
# Convert string to symbol
as.symbol("some_string")
# The "name" class is synonymous with a symbol
class(as.symbol("some_string"))
# Symbols are created during assignments
symboln <- 2
# Evaluate symbol (same as typing it)
eval(symboln)
# Convert string into a symbol and evaluate it
eval(as.symbol("symboln"))
# Convert string into unevaluated expression
expv <- parse(text="newv <- symboln")
expv
class(expv)
ls()
eval(expv)  # Evaluate expression
ls()  # Expression evaluation created new object
newv
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Manipulating Symbols and Expressions}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      The function \texttt{quote()} accepts \emph{symbols} and \emph{expressions}, and returns an \emph{expression} object without evaluating it.
      \vskip1ex
      The function \texttt{quote()} creates unevaluated \emph{expression} objects which later can be evaluated by functions.
      \vskip1ex
      The function \texttt{substitute()} replaces objects in unevaluated expressions with their corresponding values, and returns an \emph{expression}.
      \vskip1ex
      \texttt{substitute()} looks up the object names in either named \texttt{listv} (symbol-value pairs) or in \texttt{environments}, and evaluates the objects in them.
      \vskip1ex
      \texttt{substitute()} is often used inside functions to substitute formal arguments with the names of the actual arguments they are bound to in a function call.
    \column{0.5\textwidth}
      \vspace{-1em}
            <<echo=TRUE,eval=FALSE>>=
# Create the expression "1+1"
quote(1+1)
# Evaluate the expression "1+1"
eval(quote(1+1))
# Create an expression containing several commands
expv <- quote({x <- 1; y <- 2; x+y})
expv
# Evaluate all the commands in the expression
eval(expv)
ls()
# Return an expression without evaluating it
newv <- 2*symboln
expv <- quote(symboln + newv)
expv
eval(expv)  # Evaluate expression
# Substitute objects in an expression
expv <- substitute(symboln + newv,
                   env=list(symbol=1, newv=2))
expv
eval(expv)  # Evaluate expression
# Get_input() substitutes its formal argument with the actual argument
get_input <- function(inputv) {
  substitute(inputv)
}  # end get_input
myvar <- 2
get_input(myvar)
eval(get_input(myvar))
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Converting Symbols and Expressions Into Strings}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      The function \texttt{deparse()} is the opposite of \texttt{parse()}, and it converts \emph{symbols} and \emph{expressions} into character strings.
      \vskip1ex
      The combination of functions \texttt{deparse(substitute())} returns a character string representing the actual argument passed into a function.
    \column{0.5\textwidth}
      \vspace{-1em}
            <<echo=TRUE,eval=FALSE>>=
# Define symbol
myvar <- 10
# Convert symbol value into string
deparse(myvar)
# Convert symbol into string without evaluating it
deparse(quote(myvar))
# Substitute object with value from named list
symboln <- 2
deparse(substitute(symboln + myvar, env=list(myvar=2)))
# Create string with name of input argument
get_name <- function(inputv) {
  names(inputv) <- deparse(substitute(inputv))
  inputv
}  # end get_name
get_name(myvar)
      @
  \end{columns}
\end{block}

\end{frame}



%%%%%%%%%%%%%%%
\section{Control Structures}


%%%%%%%%%%%%%%%
\subsection{The Parenthesis \texttt{"()"} and Curly Braces \texttt{"\{\}"} Operators}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      The parenthesis \texttt{"()"} and curly braces \texttt{"\{\}"} operators are used to enclose and to group (combine) expressions.
      \vskip1ex
      The parenthesis \texttt{"()"} and curly braces \texttt{"\{\}"} operators are functions, and they return values.
      \vskip1ex
      An expression enclosed by the parenthesis \texttt{"()"} operator is evaluated separatately from other expressions, and its result is returned.
      \vskip1ex
      Enclosing expressions in parenthesis makes them less ambiguous.
      \vskip1ex
      The curly braces \texttt{"\{\}"} operator can group several expressions, that can be written either on separate lines, or be separated by the semicolon \texttt{";"} operator.
      \vskip1ex
      The curly braces \texttt{"\{\}"} operator returns the last expression it encloses.
      \vskip1ex
      Both the parenthesis \texttt{"()"} and curly braces \texttt{"\{\}"} operators are functions, and executing them requires a little additional processing time.
      \vskip1ex
      The square braces (brackets) \texttt{"[]"} operator subsets (references) the elements of vectors, matrices, and listv.
    \column{0.5\textwidth}
      \vspace{-1em}
        <<echo=(-(1:1))>>=
rm(list=ls())
# Expressions enclosed in parenthesis are less ambiguous
-2:5
(-2):5
-(2:5)
# Expressions enclosed in parenthesis are less ambiguous
-2*3+5
-2*(3+5)

# Expressions can be separated by semicolons or by lines
{1+2; 2*3; 1:5}
# or
{1+2
2*3
1:5}

matv <- matrix(nr=3, nc=4)
matv <- 0
# Subset whole matrix
matv[] <- 0

# Parenthesis and braces require a little additional processing time
library(microbenchmark)
summary(microbenchmark(
  basep=sqrt(rnorm(10000)^2),
  parven=sqrt(((((rnorm(10000)^2))))),
  bra_ce=sqrt({{{{rnorm(10000)^2}}}}),
  times=10))[, c(1, 4, 5)]  # end microbenchmark summary
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{The \texttt{"if () else"} Control Statement}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      \texttt{R} has the familiar \texttt{"if () \{...\} else \{...\}"} statement to control execution flow depending on logical conditions.
      \vskip1ex
      The logical conditions must be either a \texttt{Boolean} or \texttt{numeric} type, otherwise an error is produced.
      \vskip1ex
      The \texttt{"else"} statement can also be omitted.
      \vskip1ex
      \texttt{"if"} statements can be nested using multiple \texttt{"else if"} statements.
    \column{0.5\textwidth}
      \vspace{-1em}
        <<echo=(-(1:1))>>=
rm(list=ls())
numv1 <- 1

if (numv1) {  # Numeric zero is FALSE, all other numbers are TRUE
  numv2 <- 4
} else if (numv1 == 0) {  # 'else if' together on same line
  numv2 <- 0
} else {  # 'else' together with curly braces
  numv2 <- -4
}  # end if

numv2
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{The \texttt{switch()} Control Statement}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      The function \texttt{switch()} matches its first argument \texttt{"EXPR"} with one of the symbols in the following arguments, evaluates the corresponding expression, and returns it.
      \vskip1ex
      The arguments that follow the first argument \texttt{"EXPR"} should be given as \emph{symbol=value} pairs.
      \vskip1ex
      If \texttt{"EXPR"} is a character string, then the expression bound to that symbol is returned by \texttt{switch()}.
      \vskip1ex
      If \texttt{"EXPR"} is an integer, then \texttt{switch()} returns the expression from that position.
      \vskip1ex
      If \texttt{switch()} can't match \texttt{"EXPR"} to any symbol, then it returns \texttt{NULL} invisibly.
      \vskip1ex
      Using \texttt{switch()} is a convenient alternative to a cascade of \texttt{"if () else"} statements.
      \vskip1ex
      The function \texttt{match.arg()} matches a string to one of the possible values, and returns the matched value, or produces an \texttt{error} if it can't match it.
    \column{0.5\textwidth}
      \vspace{-1em}
        <<echo=TRUE>>=
switch("a", a="aaahh", b="bee", c="see", d=2,
       "else this")
switch("c", a="aaahh", b="bee", c="see", d=2,
       "else this")
switch(3, a="aaahh", b="bee", c="see", d=2,
       "else this")
switch("cc", a="aaahh", b="bee", c="see", d=2,
       "else this")
# Measure of central tendency
calc_center <- function(inputv, method=c("mean", "mean_narm", "median")) {
# validate "method" argument
  method <- match.arg(method)
  switch(method,
         mean=mean(inputv),
         mean_narm=mean(inputv, na.rm=TRUE),
         median=median(inputv))
}  # end calc_center
myvar <- rnorm(100, mean=2)
calc_center(myvar, "mean")
calc_center(myvar, "mean_narm")
calc_center(myvar, "median")
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Iteration Using \texttt{for()} and \texttt{while()} Loops}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      The \texttt{for()} loop statement:
      \vspace{-1em}
      <<echo=TRUE,eval=FALSE>>=
for (indeks in vecv) {expvs}
@
      \vspace{-1em}
      iterates the \emph{dummy} variable \texttt{indeks} over the elements of the vector or list \texttt{colorl}, and evaluates in a loop the \texttt{ex\_pressions} contained in the body of the \texttt{for()} loop.
      \vskip1ex
      Upon loop exit the \emph{dummy} variable \texttt{indeks} is left equal to the last element of the vector \texttt{colorl}.
      \vskip1ex
      \texttt{while()} loops start by testing their logical condition, and they repeat executing the loop body until that condition is \texttt{FALSE}.
      \vskip1ex
      But \texttt{while()} loops risk producing infinite loops if not written
properly, so \alert{Use Them With Care!}
    \column{0.5\textwidth}
      \vspace{-1em}
        <<echo=(-(1:1))>>=
rm(list=ls())
colorl <- list("red", "white", "blue")
# Loop over list
for (some_color in colorl) {
  print(some_color)
}  # end for
# Loop over vector
for (indeks in 1:3) {
  print(colorl[[indeks]])
}  # end for

# While loops require initialization
indeks <- 1
# While loop
while (indeks < 4) {
  print(colorl[[indeks]])
  indeks <- indeks + 1
}  # end while
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Performing Loops Using \texttt{for()} and \texttt{apply()}}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      The \texttt{for()} loop doesn't return a value, so values calculated in the \texttt{for()} loop body must be assigned to variables in the parent environment, or otherwise they are lost.
      \vskip1ex
      The expressions in the \texttt{for()} loop body have access to variables in the parent environment in which the \texttt{for()} loop is executed, and they can modify those variables.
      \vskip1ex
      So even though \texttt{for()} loops don't return a value, they can be used to perform calculations on variables in the parent environment, but this is discouraged since it can produce errors that are hard to debug.
      \vskip1ex
      {\color{red}{Rule of Thumb:}}\\
      \begin{itemize}
        \item \texttt{for()} loops are preferred for producing \emph{side effects}, like plotting or reading and writing data to files,
        \item \texttt{apply()} loops are preferred for performing calculations which produce vectors or matrices of values.
      \end{itemize}
    \column{0.5\textwidth}
      \vspace{-1em}
      <<echo=TRUE,eval=FALSE>>=
vecv <- integer(7)
# Loop over a vector and overwrite it
for (i in seq_along(vecv)) {
  cat("Changing element:", i, "\n")
  vecv[i] <- i^2
}  # end for
# Modifying vecv inside sapply() has no effect
vecv <- integer(7)
vecv
sapply(seq_along(vecv), function(i) {
  vecv[i] <- i^2
})  # end sapply
vecv
# Super-assignment operator "<<-" allows modifying vecv
sapply(seq_along(vecv), function(i) {
  vecv[i] <<- i^2 # "<<-" !!!
})  # end sapply
vecv
# sapply() loop returns vector of values
vecv <- sapply(seq_along(vecv), function(i) (i^2))
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Fibonacci Sequence Using \texttt{for()} Loop}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      The \emph{Fibonacci} sequence of integers is defined by the recurrence relation:
      \begin{displaymath}
        F_n = F_{n-1} + F_{n-2},
      \end{displaymath}
      \begin{displaymath}
        F_1 = 0, F_2 = 1,
      \end{displaymath}
      \begin{displaymath}
        F_n = 0, 1, 1, 2, 3, 5, 8, 13, \ldots
      \end{displaymath}
      The \emph{Fibonacci} sequence was invented by the \emph{Indian} mathematician Virahanka in the 8th century AD, and later described by the Italian mathematician \emph{Fibonacci} in his famous treatise \emph{Liber Abaci}.
      \vskip1ex
      Very often variables are initialized to \texttt{NULL} before the start of iteration.
      \vskip1ex
      A more efficicent way to perform iteration is by pre-allocating the vector.
      \vskip1ex
      The function \texttt{numeric()} returns an zero length \texttt{numeric} vector.
      \vskip1ex
      The function \texttt{numeric(k)} returns a \texttt{numeric} vector of zeros of length \texttt{k}.
    \column{0.5\textwidth}
      \vspace{-1em}
        <<echo=(-(1:1))>>=
rm(list=ls())
# fibv <- numeric()  # zero length numeric vector
# Pre-allocate vector instead of "growing" it
fibv <- numeric(10)
fibv[1] <- 0  # Initialize
fibv[2] <- 1  # Initialize
for (i in 3:10) {  # Perform recurrence loop
  fibv[i] <- fibv[i-1] + fibv[i-2]
}  # end for
fibv
      @
  \end{columns}
\end{block}

\end{frame}



%%%%%%%%%%%%%%%
\section{Manipulating Vectors and Matrices}


%%%%%%%%%%%%%%%
\subsection{Allocating Memory to Vectors and Matrices}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      \texttt{R} automatically allocates memory to new objects as needed during runtime, but at the cost of slowing down calculations.
      \vskip1ex
      Allocating memory of the correct \emph{mode} speeds up calculations by avoiding automatic memory allocation by \texttt{R}.
      \vskip1ex
      The functions \texttt{character()}, \texttt{integer()}, and \texttt{numeric()} return zero-length vectors of the specified \emph{mode}.
      \vskip1ex
      Zero length vectors are not the same as \texttt{NULL} objects.
      \vskip1ex
      The function \texttt{character(k)} returns a \texttt{character} vector of empty strings of length \texttt{k}.
      \vskip1ex
      The function \texttt{integer(k)} returns a \texttt{integer} vector of zeros of length \texttt{k}.
      \vskip1ex
      The function \texttt{numeric(k)} returns a \texttt{numeric} vector of zeros of length \texttt{k}.
      \vskip1ex
      The function \texttt{vector()} by default returns a \texttt{Boolean} vector, unless the \emph{mode} is specified.
      \vskip1ex
      The function \texttt{matrix()} by default returns a \texttt{Boolean} matrix containing \texttt{NA} values, unless the \emph{mode} is specified.
    \column{0.5\textwidth}
      \vspace{-1em}
        <<echo=TRUE>>=
# Allocate character vector
character()
character(5)
is.character(character(5))
# Allocate integer vector
integer()
integer(5)
is.integer(integer(5))
is.numeric(integer(5))
# Allocate numeric vector
numeric()
numeric(5)
is.integer(numeric(5))
is.numeric(numeric(5))
# Allocate Boolean vector
vector()
vector(length=5)
# Allocate numeric vector
vector(length=5, mode="numeric")
is.null(vector())
# Allocate Boolean matrix
matrix()
is.null(matrix())
# Allocate integer matrix
matrix(NA_integer_, nrow=3, ncol=2)
is.integer(matrix(NA_integer_, nrow=3, ncol=2))
# Allocate numeric matrix
matrix(NA_real_, nrow=3, ncol=2)
is.numeric(matrix(NA_real_, nrow=3, ncol=2))
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Logical Operators Applied to Vectors and Matrices}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      When logical operators are applied to vectors and matrices, they are applied element-wise, producing \texttt{Boolean} vectors and matrices.
    \column{0.5\textwidth}
      \vspace{-1em}
        <<echo=TRUE>>=
vecv <- sample(1:9)
vecv
vecv < 5  # Element-wise comparison
vecv == 5  # Element-wise comparison
matv <- matrix(vecv, ncol=3)
matv
matv < 5  # Element-wise comparison
matv == 5  # Element-wise comparison
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Coercing Vectors Into Matrices}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      Vectors can be coerced into matrices by adding a dimension attribute.
      \vskip1ex
      The \texttt{dimnames} attribute can be assigned a named list to convert it into a named matrix.
      \vskip1ex
      The function \texttt{structure()} adds attributes (specified as \texttt{symbol=value} pairs) to an object, and returns it.
    \column{0.5\textwidth}
      \vspace{-1em}
            <<echo=TRUE,eval=FALSE>>=
matv <- 1:6  # Create a vector
class(matv)  # Get its class
# Is it vector or matrix?
c(is.vector(matv), is.matrix(matv))
structure(matv, dim=c(2, 3))  # Matrix object
# Adding dimension attribute coerces into matrix
dim(matv) <- c(2, 3)
class(matv)  # Get its class
# Is it vector or matrix?
c(is.vector(matv), is.matrix(matv))
# Assign dimnames attribute
dimnames(matv) <- list(rows=c("row1", "row2"),
                        columns=c("col1", "col2", "col3"))
matv
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Coercing Matrices Into Other Types}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      Matrices can be explicitly coerced using the \texttt{"as.*"} coercion functions.
      \vskip1ex
      But coercion functions strip the \emph{attributes} from an object.
    \column{0.5\textwidth}
      \vspace{-1em}
            <<echo=TRUE,eval=FALSE>>=
matv <- matrix(1:10, 2, 5)  # Create matrix
matv
# as.numeric strips dim attribute from matrix
as.numeric(matv)
# Explicitly coerce to "character"
matv <- as.character(matv)
c(typeof(matv), mode(matv), class(matv))
# Coercion converted matrix to vector
c(is.matrix(matv), is.vector(matv))
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Binding Vectors and Matrices Together}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      Vectors can be bound into matrices using the functions \texttt{cbind()} and \texttt{rbind()}.
      \vskip1ex
      The \emph{recycling rule} allows operations on vectors of different lengths:\\
      \begin{enumerate}
        \item Vectors are scanned from left to right,
        \item Shorter vectors are extended in length by recycling their values until they match the length of longer vectors,
      \end{enumerate}
    \column{0.5\textwidth}
      \vspace{-1em}
            <<echo=TRUE,eval=FALSE>>=
vec1 <- 1:3  # Define vector
vec2 <- 6:4  # Define vector
# Bind vectors into columns
cbind(vec1, vec2)
# Bind vectors into rows
rbind(vec1, vec2)
# Extend to four elements
vec2 <- c(vec2, 7)
# Recycling rule applied
cbind(vec1, vec2)
# Another example of recycling rule
1:6 + c(10, 20)
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Replicating Objects Using \texttt{rep()}}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      The function \texttt{rep()} replicates vectors and listv a given number of times.
      \vskip1ex
      \texttt{rep()} accepts a vector or list \texttt{"x"}, and an integer specifying the type and number of replications.
      \vskip1ex
      Argument \texttt{"times"} replicates the whole vector a given number of times.
      \vskip1ex
      Argument \texttt{"each"} replicates each vector element a given number of times.
      \vskip1ex
      Argument \texttt{"length.out"} replicates the whole vector a certain number of times, so that the output vector length is equal to \texttt{"length.out"}.
    \column{0.5\textwidth}
      \vspace{-1em}
            <<echo=TRUE,eval=FALSE>>=
# Replicate a single element
rep("a", 5)
# Replicate the whole vector several times
rep(c("a", "b"), 5)
rep(c("a", "b"), times=5)
# Replicate the first element, then the second, etc.
rep(c("a", "b"), each=5)
# Replicate to specified length
rep(c("a", "b"), length.out=5)
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Multiplying Vectors and Matrices}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      The multiplication \texttt{"*"} \emph{operator} performs \emph{element-wise} (\emph{element-by-element}) multiplication of vectors and matrices.
      \vskip1ex
      By default the matrix elements are multiplied column-wise by the vector elements: the first matrix element in the first column is multiplied by the first vector element, then the second matrix column is multiplied by the remaining vector elements, etc.
      \vskip1ex
      The \emph{recycling rule} is applied to the vector elements as needed.
      \vskip1ex
      The transpose function \texttt{t()} can be applied if we want to perform row-wise multiplication.
      \vskip1ex
      But the transpose function \texttt{t()} is very slow for large matrices.
      \vskip1ex
      A better choice is to use functions \texttt{lapply()} and \texttt{do.call()}.
     \column{0.5\textwidth}
      \vspace{-1em}
      <<echo=TRUE>>=
# Define vector and matrix
vec1 <- c(2, 4, 3)
matv <- matrix(sample(1:12), ncol=3)
# Multiply columns of matrix by vector
vec1*matv
# Or
matv*vec1
# Multiply rows of matrix by vector
t(vec1*t(matv))
# Multiply rows of matrix by vector - transpose is very slow
matrixp <- lapply(1:NCOL(matv), 
  function(x) vec1[x]*matv[, x])
do.call(cbind, matrixp)
library(microbenchmark)
summary(microbenchmark(
  trans=t(vec1*t(matv)),
  lapp={
    matrixp <- lapply(1:NCOL(matv), function(x) vec1[x]*matv[, x])
    do.call(cbind, matrixp)
  },
  times=10))[, c(1, 4, 5)]  # end microbenchmark summary
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Matrix Inner Multiplication}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      The \texttt{\%*\%} operator performs \emph{inner} (\emph{scalar}) multiplication of vectors and matrices.
      \vskip1ex
      \emph{Inner} multiplication multiplies the rows of one matrix with the columns of another matrix, so that each pair produces a single number:
      \begin{displaymath}
        C_{i,j} = \sum_{k=1}^n A_{i,k} B_{k,j}
      \end{displaymath}
      \emph{Inner} multiplication produces a vector or matrix with a reduced dimension.
      \vskip1ex
      \emph{Inner} multiplication requires the dimensions of the matrices to be \emph{conformable} (number of columns in the first matrix must be equal to the number of rows in the second).
      \vskip1ex
      The function \texttt{drop()} removes any extra dimensions of length \emph{one}.
      \vskip1ex
      The functions \texttt{rowSums()} and \texttt{colSums()} calculate the sums of rows and columns, and they're very fast because they pass their data to compiled \texttt{C++} code.
    \column{0.5\textwidth}
      \vspace{-1em}
      <<echo=(-(1:1))>>=
vec1
vec2 <- 6:4  # Define vector
# Multiply two vectors element-by-element
vec1 * vec2
# Calculate inner product
vec1 %*% vec2
# Calculate inner product and drop dimensions
drop(vec1 %*% vec2)
# Multiply columns of matrix by vector
matv %*% vec1  # Single column matrix
drop(matv %*% vec1)  # vector
rowSums(t(vec1 * t(matv)))
# using rowSums() and t() is 10 times slower than %*%
library(microbenchmark)
summary(microbenchmark(
  inner=drop(matv %*% vec1),
  transp=rowSums(t(vec1 * t(matv))),
  times=10))[, c(1, 4, 5)]  # end microbenchmark summary
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Matrix Transpose}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      The function \texttt{t()} returns the transpose of a matrix.
      \vskip1ex
      The function \texttt{crossprod()} also performs \emph{inner} (\emph{scalar}) multiplication, exactly the same as the \texttt{\%*\%} operator, but is slightly faster.
    \column{0.5\textwidth}
      \vspace{-1em}
      <<echo=(-(1:1)),eval=FALSE>>=
library(microbenchmark)
# Multiply matrix by vector fails because dimensions aren't conformable
vec1 %*% matv
# Works after transpose
drop(vec1 %*% t(matv))
# Calculate inner product
crossprod(vec1, vec2)
# Create matrix and vector
matv <- matrix(1:3000, ncol=3)
tmatv <- t(matv)
vecv <- 1:3
# crossprod() is slightly faster than "%*%" operator
summary(microbenchmark(
  cross_prod=crossprod(tmatv, vecv),
  inner_prod=matv %*% vecv,
  times=10))[, c(1, 4, 5)]  # end microbenchmark summary
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Matrix Outer Multiplication}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      An \emph{outer} product consists of all possible products of pairs of elements of two objects:
      \begin{displaymath}
        C_{i,j} = A_i \cdot B_j
      \end{displaymath}
      An \emph{outer} product of a function consists of applying it to all possible pairs of elements of two objects:
      \begin{displaymath}
        C_{i,j} = f(A_i, B_j)
      \end{displaymath}
      \emph{Outer} multiplication produces an object with dimension equal to the sum of the factors' dimensions, and with the number of elements equal to the product of the factors' elements.
      \vskip1ex
      The function \texttt{outer()} calculates the \emph{outer} product of two matrices, and by default multiplies the elements of its arguments.
      \vskip1ex
      \texttt{outer()} can also calculate the values of a vectorized function of two variables passed to the \texttt{"FUN"} argument.
    \column{0.5\textwidth}
      \vspace{-1em}
      <<echo=TRUE>>=
# Define named vectors
vec1 <- sample(1:4)
names(vec1) <- paste0("row", 1:4, "=", vec1)
vec1
vec2 <- sample(1:3)
names(vec2) <- paste0("col", 1:3, "=", vec2)
vec2
# Calculate outer product of two vectors
matv <- outer(vec1, vec2)
matv
# Calculate vectorized function spanned over two vectors
matv <- outer(vec1, vec2,
                 FUN=function(x1, x2) x2*sin(x1))
matv
      @
  \end{columns}
\end{block}

\end{frame}




%%%%%%%%%%%%%%%
\section{Functions}


%%%%%%%%%%%%%%%
\subsection{\secname \hskip0.4em in \texttt{R}}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      \texttt{R} functions have three components:
      \begin{itemize}
        \item a list of formal arguments,
        \item a body containing \texttt{R} code,
        \item an environment,
      \end{itemize}
      An \texttt{R} function plus its environment is referred to as a function \emph{closures}.
      \vskip1ex
      The function body should be enclosed in curly braces \texttt{\{\}}, unless it contains a single command, then it doesn't have to enclosed.
      \vskip1ex
      The function body doesn't require a \texttt{return} statement, since by default \texttt{R} functions return the last statement evaluated in the body.
      \vskip1ex
      \texttt{args()} displays the formal arguments of a function.
    \column{0.5\textwidth}
      \vspace{-1em}
        <<echo=TRUE,eval=FALSE>>=
# Define a function with two arguments
testfun <- function(arg1, arg2) {  # Body
  arg1 + arg2  # Returns last evaluated statement
}  # end testfun

testfun(1, 2)  # Apply the function
args(testfun)  # Display argument

# Define function that uses variable from enclosure environment
testfun <- function(arg1, arg2) {
  arg1 + arg2 + globv
}  # end testfun

testfun(3, 2)  # error - globv doesn't exist yet!
globv <- 10  # Create globv
testfun(3, 2)  # Now works
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Return Values of \secname}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      The function body doesn't require a \texttt{return} statement, since by default \texttt{R} functions return the last statement evaluated in the body.
      \vskip1ex
      \texttt{return()} statements are inserted in logical branches to terminate function execution and return its intended value.
    \column{0.5\textwidth}
      \vspace{-1em}
        <<echo=TRUE,eval=FALSE>>=
# Define function that returns NULL for non-numeric argument
testfun <- function(inputv) {
  if (!is.numeric(inputv)) {
    warning(paste("argument", inputv, "isn't numeric"))
    return(NULL)
  }
  2*inputv
}  # end testfun

testfun(2)
testfun("hello")
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{\secname \hskip0.4em That Return \texttt{invisible}}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      If a return value is wrapped in the function \texttt{invisible()} then the return value isn't printed.
      \vskip1ex
      But if the function is assigned to a variable, then its return value is assigned to that variable.
      \vskip1ex
      \texttt{invisible()} allows creating functions whose return values can be assigned, but which do not print when they're not assigned.
      \vskip1ex
      The function \texttt{load()} reads data from \texttt{.RData} files, and \emph{invisibly} returns a vector of names of objects created in the workspace.
    \column{0.5\textwidth}
      \vspace{-1em}
        <<echo=TRUE,eval=FALSE>>=
# Define a function that returns invisibly
retinv <- function(inputv) {
  invisible(inputv)
}  # end retinv

retinv(2)

globv <- retinv(2)
globv

rm(list=ls())  # Delete all objects in workspace
# Load objects from file
loaded <- load(file="/Users/jerzy/Develop/data/my_data.RData")
loaded  # Vector of loaded objects
ls()  # List objects
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Binding Function Arguments}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      The formal arguments of a function are defined in its argument list.
      \vskip1ex
      When a function is called, it's passed a list of actual function arguments.
      \vskip1ex
      Formal arguments can be \emph{bound} to actual arguments either by name or by position:
      \begin{itemize}
        \item by name: formal arguments are \emph{bound} to actual arguments with the same name,
        \item by position: the first formal argument is \emph{bound} to the first actual argument, etc.
      \end{itemize}
      \emph{Binding} by name takes precedence over \emph{binding} by position: first all the named arguments are \emph{bound}, then the remaining arguments are \emph{bound} by position.
      \vskip1ex
      Partial argument names are \emph{bound} to full names.
    \column{0.5\textwidth}
      \vspace{-1em}
        <<echo=TRUE,eval=FALSE>>=
testfun <- function(arg1, arg2) {
# Last statement of function is return value
  arg1 + 2*arg2
}  # end testfun
testfun(arg1=3, arg2=2)  # Bind by name
testfun(first=3, second=2)  # Partial name binding
testfun(3, 2)  # Bind by position
testfun(arg2=2, 3)  # mixed binding
testfun(3, 2, 1)  # Too many arguments
testfun(2)  # Not enough arguments
      @
      \vspace{-1em}
      All the actual arguments must be \emph{bound} to formal arguments, and if not then an \texttt{"unused argument"} error is produced.
      \vskip1ex
      If there aren't enough formal arguments, then an \texttt{"argument is missing"} error is produced,
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Default Values for Arguments}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      Formal arguments may be assigned default values, so that when the actual arguments are missing then their default values are used instead.
      \vskip1ex
      Default values are often assigned to function parameters, that determine the function's behavior.
      \vskip1ex
      Default values can be specified as a vector of strings, representing the possible values of a function's parameter.
      \vskip1ex
      The function \texttt{match.arg()} matches a string to one of the possible values, and returns the matched value, or produces an \texttt{error} if it can't match it.
      \vskip1ex
      The function \texttt{str()} displays the structure of an \texttt{R} object, for example a function name and its formal arguments.
    \column{0.5\textwidth}
      \vspace{-1em}
        <<echo=TRUE,eval=FALSE>>=
# Function "paste" has two arguments with default values
str(paste)
# Default values of arguments can be specified in argument list
testfun <- function(arg1, ratio=1) {
  ratio*arg1
}  # end testfun
testfun(3)  # Default value used for second argument
testfun(3, 2)  # Default value over-ridden
# Default values can be a vector of strings
testfun <- function(inputv=c("first_val", "second_val")) {
  inputv <- match.arg(inputv)  # Match to arg list
  inputv
}  # end testfun
testfun("second_val")
testfun("se")  # Partial name binding
testfun("some_val")  # Invalid string
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Function for Calculating Skew}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      \texttt{R} provides an easy way for users to write functions.
      \vskip1ex
      Formal function arguments can be bound to input variables by position or by name.
      \vskip1ex
      If the function arguments are missing then their default value is used.
      \vskip1ex
      Functions return the value of the last expression that is evaluated.
      \vskip1ex
      \texttt{datasets} is a \texttt{base} package containing various datasets, for example: \texttt{EuStockMarkets}.
      \vskip1ex
      The \texttt{EuStockMarkets} dataset contains daily closing prices of european stock indices.
    \column{0.5\textwidth}
      \vspace{-1em}
        <<echo=TRUE,eval=FALSE>>=
# VTI percentage returns
retp <- rutils::diffit(log(Cl(rutils::etfenv$VTI)))
# calc_skew() calculates skew of time series of returns
# Default is normal time series
calc_skew <- function(retp=rnorm(1000)) {
  # Number of observations
  nrows <- NROW(retp)
  # Standardize returns
  retp <- (retp - mean(retp))/sd(retp)
  # Calculate skew - last statement automatically returned
  nrows*sum(retp^3)/((nrows-1)*(nrows-2))
}  # end calc_skew

# Calculate the skew of VTI returns
# Pass the arguments by name
calc_skew(retp=retp)
# Pass the arguments by position
calc_skew(retp)
# Use default value of arguments
calc_skew()
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{The dots \texttt{"..."} Function Argument}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      The dots \texttt{"..."} function argument is a formal argument without a name, as opposed to the other formal arguments which all have names.
      \vskip1ex
      The dots \texttt{"..."} bind with any number of additional arguments, that aren't already bound by name or position to the named arguments.
      \vskip1ex
      The dots \texttt{"..."} are used when the number of arguments isn't known in advance, and allows functions to accept an indefinite number of arguments.
      \vskip1ex
      The dots \texttt{"..."} are sometimes placed \emph{after} the named arguments, to allow passing of additional parameters into a function.
      \vskip1ex
      \emph{Functionals} often place the dots \texttt{"..."} argument \emph{after} the named arguments, to allow passing the dots \texttt{"..."} to the function being called by the \emph{functional}.
    \column{0.5\textwidth}
      \vspace{-1em}
        <<echo=TRUE>>=
str(plot)  # Dots for additional plot parameters
bind_dots <- function(inputv, ...) {
  paste0("inputv=", inputv, ", dots=", paste(..., sep=", "))
}  # end bind_dots
bind_dots(1, 2, 3)  # "inputv" bound by position
bind_dots(2, inputv=1, 3)  # "inputv" bound by name
bind_dots(1, 2, 3, argv=10)  # Named argument bound to dots
bind_dots <- function(arg1, arg2, ...) {
  arg1 + 2*arg2 + sum(...)
}  # end bind_dots
bind_dots(3, 2)  # Bind arguments by position
bind_dots(3, 2, 5, 8)  # Extra arguments bound to dots
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Argument Binding With dots \texttt{"..."} Argument}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      The dots \texttt{"..."} argument is sometimes placed \emph{before} the named arguments, so that a function can accept an indefinite number of arguments, without binding them by position with the named arguments.
      \vskip1ex
      When the dots \texttt{"..."} are placed \emph{before} the named arguments, the named arguments are often assigned default values, so they don't have to be bound to a value in the call.
      \vskip1ex
      Arguments that appear after the dots \texttt{"..."} must be \emph{bound} by their full name, and can't be partially \emph{bound}.
    \column{0.5\textwidth}
      \vspace{-1em}
        <<echo=TRUE>>=
str(sum)  # Dots before other arguments
sum(1, 2, 3)  # Dots bind before other arguments
sum(1, 2, NA, 3, na.rm=TRUE)
bind_dots <- function(..., inputv) {
  paste0("inputv=", inputv, ", dots=", paste(..., sep=", "))
}  # end bind_dots
# Arguments after dots must be bound by full name
bind_dots(1, 2, 3, inputv=10)
bind_dots(1, 2, 3, inputv=10, argv=4)  # Dots bound
bind_dots(1, 2, 3)  # "inputv" not bound
bind_dots <- function(..., inputv=10) {
  paste0("inputv=", inputv, ", dots=", paste(..., sep=", "))
}  # end bind_dots
bind_dots(1, 2, 3)  # "inputv" not bound, but has default
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Wrapper \secname \hskip0.4em With dots \texttt{"..."} Argument}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      \emph{Wrapper} functions provide a convenient user interface to functions, by assigning default argument values, validating data, and formatting the output.
      \vskip1ex
      \emph{Wrapper} functions are designed to perform the actions of other functions, while reducing their complexity.
      \vskip1ex
      The dots \texttt{"..."} argument of the \emph{wrapper} function allows passing additional arguments on to the wrapped function.
      \vskip1ex
      \emph{Wrapper} functions should be used with caution, since wrapping a function creates extra code (overhead), which slows down \texttt{R}.
    \column{0.5\textwidth}
      \vspace{-1em}
        <<echo=TRUE,eval=FALSE>>=
# Wrapper for mean() with default na.rm=TRUE
meanfun <- function(x, na.rm=TRUE, ...) {
  mean(x=x, na.rm=na.rm, ...)
}  # end meanfun
vecv <- sample(c(1:10, NA, rep(0.1, t=5)))
mean(vecv)
mean(vecv, na.rm=TRUE)
meanfun(vecv)
meanfun(vecv, trim=0.4)  # Pass extra argument
# Wrapper for saving data into default directory
save_data <- function(...,
                      file=stop("error: no file name"),
                      my_dir="/Users/jerzy/Develop/data") {
# Create file path
  file <- file.path(my_dir, file)
  save(..., file=file)
}  # end save_data
vecv <- 1:10
save_data(vecv, file="scratch.RData")
save_data(vecv, file="scratch.RData", my_dir="/Users/jerzy/Develop")
# Wrapper for testing negative arguments
stop_if_neg <- function(inputv) {
  if (!is.numeric(inputv) || inputv < 0)
    stop("argument not numeric or negative")
}  # end stop_if_neg
# Wrapper for sqrt()
my_sqrt <- function(inputv) {
  stop_if_neg(inputv)
  sqrt(inputv)
}  # end my_sqrt
my_sqrt(2)
my_sqrt(-2)
my_sqrt(NA)
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Recursive \secname \hskip0.4em with dots \texttt{"..."} Argument}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      \emph{Recursive} functions can also accept the dots \texttt{"..."} argument.
      \vskip1ex
      The dots \texttt{"..."} argument can be referenced inside a function by first converting it into a list using \texttt{"list(...)"}.
      \vskip1ex
      The function \texttt{missing()} returns \texttt{TRUE} if an argument is missing, and \texttt{FALSE} otherwise.
    \column{0.5\textwidth}
      \vspace{-1em}
        <<echo=TRUE,eval=FALSE>>=
# Recursive function sums its argument list
sum_dots <- function(inputv, ...) {
  if (missing(...)) {  # Check if dots are empty
    return(inputv)  # just one argument left
  } else {
    inputv + sum_dots(...)  # Sum remaining arguments
  }  # end if
}  # end sum_dots
sum_dots(1, 2, 3, 4)
# Recursive function sums its argument list
sum_dots <- function(inputv, ...) {
  if (NROW(list(...)) == 0) {  # Check if dots are empty
    return(inputv)  # just one argument left
  } else {
    inputv + sum_dots(...)  # Sum remaining arguments
  }  # end if
}  # end sum_dots
sum_dots(1, 2, 3, 4)
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Recursive Function for Calculating Fibonacci Sequence}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      \emph{Recursive} functions call themselves in their own body.
      \vskip1ex
      The \emph{Fibonacci} sequence of integers is defined by the recurrence relation:
      \begin{displaymath}
        F_n = F_{n-1} + F_{n-2},
      \end{displaymath}
      \begin{displaymath}
        F_1 = 0, F_2 = 1,
      \end{displaymath}
      \begin{displaymath}
        F_n = 0, 1, 1, 2, 3, 5, 8, 13, \ldots
      \end{displaymath}
      The \emph{Fibonacci} sequence was invented by \emph{Indian} mathematicians, and later described by the Italian mathematician \emph{Fibonacci} in his famous treatise \emph{Liber Abaci}.
    \column{0.5\textwidth}
      \vspace{-1em}
        <<echo=TRUE>>=
fibonacci <- function(nrows) {
  if (nrows > 2) {
    fibv <- fibonacci(nrows-1)  # Recursion
    c(fibv, sum(tail(fibv, 2)))  # Return this
  } else {
    c(0, 1)  # Initialize and return
  }
}  # end fibonacci
fibonacci(10)
tail(fibonacci(9), 2)
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Exploring Functions}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      If a function name is called alone without arguments, then \texttt{R} displays the function code (but it must be on the search path).
      \vskip1ex
      Non-visible objects can't be viewed by calling their name.
      \vskip1ex
      The function \texttt{getAnywhere()} displays information about \texttt{R} objects, including non-visible objects.
      \vskip1ex
      The function \texttt{getAnywhere()} also displays \texttt{R} objects that aren't on the search path.
    \column{0.5\textwidth}
      \vspace{-1em}
      <<echo=TRUE,eval=FALSE>>=
# Show the function code
plot.default
# Display function
getAnywhere(plot.default)
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Internal and Primitive Functions}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      \texttt{R} is a high-confl language written in lower-confl languages, mostly \texttt{C++} and some \texttt{Fortran}.
      \vskip1ex
      \texttt{R} functions are either written in \texttt{R} code (\emph{interpreted} functions), or they directly call compiled \texttt{C++} or \texttt{Fortran} code (\emph{compiled} functions, also called \emph{internal} or \emph{primitive}).
      \vskip1ex
      \texttt{R} parses the code of \emph{interpreted} functions, and eventually calls compiled \texttt{C++} or \texttt{Fortran} code.
      \vskip1ex
      But this extra processing makes \emph{interpreted} functions much slower than \emph{compiled} functions.
      \vskip1ex
      Users can distinguish between \emph{interpreted} functions and \emph{compiled} functions by typing their names, and analyzing their source code.
      \vskip1ex
      The source code of \emph{interpreted} functions contains multiple lines of \texttt{R} code, or a call to function \texttt{UseMethod()} (which \emph{dispatches} \emph{methods} associated with \emph{generic} functions).
      \vskip1ex
      The source code of \emph{compiled} functions contains a single call to one of the functions that execute \emph{compiled} \texttt{C++} or \texttt{Fortran} code: \texttt{.Internal()}, \texttt{.Primitive()}, \texttt{.C()}, \texttt{.Call()}, \texttt{.Fortran()}, or \texttt{.External()}.
    \column{0.5\textwidth}
      \vspace{-1em}
      <<echo=TRUE, eval=FALSE>>=
# Sum() is a compiled primitive function
sum
# mean() is a generic function
mean
# Show all methods of mean()
methods(generic.function=mean)
# Show code for mean.default()
mean.default
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Exploring Internal and Primitive Functions}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      Several functions call compiled code: \texttt{.C()}, \texttt{.Call()}, \texttt{.Fortran()}, \texttt{.External()}, or \texttt{.Internal()} and \texttt{.Primitive()}
      \vskip1ex
      \texttt{R} \texttt{.Internal()} \texttt{.Primitive()}
      \vskip1ex
      The function \texttt{getAnywhere()} displays \texttt{R} objects, including functions.
      \vskip1ex
      If a function name is called alone then \texttt{R} displays the function code (but it must be on the search path).
      \vskip1ex
      the user can access symbols from a package that isn't attached using the double-colon operator \texttt{tools::file\_ext}

      The function \texttt{getAnywhere()} also displays \texttt{R} objects that aren't on the search path.
    \column{0.5\textwidth}
      \vspace{-1em}
        <<echo=TRUE,eval=FALSE>>=
# Get all methods for generic function "plot"
methods("plot")

getAnywhere(plot)  # Display function
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Lazy Evaluation of Function Arguments}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      \texttt{R} functions delay evaluation of their arguments until they're needed by their \texttt{R} code.
      \vskip1ex
      This is called \emph{lazy} evaluation.
      \vskip1ex
      If the function body doesn't evaluate an argument, then the function won't produce an error, even if the argument is missing.
    \column{0.5\textwidth}
      \vspace{-1em}
        <<echo=(-1)>>=
rm(list=ls())
lazyfun <- function(arg1, arg2) {  # Define function lazyfun
  2*arg1  # just multiply first argument
}  # end lazyfun
lazyfun(3, 2)  # Bind arguments by position
lazyfun(3)  # Second argument was never evaluated!
lazyfun <- function(arg1, arg2) {  # Define function lazyfun
  cat(arg1, '\n')  # Write to output
  cat(arg2)  # Write to output
}  # end lazyfun
lazyfun(3, 2)  # Bind arguments by position
lazyfun(3)  # First argument written to output
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Function Environments}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      When a function is called, a new \emph{evaluation} environment is created.
      \vskip1ex
      The \emph{evaluation} environment contains the function arguments and locally defined variables.
      \vskip1ex
      \texttt{R} evaluates variables inside functions by searching first in the \emph{evaluation} environment, then the \emph{enclosure} environment, then the \texttt{R} search path.
      \vskip1ex
      The enclosure of the \emph{evaluation} environment is the environment where the function was defined.
      \vskip1ex
      The enclosure of functions defined in the workspace is the \emph{global} environment.
      \vskip1ex
      The enclosure of functions defined in packages is the package \emph{namespace}.
      \vskip1ex
      Objects defined in the function enclosure can be referenced inside the function.
    \column{0.5\textwidth}
      \vspace{-1em}
        <<echo=(-1)>>=
rm(list=ls())
globv <- 1  # Define a global variable
ls(environment())  # Get all variables in environment
func_env <- function() {  # Explore function environments
  locvar <- 1  # Define a local variable
  cat('objects in evaluation environment:\t',
      ls(environment()), '\n')
  cat('objects in enclosing environment:\t',
      ls(parent.env(environment())), '\n')
  cat('this is the enclosing environment:')
  parent.env(environment())  # Return enclosing environment
}  # end func_env
func_env()

environment(func_env)
environment(print)  # Package namespace is the enclosure
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Lexical Function Scope}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      A \emph{free} variable is a variable that's not included in the \emph{evaluation} environment.
      \vskip1ex
      Scoping rules determine how \emph{free} variables are evaluated.
      \vskip1ex
      By default \texttt{R} uses \emph{lexical} (\emph{static}) scoping, which means that variables are first evaluated in the \emph{evaluation} environment, then in the \emph{enclosing} environment in which the function was \emph{defined}, and so on.
      \vskip1ex
      \emph{Dynamic} scoping means that variables are evaluated in the environment from which the function was \emph{called}.
      \vskip1ex
      The standard assignment operator \texttt{"<-"} modifies variables in the \emph{evaluation} environment.
      \vskip1ex
      The super-assignment operator \texttt{"<<-"} modifies variables in the \emph{enclosing} environment.
    \column{0.5\textwidth}
      \vspace{-1em}
        <<echo=(-1)>>=
rm(list=ls())
globv <- 1  # Define a global variable
probe_scope <- function() {  # Explore function scope
  locvar <- 2*globv  # Define a local variable
  new_globvar <<- 11  # Define a global variable
  cat('objects in evaluation environment:\t',
      ls(environment()), '\n')
  cat('this is a local locvar:\t', locvar, '\n')
  cat('objects in enclosing environment:\n',
      ls(parent.env(environment())), '\n')
  cat('this is globv:\t', globv, '\n')
  globv <- 10  # Define local globv
  cat('this is the local globv:\t', globv, '\n')
}  # end probe_scope
probe_scope()
globv  # Global variable is unaffected
new_globvar  # new_globvar is preserved
locvar  # Local variable is gone!
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Argument Passing in \texttt{R}}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      In general, arguments can be passed into functions either by \emph{value} or by \emph{reference}.
      \vskip1ex
      When an argument is passed by \emph{value}, then a copy of that argument is passed to the function.
      \vskip1ex
      That way if the function modifies that argument, then the original object isn't modified.
      \vskip1ex
      When an argument is passed by \emph{reference}, then a \emph{pointer} to the original object is passed to the function.
      \vskip1ex
      If the function modifies that argument, then the original object is modified as well.
      \vskip1ex
      \texttt{R} uses a hybrid method of argument passing called \emph{copy-on-modify semantics}.
      \vskip1ex
      \texttt{R} passes arguments by reference, thus saving memory space and time for copying.
      \vskip1ex
      But if the argument is modified within the function, then \texttt{R} makes a copy of it, so that the original object is unchanged.
    \column{0.5\textwidth}
      \vspace{-1em}
        <<echo=TRUE,eval=FALSE>>=
a <- 1  # Define a variable
# New variable "b" points to value of "a"
b <- a  # Define a new variable
# When "b" is modified, R makes a copy of it
b <- b+1
# Function doubles its argument and returns it
double_it <- function(inputv) {
  inputv <- 2*inputv
  cat("input argument was doubled to:", inputv, "\n")
  inputv
}
double_it(a)
a  # variable "a" is unchanged
      @
      \emph{Copy-on-modify semantics} has important implications for performance and memory usage.
      \vskip1ex
      \url{http://stackoverflow.com/questions/15759117/what-exactly-is-copy-on-modify-semantics-in-r-and-where-is-the-canonical-source}
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Side effects Using the Super-assignment Operator \texttt{"<<-"}}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      Function \emph{side effects} are operations on objects outside a function's \emph{evaluation} environment.
      \vskip1ex
      The functions \texttt{plot()} and \texttt{load()} are examples of functions that produce \emph{side effects}.
      \vskip1ex
      \texttt{load()} reads data from an \texttt{.RData} file, and creates objects in the workspace that are contained in the \texttt{.RData} file.
      \vskip1ex
      The super-assignment operator \texttt{"<<-"} allows creating functions that produce \emph{side effects}.
      \vskip1ex
      The super-assignment operator \texttt{"<<-"} modifies or creates variables in the \emph{enclosing} environment in which a function was \emph{defined} (\emph{lexical} scoping).
      \vskip1ex
      If a function was \emph{defined} in the \emph{global} environment then that's the function's \emph{enclosing} environment, and the \texttt{"<<-"} operator operates on variables in the \emph{global} environment.
    \column{0.5\textwidth}
      \vspace{-1em}
        <<echo=(-(1:1))>>=
setwd("/Users/jerzy/Develop/lecture_slides/data")
rm(list=ls())  # Delete all objects in workspace
ls()  # List objects
# Load objects from file (side effect)
load(file="my_data.RData")
ls()  # List objects
globv <- 1  # Define a global variable
# Explore function scope and side effects
side_effect <- function() {
  cat("global globv =", globv, "\n")
# Define local "globv" variable
  globv <- 10
  cat("local globv =", globv, "\n")
  # Re-define the global "globv"
  globv <<- 2
  cat("local globv =", globv, "\n")
}  # end side_effect
side_effect()
# Global variable was modified as side effect
globv
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Operators as Functions}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      Most functions in \texttt{R} are \emph{prefix} operators (where the function name is followed by a list of arguments).
      \vskip1ex
      \emph{Infix} operators (where the the function name comes in between its arguments) can also be applied using \emph{prefix} syntax.
      \vskip1ex
      In \emph{prefix} syntax, the \emph{Infix} operator name must be surrounded by single \texttt{''} or double  \texttt{""} quotes.
      \vskip1ex
      The \texttt{"["} bracket operator can also be written as a \emph{prefix} function.
    \column{0.5\textwidth}
      \vspace{-1em}
        <<echo=TRUE,eval=FALSE>>=
# Standard infix operator call syntax
2 + 3
# Infix operator applied using prefix syntax
"+"(2, 3)
# Standard bracket operator
vecv <- c(4, 3, 5, 6)
vecv[2]
# Bracket operator applied using prefix syntax
"["(vecv, 2)

      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Defining New Infix Operators}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      New \emph{infix} operators can be defined using the usual function definition syntax.
      \vskip1ex
      All user defined \emph{infix} operators names must be nested between \texttt{"\%"} characters.
    \column{0.5\textwidth}
      \vspace{-1em}
        <<echo=TRUE,eval=FALSE>>=
# Define infix operator that returns string
'%+%' <- function(a, b) paste(a, b, sep=" + ")
2 %+% 3
2 %+% 3 %+% 4
"hello" %+% 2 %+% 3 %+% "bye"
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Replacement Functions}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      \texttt{R} syntax allows assigning to the values returned by functions, but they must be defined as \emph{replacement} functions.
      \vskip1ex
      \emph{replacement} function names include the assignment arrow: \texttt{"name<-"}.
      \vskip1ex
      The first argument passed to the \emph{replacement} function is modified by the second argument, and then it's returned.
    \column{0.5\textwidth}
      \vspace{-1em}
        <<echo=TRUE,eval=FALSE>>=
obj_string <- "hello"
class(obj_string)
# Assign to value returned by "class" function
class(obj_string) <- "string"
class(obj_string)
# Define function last()
last <- function(vecv) {
  vecv[NROW(vecv)]
}  # end last
last(1:10)
# Define replacement function last()
'last<-' <- function(vecv, value) {
  vecv[NROW(vecv)] <- value
  vecv
}  # end last
x <- 1:5
last(x) <- 11
x
      @
  \end{columns}
\end{block}

\end{frame}



%%%%%%%%%%%%%%%
\section{Functionals}


%%%%%%%%%%%%%%%
\subsection{Functionals}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      \emph{Functionals} are functions that accept a function or a function name (string) as one of their input arguments.
      \vskip1ex
      \emph{Functionals} are able to execute function calls using the function names.
      \vskip1ex
      The function \texttt{match.fun()} returns a function name that is specified by a string.
      \vskip1ex
      \emph{Functionals} that call \texttt{match.fun()} are able to accept a string as a function name, because \texttt{match.fun()} converts it to a function.
      \vskip1ex
      \texttt{match.fun()} produces an error condition if it fails to find a function with the specified name.
    \column{0.5\textwidth}
      \vspace{-1em}
        <<echo=TRUE,eval=FALSE>>=
# Functional accepts function name and additional argument
testfun <- function(funn, inputv) {
# Produce function name from argument
  funn <- match.fun(funn)
# Execute function call
  funn(inputv)
}  # end testfun
testfun(sqrt, 4)
# String also works because match.fun() converts it to a function
testfun("sqrt", 4)
str(sum)  # Sum() accepts multiple arguments
# Functional can't accept indefinite number of arguments
testfun(sum, 1, 2, 3)
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Functionals with dots \texttt{"..."} Argument}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      The dots \texttt{"..."} argument in \emph{functionals} can be used to pass additional arguments to the function being called by the \emph{functional}.
      \vskip1ex
      If named values are passed to the dots \texttt{"..."} argument, then the \emph{functional} can bind them to the correct formal arguments of the function being called by the \emph{functional}.
    \column{0.5\textwidth}
      \vspace{-1em}
        <<echo=TRUE,eval=FALSE>>=
# Functional accepts function name and dots '...' argument
testfun <- function(funn, ...) {
  funn <- match.fun(funn)
  funn(...)  # Execute function call
}  # end testfun
testfun(sum, 1, 2, 3)
testfun(sum, 1, 2, NA, 4, 5)
testfun(sum, 1, 2, NA, 4, 5, na.rm=TRUE)
# Function with three arguments and dots '...' arguments
testfun <- function(inputv, param1, param2, ...) {
  c(inputv=inputv, param1=param1, param2=param2, dots=c(...))
}  # end testfun
testfun(1, 2, 3, 4, 5)
testfun(1, 2, 3, param2=4, param1=5)
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Anonymous Functions}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      \texttt{R} allows defining functions without assigning a name to them.
      \vskip1ex
      \emph{Anonymous} functions are functions that are not assigned to a name.
      \vskip1ex
      \emph{Anonymous} functions can be passed as arguments to \emph{functionals}.
    \column{0.5\textwidth}
      \vspace{-1em}
        <<echo=TRUE,eval=FALSE>>=
# Simple anonymous function
(function(x) (x + 3)) (10)
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Functionals with Anonymous Functions}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      \emph{Anonymous} functions can be passed as arguments to \emph{functionals}.
      \vskip1ex
      \emph{Anonymous} functions can also be used as default values for function arguments.
    \column{0.5\textwidth}
      \vspace{-1em}
        <<echo=TRUE,eval=FALSE>>=
# Anonymous function passed to testfun
testfun(funn=(function(x) (x + 3)), 5)
# Anonymous function is default value
testfun <-
  function(..., funn=function(x, y, z) {x+y+z}) {
    funn <- match.fun(funn)
    funn(...)  # Execute function call
}  # end testfun
testfun(2, 3, 4)  # Use default funn
testfun(2, 3, 4, 5)
# funn bound by name
testfun(funn=sum, 2, 3, 4, 5)
# Pass anonymous function to funn
testfun(funn=function(x, y, z) {x*y*z},
            2, 3, 4)
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Executing Function Calls Using the \texttt{do.call()} Functional}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      The functional \texttt{do.call()} executes a function call using a function name and a list of arguments.
      \vskip1ex
      \texttt{do.call()} allows calling a function on arguments that are elements of a list.
      \vskip1ex
      \texttt{do.call()} passes the list elements individually, instead of passing the whole list as one argument:\\
      \texttt{do.call(fun, list)=
      fun(list[[1]], list[[2]], \ldots)}
      \vskip1ex
      \texttt{do.call()} can be called inside other \emph{functionals} to allow them to execute function calls.
      \vskip1ex
      The function \texttt{str()} displays the structure of an \texttt{R} object, for example a function name and its formal arguments.
      \vskip1ex
      The function \texttt{do\_call()} from package \emph{rutils} performs the same operation as \texttt{do.call()}, but using recursion, which is much faster and uses less memory.
    \column{0.5\textwidth}
      \vspace{-1em}
        <<echo=TRUE,eval=FALSE>>=
str(sum)  # Sum() accepts multiple arguments
# Sum() can't accept list of arguments
sum(list(1, 2, 3))
str(do.call)  # "what" argument is a function
# Do.call passes list elements into "sum" individually
do.call(sum, list(1, 2, 3))
do.call(sum, list(1, 2, NA, 3))
do.call(sum, list(1, 2, NA, 3, na.rm=TRUE))
# Functional accepts list with function name and arguments
testfun <- function(list_arg) {
# Produce function name from argument
  funn <- match.fun(list_arg[[1]])
# Execute function call uing do.call()
  do.call(funn, list_arg[-1])
}  # end testfun
arg_list <- list("sum", 1, 2, 3)
testfun(arg_list)
# do_call() performs same operation as do.call()
all.equal(
  do.call(sum, list(1, 2, NA, 3, na.rm=TRUE)),
  rutils::do_call(sum, list(1, 2, NA, 3), na.rm=TRUE))
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Performing Loops Using the \texttt{apply()} \secname}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      An important example of \emph{functionals} are the \texttt{apply()} functionals.
      \vskip1ex
      The functional \texttt{apply()} returns the result of applying a function to the rows or columns of an array or matrix.
      \vskip1ex
      If \texttt{MARGIN=1} then the function will be applied over the matrix \emph{rows,}
      \vskip1ex
      If \texttt{MARGIN=2} then the function will be applied over the matrix \emph{columns}.
      \vskip1ex
      \texttt{apply()} performs a loop over the list of objects, and can replace \texttt{"for"} loops in \texttt{R}.
    \column{0.5\textwidth}
      \vspace{-1em}
        <<echo=(-1)>>=
rm(list=ls())
str(apply)  # Get list of arguments
# Create a matrix
matv <- matrix(6:1, nrow=2, ncol=3)
matv
# Sum the rows and columns
rowsumv <- apply(matv, 1, sum)
colsumv <- apply(matv, 2, sum)
matv <- cbind(c(sum(rowsumv), rowsumv),
                  rbind(colsumv, matv))
dimnames(matv) <- list(c("colsumv", "row1", "row2"),
                         c("rowsumv", "col1", "col2", "col3"))
matv
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{The \texttt{apply()} Functional with dots \texttt{"..."} Argument}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      The dots \texttt{"..."} argument in \texttt{apply()} is designed to pass additional arguments to the function being called by \texttt{apply()}.
      \vskip1ex
      The additional arguments to \texttt{apply()} must be \emph{bound} by their full (complete) names.
      <<echo=TRUE,eval=FALSE>>=
str(apply)  # Get list of arguments
matv <- matrix(sample(12), nrow=3, ncol=4)  # Create a matrix
matv
apply(matv, 2, sort)  # Sort matrix columns
apply(matv, 2, sort, decreasing=TRUE)  # Sort decreasing order
      @
    \column{0.5\textwidth}
        <<echo=TRUE,eval=FALSE>>=
matv[2, 2] <- NA  # Introduce NA value
matv
# Calculate median of columns
apply(matv, 2, median)
# Calculate median of columns with na.rm=TRUE
apply(matv, 2, median, na.rm=TRUE)
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{The \texttt{apply()} Functional with Anonymous Functions}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      The \texttt{apply()} functional combined with \emph{anonymous} functions can be used to loop over function parameters.
      \vskip1ex
      The dots \texttt{"..."} argument in \texttt{apply()} is designed to pass additional arguments to the function being called by \texttt{apply()}.
      \vskip1ex
      The additional arguments to \texttt{apply()} must be \emph{bound} by their full (complete) names.
    \column{0.5\textwidth}
      \vspace{-1em}
      <<echo=TRUE,eval=FALSE>>=
# VTI percentage returns
retp <- rutils::diffit(log(Cl(rutils::etfenv$VTI)))
library(moments)  # Load package moments
str(moment)  # Get list of arguments
# Apply moment function
moment(x=retp, order=3)
# 4x1 matrix of moment orders
orderv <- as.matrix(1:4)
# Anonymous function allows looping over function parameters
apply(X=orderv, MARGIN=1, FUN=function(orderp) {
  moment(x=retp, order=orderp)
}  # end anonymous function
)  # end apply

# Another way of passing parameters into moment() function
apply(X=orderv, MARGIN=1, FUN=moment, x=retp)
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{\texttt{apply()} Calling Functions with Multiple Arguments}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      When \texttt{apply()} calls a function with multiple arguments, then care must be taken for proper argument binding.
      \vskip1ex
      The dots \texttt{"..."} argument in \texttt{apply()} allows passing additional arguments to the function being called by \texttt{apply()}.
      \vskip1ex
      The additional arguments to \texttt{apply()} must be \emph{bound} by their full (complete) names.
      \vskip1ex
      The values of the \texttt{"X"} argument in \texttt{apply()} are \emph{bound} by position to the first unused argument in the function being called by \texttt{apply()}.
    \column{0.5\textwidth}
      \vspace{-1em}
        <<echo=TRUE>>=
# Function with three arguments
testfun <- function(arg1, arg2, arg3) {
  c(arg1=arg1, arg2=arg2, arg3=arg3)
}  # end testfun
testfun(1, 2, 3)
datav <- as.matrix(1:4)
# Pass datav to arg1
apply(X=datav, MAR=1, FUN=testfun, arg2=2, arg3=3)
# Pass datav to arg2
apply(X=datav, MAR=1, FUN=testfun, arg1=1, arg3=3)
# Pass datav to arg3
apply(X=datav, MAR=1, FUN=testfun, arg1=1, arg2=2)
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{The \texttt{lapply()} Functional}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      The functional \texttt{lapply()} is a specialized version of the functional \texttt{apply()}.
      \vskip1ex
      \texttt{lapply()} applies a function to a list of objects and returns a list.
      \vskip1ex
      The function \texttt{unlist()} collapses a list with atomic elements into a vector (which can cause type coercion).
      \vskip1ex
      {\color{red}{Rule of Thumb}}\\
      It's often better to use \texttt{lapply()}, since \texttt{apply()} and \texttt{sapply()} attempt to coerce their output into a vector or matrix, which may cause them to fail.
    \column{0.5\textwidth}
      \vspace{-1em}
        <<echo=TRUE,eval=FALSE>>=
# Vector of means of numeric columns
sapply(iris[, -5], mean)
# List of means of numeric columns
lapply(iris[, -5], mean)
# Lapply using anonymous function
unlist(lapply(iris,
              function(column) {
                if (is.numeric(column)) mean(column)
              }  # end anonymous function
              )  # end lapply
       )  # end unlist
unlist(sapply(iris, function(column) {
  if (is.numeric(column)) mean(column)}))
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{The \texttt{sapply()} Functional}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      The \texttt{sapply()} functional is a specialized version of the \texttt{apply()} functional.
      \vskip1ex
      \texttt{sapply()} applies a function to a vector or a list of objects and returns a vector or a list.
      \vskip1ex
      \texttt{sapply()} tries to return a vector, but if the elements can't be combined into a vector, then it returns a list.
      \vskip1ex
      When \texttt{sapply()} is given a data frame, it interprets it as a list, and applies the function to each element (column) of the data frame.
    \column{0.5\textwidth}
      \vspace{-1em}
        <<echo=TRUE,eval=FALSE>>=
sapply(6:10, sqrt)  # Sapply on vector
sapply(list(6, 7, 8, 9, 10), sqrt)  # sapply on list

# Calculate means of iris data frame columns
sapply(iris, mean)  # Returns NA for Species

# Create a matrix
matv <- matrix(sample(100), ncol=4)
# Calculate column means using apply
apply(matv, 2, mean)

# Calculate column means using sapply, with anonymous function
sapply(1:NCOL(matv), function(colnum) {  # Anonymous function
         mean(matv[, colnum])
  }  # end anonymous function
)  # end sapply
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{\texttt{sapply()} Returning Matrices}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      If the function called by \texttt{sapply()} returns a vector, then \texttt{sapply()} returns a matrix, if possible.
      \vskip1ex
      The vectors returned by the function are arranged to form columns of the matrix returned by \texttt{sapply()}.
      \vskip1ex
      But if the function returns vectors of different lengths, then \texttt{sapply()} cannot return a matrix, and returns a list instead.
      \vskip1ex
      This behavior of \texttt{sapply()} can cause run-time errors.
      \vskip1ex
      The function \texttt{vapply()} is similar to \texttt{sapply()}, but it always attempts to simplify its output to a matrix, and if it can't then it produces an error.
      \vskip1ex
      \texttt{vapply()} requires the argument \texttt{FUN.VALUE} that specifes the output format of the function called by \texttt{vapply()}.
    \column{0.5\textwidth}
      \vspace{-1em}
        <<echo=TRUE,eval=FALSE>>=
# Vectors form columns of matrix returned by sapply
sapply(2:4, function(num) c(el1=num, el2=2*num))
# Vectors of different lengths returned as list
sapply(2:4, function(num) 1:num)
# vapply is similar to sapply
vapply(2:4, function(num) c(el1=num, el2=2*num),
       FUN.VALUE=c(row1=0, row2=0))
# vapply produces an error if it can't simplify
vapply(2:4, function(num) 1:num,
       FUN.VALUE=c(row1=0, row2=0))
      @
  \end{columns}
\end{block}

\end{frame}



%%%%%%%%%%%%%%%
\section{Homework Assignment}


%%%%%%%%%%%%%%%
\subsection{Homework Assignment}
\begin{frame}[t]{\secname}
\vspace{-1em}

\begin{block}{Required}
  \begin{itemize}[]
    \item Study all the lecture slides in \texttt{FRE6871\_Lecture\_1.pdf}, and run all the code in \texttt{FRE6871\_Lecture\_1.R},
    \item Study the 
    \href{https://style.tidyverse.org/}{\color{blue}{\emph{RStudio Style Guide}}}.
  \end{itemize}
\end{block}

\begin{block}{Recommended}
  \begin{itemize}[]
    \item Read about the \emph{Vasicek} single factor model in \texttt{Vasicek Portfolio Default Distribution.pdf}, \texttt{BOE Credit Risk Models.pdf}, \texttt{BIS Bank Capital Model.pdf}, and in \texttt{Elizalde CDO Vasicek Credit Model.pdf}.
  \end{itemize}
\end{block}

\end{frame}


\end{document}
