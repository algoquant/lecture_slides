% FRE6871_Lecture1
% Define knitr options
% !Rnw weave=knitr
% Set global chunk options
<<knitr_setup,include=FALSE,cache=FALSE>>=
library(knitr)
opts_chunk$set(prompt=TRUE, eval=FALSE, tidy=FALSE, strip.white=FALSE, comment=NA, highlight=FALSE, message=FALSE, warning=FALSE, size="tiny", fig.width=4, fig.height=4)
options(width=80, dev="pdf")
options(digits=3)
thm <- knit_theme$get("acid")
knit_theme$set(thm)
@


% Define document options
\documentclass[9pt]{beamer}
\DeclareMathSizes{8pt}{6pt}{6pt}{5pt}
\mode<presentation>
\usetheme{AnnArbor}
% \usecolortheme{whale}
% Uncover everything in a step-wise fashion
% \beamerdefaultoverlayspecification{<+->}
% mathtools package for math symbols
% \usepackage{mathtools}
\usepackage[latin1]{inputenc}
\usepackage{hyperref}
\usepackage{fancybox}
\usepackage{url}
\usepackage[backend=bibtex,style=alphabetic]{biblatex} % bibstyle=numeric
\usepackage{listings}
\usepackage{xcolor}
\definecolor{anti_flashwhite}{rgb}{0.95, 0.95, 0.96}
\definecolor{cmd_background}{rgb}{0.2, 0.2, 0.0}
\definecolor{vba_background}{rgb}{0.0, 0.0, 0.9}
% \bibliographystyle{amsalpha} % doesn't work
\addbibresource{FRE_lectures.bib}
% \addbibresource[location=remote]{http://www.citeulike.org/user/jerzyp}
\renewcommand\bibfont{\footnotesize}
\renewcommand{\pgfuseimage}[1]{\scalebox{0.75}{\includegraphics{#1}}} % scale bib icons
\setbeamertemplate{bibliography item}[text] % set bib icons
% \setbeamertemplate{bibliography item}{} % remove bib icons

% \usepackage{enumerate}
% \let\emph\textbf
% \let\alert\textbf
% Define colors for hyperlinks
\definecolor{links}{HTML}{2A1B81}
\hypersetup{colorlinks=true,linkcolor=,urlcolor=links}
% Make url text scriptsize
\renewcommand\UrlFont{\scriptsize}
% Make institute text italic and small
\setbeamerfont{institute}{size=\small,shape=\itshape}
\setbeamerfont{date}{size=\small}
\setbeamerfont{block title}{size=\normalsize} % shape=\itshape
\setbeamerfont{block body}{size=\footnotesize}


% Title page setup
\title[FRE6871 Lecture\#1]{FRE6871 \texttt{R} in Finance}
\subtitle{Lecture\#1, Fall 2022}

\institute[NYU Tandon]{NYU Tandon School of Engineering}
\titlegraphic{\includegraphics[scale=0.2]{image/tandon_long_color.png}}
\author[Jerzy Pawlowski]{Jerzy Pawlowski \emph{\href{mailto:jp3900@nyu.edu}{jp3900@nyu.edu}}}
% \email{jp3900@nyu.edu}
\date{September 5, 2022}
% \date{\today}
% \pgfdeclareimage[height=0.5cm]{university-logo}{engineering_long_white}
% \logo{\pgfuseimage{engineering_long_white}}


%%%%%%%%%%%%%%%
\begin{document}


%%%%%%%%%%%%%%%
\maketitle



%%%%%%%%%%%%%%%
\section{Introduction}


%%%%%%%%%%%%%%%
\subsection{Welcome Students!}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      My name is Jerzy Pawlowski \href{mailto:jp3900@nyu.edu}{jp3900@nyu.edu}
      \vskip1ex
      I'm an adjunct professor at NYU Tandon because I love teaching and I want to share my professional knowledge with young, enthusiastic students.
      \vskip1ex
      I'm interested in applications of \emph{machine learning} to \emph{systematic investing}.
      \vskip1ex
      I'm an advocate of \emph{open-source software}, and I share it on GitHub:\\
      \href{https://github.com/algoquant/}{\color{blue}{My GitHub account}} 
      \vskip1ex
      In my finance career, I have worked as a hedge fund \emph{portfolio manager}, \emph{CLO structurer} (banker), and \emph{quant analyst}.\\
      \href{https://www.linkedin.com/in/jerzypawlowski/}{\color{blue}{My LinkedIn profile}} 
    \column{0.5\textwidth}
    \includegraphics[width=0.5\paperwidth]{image/Jerzy_Pawlowski_linked.png}
    \includegraphics[width=0.5\paperwidth]{image/github_algoquant.png}
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{FRE6871 Course Description and Objectives}
\begin{frame}[t]{\subsecname}
\vspace{-1em}

\begin{block}{Course Description}
The course will study the applications of the \texttt{R} statistical language to financial data analysis and modeling.
The applications will include \emph{classification} for credit scoring, \emph{Monte Carlo simulation} for option pricing and credit portfolio modeling, and \emph{Principal Component Analysis} (\emph{PCA}) for interest rate yield curve modeling.
The course will apply statistical techniques, such as \emph{hypothesis testing}. \emph{linear regression}, \emph{logistic regression}, and \emph{bootstrap simulation}.
\end{block}
\pause

\begin{block}{Course Objectives}
Students will learn through \texttt{R} coding exercises how to:\\
\hskip1em - Manipulate data structures (vectors, data frames, dates, and time series).\\
\hskip1em - Download data from external sources, and to scrub and format it.\\
\hskip1em - Create interactive plots and visualizations.\\
\hskip1em - Build financial models.\\
\hskip1em - Perform exception and error handling, and debugging.\\
\end{block}
\pause

\begin{block}{Course Prerequisites}
The \texttt{R} language is considered to be challenging, so this course requires some programming experience with other languages such as \texttt{C++} or \texttt{Python}.  Students should also have knowledge of basic statistics (random variables, estimators, hypothesis testing, regression, etc.)
The course \emph{FRE7241 Algorithmic Portfolio Management} is designed as a followup course to \emph{FRE6871}.
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Homeworks and Tests}
\begin{frame}[t]{\subsecname}
\vspace{-1em}

\begin{block}{Homeworks and Tests}
Grading will be based on homeworks and tests.  There will be no final exam.
      \vskip1ex
The tests will require writing code, which should run directly when pasted into an \texttt{R} session, and should produce the required output, without any modifications.
      \vskip1ex
Students will be allowed to consult lecture slides, and to copy code from them, and to copy from books or any online sources, but they will be required to provide references to those external sources (such as links or titles and page numbers).
      \vskip1ex
The tests will be closely based on code contained in the lecture slides, so students are encouraged to become very familiar with those slides.
      \vskip1ex
Students will submit their homework and test files only through \emph{Brightspace} (not emails).
      \vskip1ex
Students will be required to bring their laptop computers to class and run the \texttt{R} Interpreter, and the \texttt{RStudio} Integrated Development Environment (\emph{IDE}), during the lecture.
      \vskip1ex
Homeworks will also include reading assignments designed to help prepare for tests.
\end{block}
\pause

\begin{block}{Graduate Assistant}
The graduate assistant (GA) will be Shardha Koul (\href{mailto:sk9225@nyu.edu}{sk9225@nyu.edu}).\\
The GA will answer questions during office hours, or via \emph{Brightspace} forums, not via emails.  Please send emails regarding lecture matters from \emph{Brightspace} (not personal emails).
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Tips for Solving Homeworks and Tests}
\begin{frame}[t]{\subsecname}
\vspace{-1em}
  \begin{block}{Tips for Solving Homeworks and Tests}
    The tests will require mostly copying code samples from the lecture slides, making some modifications to them, and combining them with other code samples.
    \vskip1ex
    Partial credit will be given even for code that doesn't produce the correct output, but that has elements of code that can be useful for producing the right answer.
    \vskip1ex
    So don't leave test assignments unanswered, and instead copy any code samples from the lecture slides that are related to the solution and make sense.
    \vskip1ex
    Contact the GA during office hours via text or phone, and submit questions to the GA or to me via \emph{Brightspace}.
  \end{block}
\pause
  \begin{block}{Please Submit \emph{Minimal Working Examples} With Your Questions}
    When submitting questions, please provide a \emph{minimal working example} that produces the error in \texttt{R}, with the following items:
      \begin{itemize}
        \item The \emph{complete} \texttt{R} code that produces the error, including the seed value for random numbers,
        \item The version of \texttt{R} (output of command: \texttt{sessionInfo()}), and the versions of \texttt{R} packages, 
        \item The type and version of your operating system (Windows or OSX),
        \item The dataset file used by the \texttt{R} code,
        \item The text or screenshots of error messages,
      \end{itemize}
    \vskip1ex
    You can read more about producing \emph{minimal working examples} here:
      \url{http://stackoverflow.com/help/mcve}\\
      \url{http://www.jaredknowles.com/journal/2013/5/27/writing-a-minimal-working-example-mwe-in-r}
  \end{block}
\end{frame}


%%%%%%%%%%%%%%%
\subsection{Course Grading Policies}
\begin{frame}[t]{\subsecname}
\vspace{-1em}

\begin{block}{Numerical Scores}
  Homeworks and tests will be graded and assigned numerical scores.  
  Each part of homeworks and tests will be graded separately and assigned a numerical score.\\
  Maximum scores will be given only for complete code, that produces the correct output when it's pasted into an \texttt{R} session, without any modifications. 
  As long as the \texttt{R} code uses the required functions and produces the correct output, it will be given full credit.\\
  Partial credit will be given even for code that doesn't produce the correct output, but that has elements of code that can be useful for producing the right answer.
\end{block}
\pause

\begin{block}{Letter Grades}
  Letter grades for the course will be derived from the cumulative scores obtained for all the homeworks and tests.  Very high numerical scores close to the maximum won't guarantee an A letter grade, since grading will also depend on the difficulty of the assignments.
\end{block}
\pause

\begin{block}{Plagiarism}
  Plagiarism (copying from other students) and cheating will be punished.\\
  But copying code from lecture slides, books, or any online sources is allowed and encouraged.\\
  Students must provide references to any external sources from which they copy code (such as links or titles and page numbers).
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{FRE6871 Course Materials}
\begin{frame}[t]{\subsecname}
\vspace{-1em}

\begin{block}{Lecture Slides}
The course will be mostly self-contained, using detailed lecture slides containing extensive, working \texttt{R} code examples.\\
The course will also utilize data and tutorials which are freely available on the internet.
\end{block}
\pause

\begin{block}{FRE6871 Recommended Textbooks}
\begin{itemize}[]
  \item \href{https://people.orie.cornell.edu/davidr/SDAFE2/index.html}{\emph{Statistics and Data Analysis for Financial Engineering}} by David Ruppert, introduces regression, cointegration, multivariate time series analysis, \emph{ARIMA}, \emph{GARCH}, \emph{CAPM}, and factor models, with examples in \texttt{R}.
  % \fullcite{ruppertbook}\\
  \item \href{https://press.princeton.edu/books/hardcover/9780691166278/quantitative-risk-management}{\emph{Quantitative Risk Management}} by Alexander J. McNeil, Rudiger Frey, and Paul Embrechts: review of Value at Risk, factor models, ARMA and GARCH, extreme value theory, and credit risk models.
  \item \href{https://www.statlearning.com}{\emph{Introduction to Statistical Learning}} by Gareth James, Daniela Witten, Trevor Hastie, and Robert Tibshirani, introduces machine learning techniques using \texttt{R}, but without deep learning.
  % \fullcite{islbook}
  \item \href{http://adv-r.had.co.nz/}{\emph{Advanced \texttt{R}}} by Hadley Wickham, is the best book for learning the advanced features of \texttt{R}.
  % \fullcite{hadleybook}
  \item \href{http://it-ebooks.info/book/1734/}{\emph{The Art of \texttt{R} Programming}} by Norman Matloff, contains a good introduction to \texttt{R} and to some statistical models.
  % \fullcite{matloffbook}
\end{itemize}

Many textbooks can be downloaded in electronic format from the 
\href{http://library.nyu.edu/}{\emph{NYU Library}}.

\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{FRE6871 Supplementary Textbooks}
\begin{frame}[t]{\subsecname}
\vspace{-1em}

\begin{block}{Supplementary Textbooks}
\begin{itemize}[]
  \item The books \href{http://www.statmethods.net/}{\emph{\texttt{R} in Action}} by Robert Kabacoff and \href{http://www.jaredlander.com/r-for-everyone/}{\emph{\texttt{R} for Everyone}} by Jared Lander, are good introductions to \texttt{R} and to statistical models.
  % \fullcite{kabacoffbook}
  % \fullcite{landerbook}
  \item \href{http://eeecon.uibk.ac.at/~zeileis/teaching/AER/index.html}{\emph{Applied Econometrics with \texttt{R}}} by Christian Kleiber and Achim Zeileis, introduces advanced statistical models and econometrics.
  % \fullcite{kleiberbook}
  \item \href{http://www.nr.com/}{\emph{Numerical Recipes in \texttt{C++}}} by William Press, Saul Teukolsky, William Vetterling, and Brian Flannery, is a great reference for linear algebra and numerical methods, implemented in working \texttt{C++} code.
  % \fullcite{numrecipesbook}
\end{itemize}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{FRE6871 Supplementary Materials}
\begin{frame}[t]{\subsecname}

\begin{block}{}
  \begin{columns}[T]
    \column{0.7\textwidth}
      \texttt{Notepad++} is a free source code editor for \texttt{MS Windows}, that supports several programming languages, including \texttt{R}.
      \vskip1ex
      \texttt{Notepad++} has a very convenient and fast \emph{search and replace} function, that allows \emph{search and replace} in multiple files.\\
      \hskip1em\url{http://notepad-plus-plus.org/}
    \column{0.3\textwidth}
      \includegraphics[height=0.5\textwidth]{image/npp.jpg}
  \end{columns}
\end{block}

\end{frame}



%%%%%%%%%%%%%%%
\section{\texttt{R} Help and Documentation}


%%%%%%%%%%%%%%%
\subsection{Internal \texttt{R} Help and Documentation}
\begin{frame}[fragile,t]{\subsecname}

\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      The function \texttt{help()} displays documentation on a function or subject,\\
      \vskip1ex
      Preceding the keyword with a single \texttt{"?"} is equivalent to calling \texttt{help()}.
    \column{0.5\textwidth}
      \vspace{-1em}
% tidy=FALSE prevents translation of "?getwd" into "`?`(getwd)"
      <<echo=TRUE,eval=FALSE>>=
# Display documentation on function "getwd"
help(getwd)
# Equivalent to "help(getwd)"
?getwd
      @
  \end{columns}
\end{block}

\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      The function \texttt{help.start()} displays a page with links to internal documentation.
      \vskip1ex
      \texttt{R} documentation is also available in \texttt{RGui} under the help tab.
      \vskip1ex
      The \emph{pdf} files with \texttt{R} documentation are also available directly under:\\
%      \texttt{\color{blue}{C:/Program Files/R/R-3.1.2/bin/x64}}\\
      \href{C:/Program Files/R/R-3.1.2/doc/manual/}{C:/Program Files/R/R-3.1.2/doc/manual/}\\
      (the exact path will depend on the \texttt{R} version.)
    \column{0.5\textwidth}
      \vspace{-1em}
      <<echo=TRUE,eval=FALSE>>=
# Open the hypertext documentation
help.start()
      @
      \vskip1ex
      \includegraphics[height=0.2\textwidth]{image/Rlogo.png}
  \end{columns}
\end{block}

\begin{block}{}
  \href{http://cran.r-project.org/doc/manuals/r-release/R-intro.pdf}{Introduction to \texttt{R}}
  by Venables and \texttt{R} Core Team.
  % \fullcite{website:rintro}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{\texttt{R} Online Help and Documentation}
\begin{frame}[t]{\subsecname}
\vspace{-1em}

\begin{block}{\texttt{R} Cheat Sheets}
  \emph{Cheat Sheets} are a fast way to find what you want\\
  \hskip1em\url{https://www.rstudio.com/resources/cheatsheets/
}
\end{block}

\begin{block}{\texttt{R} Programming \texttt{Wikibook}}
  \texttt{Wikibooks} are crowdsourced textbooks\\
  \hskip1em\url{http://en.wikibooks.org/wiki/R_Programming/}\\
\end{block}

\begin{block}{\texttt{R FAQ}}
  Frequently Asked Questions about \texttt{R}\\
  \hskip1em\url{http://cran.r-project.org/doc/FAQ/R-FAQ.html}\\
\end{block}

\begin{block}{\texttt{R}-seek Online Search Tool}
  \texttt{R}-seek allows online searches specific to the \texttt{R} language\\
  \hskip1em\url{http://www.rseek.org/}
\end{block}

\begin{block}{\texttt{R}-help Mailing List}
  \texttt{R}-help is a very comprehensive Q\&A mailing list\\
  \hskip1em\url{https://stat.ethz.ch/mailman/listinfo/r-help}\\
  \texttt{R}-help has archives of past Q\&A - search it before you ask\\
  \hskip1em\url{https://stat.ethz.ch/pipermail/r-help/}\\
  GMANE allows searching the \texttt{R}-help archives using a usenet newsgroup style GUI\\
  \hskip1em\url{http://news.gmane.org/gmane.comp.lang.r.general}\\
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{\texttt{R} Code Style Guidelines}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}

\begin{block}{}
  Please follow the 
  \href{https://style.tidyverse.org/}{\color{blue}{\emph{RStudio Style Guide}}} 
  to make your \texttt{R} code more readable.
\end{block}

\begin{block}{Please also follow these \texttt{R} code style rules:}
  - Use the left arrow \texttt{"<-"} for assignment, not the equals sign \texttt{"="} (to insert \texttt{"<-"} into code, use the \emph{Alt-hyphen} shortcut in Windows),\\
  - Use \emph{nouns} for variable names and \emph{verbs} for function names,\\
  - Use a combination of lowercase letters, numbers, and underscores \texttt{"\_"} for names of variables and functions,\\
  - Add underscores \texttt{"\_"} to names to avoid conflicts with the names of existing \texttt{R} functions and variables,\\
  - Do not use dots \texttt{"."} in names, except in the names of function \emph{methods} (even though \texttt{R} uses them for variables as well),\\
  - Use underscores \texttt{"\_"} in file names, instead of spaces,\\
  - Always put a space after a comma, never before it: \texttt{"x, y"} not \texttt{"x , y"},\\
  - Do not put spaces inside or outside parentheses: \texttt{"if (x > 0)"} not \texttt{"if ( x > 0 )"},\\
  - Surround infix operators (\texttt{==, +, -, <-,} etc.) with spaces: \texttt{"x > 0"} not \texttt{"x>0"} (even though I don't always follow that rule, to save whitespace),\\
  - Add a comment after the closing curly bracket: \texttt{"\}  \# end my\_fun"},
\end{block}
  
\begin{block}{}
  You can reformat \texttt{R} code chunks using the 
  \href{http://styler.r-lib.org/}{\color{blue}{\emph{styler}}} 
  macros in the \emph{RStudio Addins} drop-down menu.\\
  You can also reformat whole files with \texttt{R} code by using the 
  \href{http://styler.r-lib.org/}{\color{blue}{\emph{styler}}} 
  package. 
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Stack Exchange}
\begin{frame}[t]{\subsecname}

\begin{columns}[T]
  \column{0.5\textwidth}
    \begin{block}{Stack Overflow}
      Stack Overflow is a Q\&A forum for computer programming, and is part of Stack Exchange\\
%  Stack Overflow is a Q\&A forum for programmers (covers many different languages)\\
      \hskip1em\url{http://stackoverflow.com}\\
      \hskip1em\url{http://stackoverflow.com/questions/tagged/r}\\
      \hskip1em\url{http://stackoverflow.com/tags/r/info}\\
    \end{block}

    \begin{block}{Stack Exchange}
      Stack Exchange is a family of Q\&A forums in a variety of fields\\
      \hskip1em\url{http://stackexchange.com/}\\
      \hskip1em\url{http://stackexchange.com/sites\#technology}\\
      \hskip1em\url{http://quant.stackexchange.com/}\\
    \end{block}
  \column{0.5\textwidth}
    \includegraphics[height=0.9\textwidth]{image/stack_exchange2.png}
\end{columns}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{\protect\emph{RStudio} Support}
\begin{frame}[t]{\subsecname}

\begin{block}{}
\emph{RStudio} has extensive online help, Q\&A database, and documentation\\
\hskip1em\url{https://support.rstudio.com/hc/en-us}\\
\vskip1ex
\hskip1em\url{https://support.rstudio.com/hc/en-us/sections/200107586-Using-RStudio}\\
\vskip1ex
\hskip1em\url{https://support.rstudio.com/hc/en-us/sections/200148796-Advanced-Topics}\\
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{\texttt{R} Online Books and References}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}

\begin{block}{Hadley Wickham book \emph{Advanced \texttt{R}}}
The best book for learning the advanced features of \texttt{R}:
\hskip1em\url{http://adv-r.had.co.nz/}
\end{block}

\begin{block}{Cookbook for \texttt{R} by Winston Chang from \emph{RStudio}}
Good plotting, but not interactive:
\hskip1em\url{http://www.cookbook-r.com/}
\end{block}

\begin{block}{Efficient \texttt{R} programming by Colin Gillespie and Robin Lovelace}
Good tips for fast \texttt{R} programming:
\hskip1em\url{https://csgillespie.github.io/efficientR/programming.html}
\end{block}

\begin{block}{Endmemo web book}
Good, but not interactive:
\hskip1em\url{http://www.endmemo.com/program/R/}
\end{block}

\begin{block}{Quick-R by Robert Kabacoff}
Good, but not interactive:
\hskip1em\url{http://www.statmethods.net/}
\end{block}

\begin{block}{\texttt{R} for Beginners by Emmanuel Paradis}
Good, basic introduction to \texttt{R}:
\hskip1em\url{http://cran.r-project.org/doc/contrib/Paradis-rdebuts_en.pdf}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{\texttt{R} Online Interactive Courses}
\begin{frame}[fragile,t]{\subsecname}

\begin{block}{Datacamp Interactive Courses}
  Datacamp introduction to \texttt{R}:
  \hskip1em\url{https://www.datacamp.com/courses/introduction-to-r/}
  \vskip1ex
  Datacamp list of free courses:
  \hskip1em\url{https://www.datacamp.com/community/open-courses}
  \vskip1ex
  Datacamp basic statistics in \texttt{R}:
  \hskip1em\url{https://www.datacamp.com/community/open-courses/basic-statistics}
  \vskip1ex
  Datacamp computational finance in \texttt{R}:
  \hskip1em\url{https://www.datacamp.com/community/open-courses/computational-finance-and-financial-econometrics-with-r}
  \vskip1ex
  Datacamp machine learning in \texttt{R}:
  \hskip1em\url{https://www.datacamp.com/community/open-courses/kaggle-r-tutorial-on-machine-learning}
\end{block}

\begin{block}{Try \texttt{R}}
  Interactive \texttt{R} tutorial, but rather basic:
  \hskip1em\url{http://tryr.codeschool.com/}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{\texttt{R} Blogs and Experts}
\begin{frame}[fragile,t]{\subsecname}

\begin{block}{R-Bloggers}
R-Bloggers is an aggregator of blogs dedicated to \texttt{R}\\
\hskip1em\url{http://www.r-bloggers.com/}\\
Tal Galili is the author of R-Bloggers and has his own excellent blog\\
\hskip1em\url{http://www.r-statistics.com/}\\
\end{block}

\begin{block}{Dirk Eddelbuettel}
Dirk is a \emph{Top Answerer} for \texttt{R} questions on Stackoverflow, the author of the \texttt{Rcpp} package, and the CRAN Finance View\\
\hskip1em\url{http://dirk.eddelbuettel.com/}\\
\hskip1em\url{http://dirk.eddelbuettel.com/code/}\\
\hskip1em\url{http://dirk.eddelbuettel.com/blog/}\\
\hskip1em\url{http://www.rinfinance.com/}\\
\end{block}

\begin{block}{Romain Frangois}
Romain is an \texttt{R} Enthusiast and \texttt{Rcpp} Hero\\
\hskip1em\url{http://romainfrancois.blog.free.fr/}\\
\hskip1em\url{http://romainfrancois.blog.free.fr/index.php?tag/graphgallery}\\
\hskip1em\url{http://blog.r-enthusiasts.com/}\\
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\begin{frame}[fragile,t]{More \subsecname}

\begin{block}{Revolution Analytics Blog}
\texttt{R} blog by Revolution Analytics software vendor\\
\hskip1em\url{http://blog.revolutionanalytics.com/}\\
\end{block}

\begin{block}{\emph{RStudio} Blog}
\texttt{R} blog by \emph{RStudio}\\
\hskip1em\url{http://blog.rstudio.org/}\\
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{\protect\emph{GitHub} for Hosting Software Projects Online}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      \emph{GitHub} is an internet-based online service for hosting repositories of software projects.
      \vskip1ex
      \emph{GitHub} provides version control using \emph{git} (desved by Linus Torvalds).
      \vskip1ex
      Most \texttt{R} projects are now hosted on \emph{GitHub}.
      \vskip1ex
      \emph{Google} uses \emph{GitHub} to host its \emph{tensorflow} library for machine learning:\\
      \hskip1em\url{https://github.com/tensorflow/tensorflow}
      \vskip1ex
      All the \emph{FRE-7241} and \emph{FRE-6871} lectures are hosted on \emph{GitHub}:\\
      \hskip1em\url{https://github.com/algoquant/lecture_slides}\\
      \hskip1em\url{https://github.com/algoquant}
      \vskip1ex
      Hosting projects on \emph{Google} is a great way to advertize your skills and network with experts.
    \column{0.5\textwidth}
    \includegraphics[width=0.5\paperwidth]{image/github_algoquant.png}
  \end{columns}
\end{block}

\end{frame}



%%%%%%%%%%%%%%%
\section{Getting Started With \texttt{R}}


%%%%%%%%%%%%%%%
\subsection{What is \texttt{R}?}
\begin{frame}[t]{\subsecname}
\vspace{-1em}
\begin{block}{}
\begin{columns}[T]
  \column{0.7\textwidth}
    \begin{itemize}
      \item An open-source software environment for statistical computing and graphics.
      \item An interpreted language, that allows interactive code development.
      \item A functional language where every operator is an \texttt{R} function.
      \item A very expressive language that can perform complex operations with very few lines of code.
      \item A language with metaprogramming facilities that allow programming on the language.
      \item A language written in \texttt{C/C++}, which can easily call other \texttt{C/C++} programs.
      \item Can be easily extended with \emph{packages} (function libraries), providing the latest developments like \emph{Machine Learning}.
      \item Supports object-oriented programming with \emph{classes} and \emph{methods}.
      \item Vectorized functions written in \texttt{C/C++}, allow very fast execution of loops over vector elements.
    \end{itemize}
  \column{0.3\textwidth}
    \href{http://www.r-project.org/}{\includegraphics[height=0.2\textwidth]{image/Rlogo.png} Project}
    \vskip1ex
    \href{http://en.wikipedia.org/wiki/R_(programming_language)}{\includegraphics[height=0.2\textwidth]{image/Rlogo.png} Wikipedia}
%    \hskip1em\url{http://blog.revolutionanalytics.com/2011/08/what-language-is-r-written-in.html}\\
\end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Why is \texttt{R} More Difficult Than Other Languages?}
\begin{frame}[t]{\subsecname}
\vspace{-1em}
\begin{block}{}
\begin{columns}[T]
  \column{0.7\textwidth}
    \texttt{R} is more difficult than other languages because:
    \begin{itemize}
      \item \texttt{R} is a \emph{functional} language, which makes its syntax unfamiliar to users of procedural languages like \texttt{C/C++}.
      \item The huge number of user-created \emph{packages} makes it difficult to tell which are the best for particular applications.
      \item \texttt{R} can produce very cryptic \emph{warning} and \emph{error} messages, because it's a programming environment, so it performs many operations quietly, but those can sometimes fail.
      \item Fixing errors usually requires analyzing the complex structure of the \texttt{R} programming environment.
    \end{itemize}
    This course is designed to teach the most useful elements of \texttt{R} for financial analysis, through case studies and examples,
  \column{0.3\textwidth}
    \includegraphics[height=0.2\textwidth]{image/Rlogo.png}
\end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{What are the Best Ways to Use \texttt{R}?}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      If used properly, \texttt{R} can be fast and interactive:
      \begin{itemize}
        \item Use \texttt{R} as an interface to libraries written in \texttt{C++}, \texttt{Java}, and \texttt{JavaScript}.
        \item Avoid using too many \texttt{R} function calls (every command in \texttt{R} is a function).
        \item Avoid using \texttt{apply()} and \texttt{for()} loops for large datasets.
        \item Use \texttt{R} functions which are \emph{compiled} \texttt{C++} code, instead of using interpreted \texttt{R} code.
        \item Use package \emph{data.table} for high performance data management.
        \item Use package \emph{shiny} for interactive charts of live models running in \texttt{R}.
        \item Use package \emph{dygraphs} for interactive time series plots.
        \item Use package \emph{knitr} for \emph{RMarkdown} documents.
        \item Pre-allocate memory for new objects.
        \item Write \texttt{C++} functions in \emph{Rcpp} and \emph{RcppArmadillo}.
      \end{itemize}
    \column{0.5\textwidth}
      \vspace{-1em}
      \includegraphics[width=0.45\paperwidth]{image/Jeremy_Clarkson_Linus_Torvalds.jpg}
      \vspace{-1em}
      <<echo=TRUE,eval=FALSE>>=
# Calculate cumulative sum of a vector
vectorv <- runif(1e5)
# Use compiled function
cumsumv <- cumsum(vectorv)
# Use for loop
cumsumv2 <- vectorv
for (i in 2:NROW(vectorv))
  cumsumv2[i] <- (cumsumv2[i] + cumsumv2[i-1])
# Compare the two methods
all.equal(cumsumv, cumsumv2)
# Microbenchmark the two methods
library(microbenchmark)
summary(microbenchmark(
  cumsum=cumsum(vectorv),
  loop=for (i in 2:NROW(vectorv))
    vectorv[i] <- (vectorv[i] + vectorv[i-1]),
  times=10))[, c(1, 4, 5)]
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{The \texttt{R} License}
\begin{frame}[t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.7\textwidth}
      \texttt{R} is open-source software released under the GNU General Public License:
      \vskip1ex
      \hskip1em\url{http://www.r-project.org/Licenses}\\
    \column{0.3\textwidth}
      \includegraphics[height=0.2\textwidth]{image/GPLv3_Logo.png}
  \end{columns}
\end{block}

\begin{block}{}
  \begin{columns}[T]
    \column{0.7\textwidth}
      Some other \texttt{R} packages are released under the Creative Commons Attribution-ShareAlike License:
      \vskip1ex
      \hskip1em\url{http://creativecommons.org}\\
    \column{0.3\textwidth}
      \includegraphics[height=0.1\textwidth]{image/CC_License.png}
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Installing \texttt{R} and \protect\emph{RStudio}}
\begin{frame}[t]{\subsecname}

\begin{block}{}
  Students will be required to bring their laptop computers to all the lectures, and to run the \texttt{R} Interpreter and \textbf{RStudio} RStudio during the lecture,
  \vskip1ex
  Laptop computers will be necessary for following the lectures, and for performing tests,
\end{block}

\begin{block}{}
  \begin{columns}[T]
    \column{0.7\textwidth}
      Students will be required to install and to become proficient with the \texttt{R} Interpreter,\\
      Students can download the \texttt{R} Interpreter from \texttt{CRAN} (Comprehensive \texttt{R} Archive Network):\\
      \hskip1em\url{http://cran.r-project.org/}
      \vskip1ex
      To invoke the \texttt{RGui} interface, click on:\\
      \href{C:/Program Files/R/R-3.1.2/bin/x64/RGui.exe}{C:/Program Files/R/R-3.1.2/bin/x64/RGui.exe}\\
    \column{0.3\textwidth}
      \includegraphics[height=0.2\textwidth]{image/Rlogo.png}
  \end{columns}
\end{block}

\begin{block}{}
  \begin{columns}[T]
    \column{0.7\textwidth}
      Students will be required to install and to become proficient with the \emph{RStudio} Integrated Development Environment (\emph{IDE}),\\
      \hskip1em\url{http://www.rstudio.com/products/rstudio/}
    \column{0.3\textwidth}
      \includegraphics[height=0.2\textwidth]{image/RStudio.png}
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Using \protect\emph{RStudio}}
\begin{frame}[t]{\subsecname}

% Snapshot of \emph{RStudio} GUI
\includegraphics[height=0.6\textwidth]{image/RStudio_screen.png}

\end{frame}



%%%%%%%%%%%%%%%
\section{The \texttt{R} Environment}


%%%%%%%%%%%%%%%
\subsection{A First \texttt{R} Session}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}

\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      Variables are created by an assignment operation, and they don't have to be declared.
      \vskip1ex
      The standard assignment operator in \texttt{R} is the arrow symbol \texttt{"<-"}.
      \vskip1ex
      \texttt{R} interretsp text in quotes ("") as character strings.
      \vskip1ex
      Text that is not in quotes ("") is interpreted as a \emph{symbol} or \emph{expression}.
      \vskip1ex
      Typing a \emph{symbol} or \emph{expression} evaluates it.
      \vskip1ex
      \texttt{R} uses the hash "\texttt{\#}" sign to mark text as comments.
      \vskip1ex
      All text after the hash "\texttt{\#}" sign is treated as a comment, and is not executed as code.
    \column{0.5\textwidth}
      \vspace{-1em}
      <<echo=TRUE,eval=TRUE>>=
# "<-" and "=" are valid assignment operators
myvar <- 3

# typing a symbol or expression evaluates it
myvar

# text in quotes is interpreted as a string
myvar <- "Hello World!"

# typing a symbol or expression evaluates it
myvar

myvar  # text after hash is treated as comment
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Exploring an \texttt{R} Session}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}

\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      The function \texttt{getwd()} returns a vector of length \texttt{1}, with the first element containing a string with the name of the current working directory (\texttt{cwd}).
      \vskip1ex
      The function \texttt{setwd()} accepts a character string as input (the name of the directory), and sets the working directory to that string.
      \vskip1ex
      \texttt{R} is a functional language, and \texttt{R} commands are functions, so they must be followed by parentheses \texttt{"()"}.
    \column{0.5\textwidth}
      \vspace{-1em}
      <<echo=TRUE,eval=FALSE>>=
getwd()  # get cwd
setwd("/Users/jerzy/Develop/R")  # Set cwd
getwd()  # get cwd
      @
  \end{columns}
\end{block}

\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      Get system date and time
      \vskip4ex
      Just the date
    \column{0.5\textwidth}
      \vspace{-1em}
      <<echo=TRUE,eval=TRUE>>=
Sys.time()  # get date and time

Sys.Date()  # get date only
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{The \texttt{R} Workspace}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}

\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      The workspace is the current \texttt{R} working environment, which includes all user-defined objects and the command history.
      \vskip1ex
      The function \texttt{ls()} returns names of objects in the \texttt{R} workspace.
      \vskip1ex
      The function \texttt{rm()} removes objects from the \texttt{R} workspace.
      \vskip1ex
      The workspace can be saved into and loaded back from an \texttt{.RData} file (compressed binary file format).
      \vskip1ex
      The function \texttt{save.image()} saves the whole workspace.
      \vskip1ex
      The function \texttt{save()} saves just the selected objects.
      \vskip1ex
      The function \texttt{load()} reads data from \texttt{.RData} files, and \emph{invisibly} returns a vector of names of objects created in the workspace.
    \column{0.5\textwidth}
      \vspace{-1em}
      <<echo=(-(1:2)),eval=FALSE>>=
rm(list=ls())
setwd("/Users/jerzy/Develop/lecture_slides/data")
var1 <- 3  # Define new object
ls()  # List all objects in workspace
# List objects starting with "v"
ls(pattern=glob2rx("v*"))
# Remove all objects starting with "v"
rm(list=ls(pattern=glob2rx("v*")))
save.image()  # Save workspace to file .RData in cwd
rm(var1)  # Remove object
ls()  # List objects
load(".RData")
ls()  # List objects
var2 <- 5  # Define another object
save(var1, var2,  # Save selected objects
     file="/Users/jerzy/Develop/lecture_slides/data/my_data.RData")
rm(list=ls())  # Remove all objects
ls()  # List objects
loadv <- load(file="/Users/jerzy/Develop/lecture_slides/data/my_data.RData")
loadv
ls()  # List objects
      @
  \end{columns}
\end{block}
% \pause

\end{frame}


%%%%%%%%%%%%%%%
\begin{frame}[fragile,t]{\subsecname \hskip0.5em (cont.)}
\vspace{-1em}

\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      When you quit \texttt{R} you'll be prompted "Save workspace image?"\\
      \vskip1ex
      If you answer $YES$ then the workspace will be saved into the \texttt{.RData} file in the \texttt{cwd},\\
      \vskip1ex
      When you start \texttt{R} again, the workspace will be automatically loaded from the existing \texttt{.RData} file,\\
    \column{0.5\textwidth}
      \vspace{-1em}
      <<echo=TRUE,eval=FALSE>>=
        q()  # quit R session
      @
  \end{columns}
\end{block}

\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      The function \texttt{history()} displays recent commands,\\
      \vskip1ex
      You can also save and load the command history from a file.
    \column{0.5\textwidth}
      \vspace{-1em}
      <<echo=TRUE,eval=FALSE>>=
history(5)  # Display last 5 commands
savehistory(file="myfile")  # Default is ".Rhistory"
loadhistory(file="myfile")  # Default is ".Rhistory"
      @
  \end{columns}
\end{block}
% \pause

\end{frame}


%%%%%%%%%%%%%%%
\subsection{\texttt{R} Session Info}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      The function \texttt{sessionInfo()} returns information about the current \texttt{R} session,
      \begin{itemize}
        \item \texttt{R version},
        \item \texttt{OS platform},
        \item \texttt{locale} settings,
        \item list of packages that are loaded and attached to the search path,
        \item list of packages that are loaded, but \emph{not} attached to the search path,
      \end{itemize}
    \column{0.5\textwidth}
      \vspace{-1em}
      <<echo=TRUE,eval=TRUE>>=
sessionInfo()  # get R version and other session info
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Environment Variables}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      \texttt{R} uses environment variables to store information about its environment, such as paths to directories containing files used by \texttt{R} (startup, history, OS).
      \vskip1ex
      For example the environment variables:
      \begin{itemize}
        \item \texttt{R\_USER} and \texttt{HOME} store the \texttt{R} user Home directory,
        \item \texttt{R\_HOME} stores the root directory of the \texttt{R} installation,
      \end{itemize}
      The functions \texttt{Sys.getenv()} and \texttt{Sys.setenv()} display and set the values environment variables.
      \vskip1ex
      \texttt{Sys.getenv("env\_var")} displays the environment variable \texttt{"env\_var"}.
      \vskip1ex
      \texttt{Sys.setenv("env\_var=value")} sets the environment variable \texttt{"env\_var"} equal to \texttt{"value"}.
    \column{0.5\textwidth}
      \vspace{-1em}
      <<echo=TRUE,eval=FALSE>>=
Sys.getenv()[5:7]  # List some environment variables

Sys.getenv("HOME")  # get R user HOME directory

Sys.setenv(Home="/Users/jerzy/Develop/data")  # Set HOME directory

Sys.getenv("HOME")  # get user HOME directory

Sys.getenv("R_HOME")  # get R_HOME directory

R.home()  # get R_HOME directory

R.home("etc")  # get "etc" sub-directory of R_HOME
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Global \protect\emph{Options} Settings}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      \texttt{R} uses a list of global \emph{options} which affect how \texttt{R} computes and displays results.
      \vskip1ex
      The function \texttt{options()} either sets or displays the values of global \emph{options}.
      \vskip1ex
      \texttt{options("globop")} displays the current value of option \texttt{"globop"}.
      \vskip1ex
      \texttt{getOption("globop")} displays the current value of option \texttt{"globop"}.
      \vskip1ex
      \texttt{options(globop=value)} sets the option \texttt{"globop"} equal to \texttt{"value"}.
    \column{0.5\textwidth}
      \vspace{-1em}
      <<echo=TRUE,eval=FALSE>>=
# ?options  # Long list of global options
# Interpret strings as characters, not factors
getOption("stringsAsFactors")  # Display option
options("stringsAsFactors")  # Display option
options(stringsAsFactors=FALSE)  # Set option
# number of digits printed for numeric values
options(digits=3)
# control exponential scientific notation of print method
# positive "scipen" values bias towards fixed notation
# negative "scipen" values bias towards scientific notation
options(scipen=100)
# maximum number of items printed to console
options(max.print=30)
# Warning levels options
# negative - warnings are ignored
options(warn=-1)
# zero - warnings are stored and printed after top-confl function has completed
options(warn=0)
# One - warnings are printed as they occur
options(warn=1)
# two or larger - warnings are turned into errors
options(warn=2)
# Save all options in variable
optionv <- options()
# Restore all options from variable
options(optionv)
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Constructing File Paths}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      Names of \emph{file paths} can be constructed using the function \texttt{paste()}.
      \vskip1ex
      The function \texttt{file.path()} is similar to \texttt{paste()}, but it also automatically uses the correct file separator for the computer platform.
      \vskip1ex
      The function \texttt{normalizePath()} performs tilde-expansions and displays file paths in user-readable format.
    \column{0.5\textwidth}
      \vspace{-1em}
      <<echo=TRUE,eval=TRUE>>=
# R startup (site) directory
paste(R.home(), "etc", sep="/")

file.path(R.home(), "etc")  # better way

# perform tilde-expansions and convert to readable format
normalizePath(file.path(R.home(), "etc"), winslash="/")

normalizePath(R.home("etc"), winslash="/")
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{\texttt{R} System Directories under \protect\emph{Windows}}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      \texttt{R} uses several different directories to search, read, and store files:
      \begin{itemize}
        \item \emph{Windows} user \texttt{personal} directory: \texttt{"\textasciitilde{}"} (\texttt{"\%USERPROFILE\%/Documents"}),
        \item \texttt{R} user \texttt{HOME} directory (\texttt{R\_USER} and \texttt{Home}),
        \item \texttt{cwd} current working directory - the default directory for storing and retrieving user files (such as \texttt{.Rhistory}, \texttt{.RData}, etc.),
        \item \texttt{R\_HOME} root directory of the \texttt{R} installation,
        \item \texttt{R} startup (site) directory: \texttt{R\_HOME/etc/},
      \end{itemize}
      By default, the \texttt{R} user \texttt{HOME} directory is the \emph{Windows} user \texttt{personal} directory.
      \vskip1ex
      The \texttt{cwd} is set to the directory from which \texttt{R} is invoked, or the \texttt{R} user \texttt{HOME} directory.
    \column{0.5\textwidth}
      \vspace{-1em}
      <<echo=TRUE,eval=FALSE>>=
normalizePath("~", winslash="/")  # Windows user HOME directory

Sys.getenv("HOME")  # R user HOME directory

setwd("/Users/jerzy/Develop/R")
getwd()  # current working directory

# R startup (site) directory
normalizePath(file.path(R.home(), "etc"), winslash="/")

# R executable directory
normalizePath(file.path(R.home(), "bin/x64"), winslash="/")

# R documentation directory
normalizePath(file.path(R.home(), "doc/manual"), winslash="/")
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{File and Directory Listing Functions}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      \vskip1ex
      The functions \texttt{list.files()} and \texttt{dir()} return a vector of names of files in a given directory.
      \vskip1ex
      The function \texttt{list.dirs()} listv the directories in a given directory.
      \vskip1ex
      The function \texttt{Sys.glob()} listv files matching names obtained from wildcard expansion.
    \column{0.5\textwidth}
      \vspace{-1em}
      <<echo=TRUE,eval=FALSE>>=
sample(dir(), 5)  # get 5 file names - dir() listv all files
sample(dir(pattern="csv"), 5)  # List files containing "csv"
sample(list.files(R.home()), 5)  # All files in R_HOME directory
sample(list.files(R.home("etc")), 5)  # All files in "etc" sub-directory of R_HOME directory
sample(list.dirs(), 5)  # Directories in cwd
list.dirs(R.home("etc"))  # Directories in "etc" sub-directory
sample(Sys.glob("*.csv"), 5)
Sys.glob(R.home("etc"))
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Invoking an \texttt{R} Session in \protect\emph{Windows}}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      An \texttt{R} session can run in several different ways:
      \begin{itemize}
        \item In an \texttt{R} terminal (by invoking \texttt{R.exe} or \texttt{Rterm.exe}),
        \item In an \texttt{R} RGui (by invoking \texttt{RGui.exe}),
        \item In an \emph{RStudio} session (or some other IDE),
      \end{itemize}
      The initial value of the \texttt{cwd} depends on how the \texttt{R} session is invoked.\\
      If \texttt{R} is invoked:
      \begin{itemize}
        \item from the \emph{Windows} menu, then \texttt{cwd} is set to the \texttt{R} user \texttt{HOME} directory,
        \item by clicking on a file (\texttt{*.R}, \texttt{.RData}, etc.), then \texttt{cwd} is set to the file's directory,
        \item by typing \texttt{R.exe} or \texttt{Rterm.exe} in the command shell (after setting the \texttt{PATH}), then \texttt{cwd} is set to the directory where the command was typed,
      \end{itemize}
    \column{0.5\textwidth}
      \vspace{-1em}
      <<echo=TRUE,eval=TRUE>>=
getwd()  # get cwd
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{\texttt{R} Session Startup}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      At startup \texttt{R} sources (reads) several types of files, in the following order:
      \begin{itemize}
        \item \texttt{Renviron} files defining environment variables,
        \item \texttt{Rprofile} files containing code executed at \texttt{R} startup,
        \item \texttt{RData} files containing data to be loaded at \texttt{R} startup,
      \end{itemize}
      \texttt{R} sources files from several directories, in the following order:
      \begin{itemize}
        \item \texttt{R} startup directory: \texttt{Renviron.site} and \texttt{Rprofile.site} files,
        \item \texttt{cwd} directory: \texttt{.Renviron}, \texttt{.Rprofile}, and \texttt{.RData} files,
        \item \texttt{HOME} user directory (only if no files found in \texttt{cwd}),
      \end{itemize}
      The above startup process can be customized by setting environment variables.
    \column{0.5\textwidth}
      \vspace{-1em}
      <<echo=(-1),eval=FALSE>>=
setwd("/Users/jerzy/Develop/R")
# help(Startup)  # Description of R session startup mechanism

# files in R startup directory directory
dir(normalizePath(file.path(R.home(), "etc"), winslash="/"))

# *.R* files in cwd directory
getwd()
dir(getwd(), all.files=TRUE, pattern="\\.R")
dir(getwd(), all.files=TRUE, pattern=glob2rx("*.R*"))
      @
  \end{columns}
\end{block}

\end{frame}



%%%%%%%%%%%%%%%
\section{Data Objects}


%%%%%%%%%%%%%%%
\subsection{Data Objects in \texttt{R}}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      All data objects in \texttt{R} are \emph{vectors}, or consist of \emph{vectors}.
      \vskip1ex
      Single numbers and character strings are vectors of length \texttt{"1"}.
      \vskip1ex
      \emph{Atomic} vectors are \emph{homogeneous} objects whose elements are all of the same \emph{mode} (type).
      \vskip1ex
      \emph{Lists} and \emph{data frames} are \emph{recursive} (heterogeneous) objects, whose elements can be vectors of different \emph{mode}.
      \vskip1ex
      The functions \texttt{is.atomic()} and \texttt{is.recursive()} return logical values depending on whether their arguments are \emph{atomic} or \emph{recursive}.
      \vskip1ex
      \renewcommand\arraystretch{1.5} % scale table rows
      \renewcommand\tabcolsep{8pt} % set table column width - 6pt is default
      \centering{{\color{blue}{\texttt{R} Data Objects}}}\\[1ex]
      \begin{tabular}{c||c|c|}
        & \text{\emph{Atomic}} & \text{\emph{Recursive}} \\
        \hline
        \hline
        \text{1-dim} & Vectors & Lists \\
        \hline
        \text{2-dim} & Matrices & Data frames \\
        \hline
        \text{n-dim} & Arrays & NA \\
      \end{tabular}
    \column{0.5\textwidth}
      \vspace{-1em}
        <<echo=TRUE,eval=TRUE>>=
# Single numbers are vectors of length 1
1
# Character strings are vectors of length 1
"a"
# Strings without quotes are variable names
a  # Variable "a" doesn't exist
# List elements can have different mode
list(aa=c("a", "b"), bb=1:5)
data.frame(aa=c("a", "b"), bb=1:2)
is.atomic(data.frame(aa=c("a", "b"), bb=1:2))
is.recursive(data.frame(aa=c("a", "b"), bb=1:2))
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Type, Mode, and Class of Objects}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      The \emph{type}, \emph{mode}, and \emph{class} are \texttt{character} strings representing various object properties.
      \vskip1ex
      The \emph{type} of an atomic object represents how it's stored in memory (\texttt{logical}, \texttt{character}, \texttt{integer}, \texttt{double}, etc.)
      \vskip1ex
      The \emph{mode} of an atomic object is the kind of data it represents (\texttt{logical}, \texttt{character}, \texttt{numeric}, etc.)
      \vskip1ex
      The \emph{mode} of an object often coincides with its \emph{type} (except for \texttt{integer} and \texttt{double} types).
      \vskip1ex
      Recursive objects (\texttt{listv}, \texttt{data frames}) have both \emph{type} and \emph{mode} equal to the recursive type (\texttt{list}).
      \vskip1ex
      The \emph{class} of an object is given by either an explicit \emph{class} attribute, or is derived from the object \emph{mode} and its \texttt{dim} attribute (implicit \emph{class}).
      \vskip1ex
      The function \texttt{class()} returns the explicit or implicit \emph{class} of an object.
      \vskip1ex
      The object \emph{class} is used for method dispatching in the \texttt{S3} object-oriented programming system in \texttt{R}.
    \column{0.5\textwidth}
      \vspace{-1em}
      <<echo=TRUE,eval=TRUE>>=
myvar <- "hello"
c(typeof(myvar), mode(myvar), class(myvar))

myvar <- 1:5
c(typeof(myvar), mode(myvar), class(myvar))

myvar <- runif(5)
c(typeof(myvar), mode(myvar), class(myvar))

myvar <- matrix(1:10, 2, 5)
c(typeof(myvar), mode(myvar), class(myvar))

myvar <- matrix(runif(10), 2, 5)
c(typeof(myvar), mode(myvar), class(myvar))

myvar <- list(aa=c("a", "b"), bb=1:5)
c(typeof(myvar), mode(myvar), class(myvar))

myvar <- data.frame(aa=c("a", "b"), bb=1:2)
c(typeof(myvar), mode(myvar), class(myvar))
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{\texttt{R} Object Attributes}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      \texttt{R} objects can have different attributes, such as: \texttt{namesv}, \texttt{dimnames}, \texttt{dimensions}, \emph{class}, etc.
      \vskip1ex
      The attributes of an object is a named \texttt{list} of \texttt{symbol=value} pairs.
      \vskip1ex
      The function \texttt{attributes()} returns the attributes of an object.
      \vskip1ex
      The attributes of an \texttt{R} object can be modified using the \texttt{"attributes() <-"} assignment.
      \vskip1ex
      The function \texttt{structure()} adds attributes (specified as \texttt{symbol=value} pairs) to an object, and returns it.
      \vskip1ex
      A \texttt{vector} that is assigned an attribute other than \texttt{namesv} is not treated as a \texttt{vector}.
      \vskip1ex
      The function \texttt{is.vector()} returns \texttt{TRUE} if its argument is a vector, and returns \texttt{FALSE} otherwise.
    \column{0.5\textwidth}
      \vspace{-1em}
      <<echo=TRUE,eval=TRUE>>=
# A simple vector has no attributes
attributes(5:10)
myvar <- c(pi=pi, euler=exp(1), gamma=-digamma(1))
# Named vector has "namesv" attribute
attributes(myvar)
myvar <- 1:10
is.vector(myvar)  # Is the object a vector?
attributes(myvar) <- list(my_attr="foo")
myvar
is.vector(myvar)  # Is the object a vector?
myvar <- 0
attributes(myvar) <- list(class="Date")
myvar  # "Date" object
structure(0, class="Date")  # "Date" object
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Modifying \protect\emph{class} Attributes}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      Objects without an explicit \emph{class} don't have a \emph{class} attribute, and the function \texttt{class()} returns the implicit \emph{class}.
      \vskip1ex
      The \emph{class} of an object can be modified using the \texttt{"class() <-"} assignment.
      \vskip1ex
      An object can have a main \emph{class}, and also an inherited \emph{class} (the \emph{class} attribute can be a vector of strings).
      \vskip1ex
      The function \texttt{unclass()} removes the explicit class attribute from an object.
    \column{0.5\textwidth}
      \vspace{-1em}
      <<echo=TRUE,eval=TRUE>>=
myvar <- matrix(runif(10), 2, 5)
class(myvar)  # Has implicit class
# But no explicit "class" attribute
attributes(myvar)
c(typeof(myvar), mode(myvar), class(myvar))
# Assign explicit "class" attribute
class(myvar) <- "my_class"
class(myvar)  # Has explicit "class"
# Has explicit "class" attribute
attributes(myvar)
is.matrix(myvar)  # Is the object a matrix?
is.vector(myvar)  # Is the object a vector?
attributes(unclass(myvar))
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Implicit Class of Objects}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      If an object has no explicit \emph{class}, then its implicit \emph{class} is derived from its \emph{mode} and \texttt{dim} attribute (except for \texttt{integer} vectors which have the implicit class \texttt{"integer"} derived from their \emph{type}).
      \vskip1ex
      If an \emph{atomic} object has a \texttt{dim} attribute, then its implicit \emph{class} is \texttt{matrix} or \texttt{array}.
      \vskip1ex
      \texttt{Data frames} have no explicit \texttt{dim} attribute, but \texttt{dim()} returns a value, so they have an implicit \texttt{dim} attribute.
    \column{0.5\textwidth}
      \vspace{-1em}
      <<echo=TRUE,eval=TRUE>>=
# Integer implicit class derived from type
myvar <- vector(mode="integer", length=10)
c(typeof(myvar), mode(myvar), class(myvar))
# Numeric implicit class derived from mode
myvar <- vector(mode="numeric", length=10)
c(typeof(myvar), mode(myvar), class(myvar))
# Adding dim attribute changes implicit class to matrix
dim(myvar) <- c(5, 2)
c(typeof(myvar), mode(myvar), class(myvar))
# Data frames have implicit dim attribute
myvar <- data.frame(aa=c("a", "b"), bb=1:2)
c(typeof(myvar), mode(myvar), class(myvar))
attributes(myvar)
dim(myvar)
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Object Coercion}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      \emph{Coercion} means changing the \emph{type}, \emph{mode}, or \emph{class} of an object, often without changing the underlying data.
      \vskip1ex
      Changing the \emph{mode} of an object can change its \emph{class} as well, but not always.
      \vskip1ex
      Objects can be explicitly coerced using the \texttt{"as.*"} coercion functions.
      \vskip1ex
      Most coercion functions strip the \emph{attributes} from the object.
      \vskip1ex
      Implicit coercion occurs when objects with different \texttt{modes} are combined into a vector, forcing the elements to have the same \emph{mode}.
      \vskip1ex
      Implicit coercion can cause bugs that are difficult to trace.
      \vskip1ex
      The rule is that coercion is into larger types (\texttt{numeric} objects are coerced into \texttt{character} strings).
      \vskip1ex
      Coercion can introduce bad data, such as \texttt{NA} values.
    \column{0.5\textwidth}
      \vspace{-1em}
      <<echo=TRUE,eval=TRUE>>=
myvar <- 1:5
c(typeof(myvar), mode(myvar), class(myvar))
mode(myvar) <- "character"  # Coerce to "character"
myvar
c(typeof(myvar), mode(myvar), class(myvar))
# Explicitly coerce to "character"
myvar <- as.character(1:5)
c(typeof(myvar), mode(myvar), class(myvar))
matrixv <- matrix(1:10, 2, 5)  # Create matrix
# Explicitly coerce to "character"
matrixv <- as.character(matrixv)
c(typeof(matrixv), mode(matrixv), class(matrixv))
# Coercion converted matrix to vector
c(is.matrix(matrixv), is.vector(matrixv))
as.logical(0:3)  # Explicit coercion to "logical"
as.numeric(c(FALSE, TRUE, TRUE, TRUE))
c(1:3, "a")  # Implicit coercion to "character"
# Explicit coercion to "numeric"
as.numeric(c(1:3, "a"))
      @
  \end{columns}
\end{block}

\end{frame}



%%%%%%%%%%%%%%%
\section{Atomic Data Objects}


%%%%%%%%%%%%%%%
\subsection{Basic \texttt{R} Objects}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      The quotation marks \texttt{""} (or \texttt{''}) around a character string tell \texttt{R} that it's a string, not a variable name.
      \vskip1ex
      Vectors are the basic building blocks of \texttt{R} objects.
      \vskip1ex
      There are no scalars in \texttt{R}, and single values are stored as vectors of length \texttt{"1"}.
      \vskip1ex
      A character string is also a vector with a single element, with the first element of the vector containing the string of text.
      \vskip1ex
      The colon binary operator \texttt{':'} produces a vector.
      \vskip1ex
      The function \texttt{c()} combines objects into a vector.
      \vskip1ex
      The \texttt{"[1]"} symbol means the return value is a vector.
      \vskip1ex
      The function \texttt{is.vector()} returns \texttt{TRUE} if its argument is a vector, and returns \texttt{FALSE} otherwise.
    \column{0.5\textwidth}
      \vspace{-1em}
      <<echo=TRUE,eval=FALSE>>=
"Hello World!"  # Type some text
# hello is a variable name, because it's not in quotes
hello  # R interretsp "hello" as a variable name
is.vector(1)  # Single number is a vector
is.vector("a")  # String is a vector
4:8  # Create a vector
# Create vector using c() combine function
c(1, 2, 3, 4, 5)
# Create vector using c() combine function
c("a", "b", "c")
# Create vector using c() combine function
c(1, "b", "c")
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Character Strings}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      Character \texttt{strings} are sequences of characters (and vectors of length one).
      \vskip1ex
      The function \texttt{nchar()} returns the length of a string.
      \vskip1ex
      Special characters in strings:\\
      \texttt{"\textbackslash{}t"} for TAB,\\
      \texttt{"\textbackslash{}n"} for new-line,\\
      "\texttt{\textbackslash{}}\texttt{\textbackslash{}}" for a (single) backslash character
      \vskip1ex
      The function \texttt{cat()} concatenates strings and echos them to console, without returning any values.
      \vskip1ex
      The function \texttt{cat()} is useful in user-defined functions.
    \column{0.5\textwidth}
      \vspace{-1em}
      <<echo=TRUE,eval=TRUE>>=
stringv <- "Some string"
stringv
stringv[1]
stringv[2]

NROW(stringv)  # length of vector
nchar(stringv)  # length of string

# Concatenate and echo to console
cat("Hello", "World!")
cat("Enter\ttab")
cat("Enter\nnewline")
cat("Enter\\backslash")
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Manipulating Strings}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      The function \texttt{paste()} concatenates its arguments into a string, coerces them to characters if needed, and returns the string.
      \vskip1ex
      If a vector or list is passed to \texttt{paste()}, together with a \texttt{collapse} string, then \texttt{paste()} concatenates the elements into a string, separated by the \texttt{collapse} string.
      \vskip1ex
      The function \texttt{strsplit()} splits the elements of a character vector.
      \vskip1ex
      Splitting on the \texttt{"."} character requires surrounding it with brackets: \texttt{"[.]"}, or using argument \texttt{fixed=TRUE}.
      \vskip1ex
      The function \texttt{substring()} extracts or replaces substrings in a character string.
      \vskip1ex
      The recycling rule extends the length to match the longest object.
    \column{0.5\textwidth}
      \vspace{-1em}
      <<echo=TRUE,eval=TRUE>>=
stringv1 <- "Hello"  # Define a character string
stringv2 <- "World!"  # Define a character string
paste(stringv1, stringv2, sep=" ")  # Concatenate and return value
cat(stringv1, stringv2)  # Concatenate and echo to console
paste("a", 1:4, sep="-")  # Convert, recycle and concatenate
paste(c("a1", "a2", "a3"), collapse="+")  # Collapse vector to string
paste(list("a1", "a2", "a3"), collapse="+")
paste("Today is", Sys.time())  # Coerce and concatenate strings
paste("Today is", format(Sys.time(), "%B-%d-%Y"))
strsplit("Hello World", split="r")  # Split string
strsplit("Hello.World", split="[.]")  # Split string
strsplit("Hello.World", split=".", fixed=TRUE)  # Split string
substring("Hello World", 3, 6)  # Extract characters from 3 to 6
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Regular Expressions in \texttt{R}}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      \texttt{R} has Regex functions for pattern matching and replacement.
      \vskip1ex
      The function \texttt{gsub()} replaces all matches of a pattern in a string.
      \vskip1ex
      The function \texttt{grep()} searches for matches of a pattern in a string.
      \vskip1ex
      The function \texttt{glob2rx()} converts globbing wildcard patterns into regular expressions.
    \column{0.5\textwidth}
      \vspace{-1em}
      <<echo=TRUE,eval=TRUE>>=
gsub("is", "XX", "is this gratis?")  # Replace "is" with "XX"

grep("b", c("abc", "xyz", "cba d", "bbb"))  # Get indexes

grep("b", c("abc", "xyz", "cba d", "bbb"), value=TRUE)  # Get values

glob2rx("abc.*")  # Convert globs into regex
glob2rx("*.doc")
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Vectors}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      Vectors are the basic building blocks of \texttt{R} objects.
      \vskip1ex
      There are no scalars in \texttt{R}, and single values are stored as vectors of length \texttt{"1"}.
      \vskip1ex
      The function \texttt{c()} combines values into a vector.
      \vskip1ex
      The function \texttt{is.vector()} returns \texttt{TRUE} if its argument is a vector, and returns \texttt{FALSE} otherwise.
      \vskip1ex
      The object \texttt{letters} is a constant and a vector,
     \column{0.5\textwidth}
      \vspace{-1em}
      <<echo=TRUE,eval=TRUE>>=
is.vector(1)  # Single number is a vector
is.vector("a")  # String is a vector
vectorv <- c(8, 6, 5, 7)  # Create vector
vectorv
vectorv[2]  # Extract second element
# Extract all elements, except the second element
vectorv[-2]
# Create Boolean vector
c(FALSE, TRUE, TRUE)
# Extract second and third elements
vectorv[c(FALSE, TRUE, TRUE)]
letters[5:10]  # Vector of letters
c("a", letters[5:10])  # Combine two vectors of letters
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\begin{frame}[fragile,t]{Creating \subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      The colon operator (\texttt{":"}) provides a simple way of creating a numeric vector.
      \vskip1ex
      The function \texttt{vector()} returns a vector of the specified \emph{mode}.
      \vskip1ex
      The functions \texttt{seq()}, \texttt{seq\_len()}, and \texttt{seq\_along()} return a sequence (vector) of numbers.
      \vskip1ex
      The function \texttt{rep()} replicates an object multiple times.
      \vskip1ex
      The functions \texttt{character()} and \texttt{numeric()} return zero-length vectors of the specified \emph{mode} (not to be confused with a \texttt{NULL} object).
      \vskip1ex
      Zero length vectors are not the same as \texttt{NULL} objects.
    \column{0.5\textwidth}
      \vspace{-1em}
      <<echo=TRUE,eval=TRUE>>=
0:10  # Vector of integers from 0 to 10
vector()  # Create empty vector
vector(mode="numeric", length=10)  # Numeric vector of zeros
seq(10)  # Sequence from 1 to 10
seq(along=(-5:5))  # Instead of 1:NROW(obj)
seq_along(c("a", "b", "c"))  # Instead of 1:NROW(obj)
seq(from=0, to=1, len=11)  # Decimals from 0 to 1.0
seq(from=0, to=1, by=0.1)  # Decimals from 0 to 1.0
seq(-2,2, len=11)  # 10 numbers from -2 to 2
rep(100, times=5)  # Replicate a number
character(5)  # Create empty character vector
numeric(5)  # Create empty numeric vector
numeric(0)  # Create zero-length vector
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\begin{frame}[fragile,t]{Arithmetic and Logical Operations on \subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      Vectors can be multiplied and squared element by element, as if they were single elements.
      \vskip1ex
      When vectors are manipulated as if they were single elements, then \texttt{R} automatically performs a loop over the vector elements, and applies the operation element-wise.
      \vskip1ex
      This is a very powerful feature of \texttt{R} called \emph{vectorized arithmetic}.
      \vskip1ex
      \emph{Vectorized arithmetic} avoids writing loops and simplifies notation.
      \vskip1ex
      Vectors can be combined together and appended.
    \column{0.5\textwidth}
      \vspace{-1em}
      <<echo=TRUE>>=
2*4:8  # Multiply a vector
2*(4:8)  # Multiply a vector
4:8/2  # Divide a vector
(0:10)/10  # Divide vector - decimals from 0 to 1.0
vectorv <- c(8, 6, 5, 7)  # Create vector
vectorv
# Boolean vector TRUE if element is equal to second one
vectorv == vectorv[2]
# Boolean vector TRUE for elements greater than six
vectorv > 6
2*vectorv  # Multiply all elements by 2
vectorv^2  # Square all elements
c(11, 5:10)  # Combine two vectors
c(vectorv, 2.0)  # Append number to vector
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\begin{frame}[fragile,t]{Naming and Manipulating \subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      Vector elements can be assigned \texttt{namesv} using a list of symbol-value pairs.
      \vskip1ex
      The function \texttt{names()} returns the \texttt{namesv} attribute of an object.
      \vskip1ex
      The \texttt{namesv} attribute of a vector can be modified by assigning to the \texttt{names()} function ("\texttt{names() <-}" assignment).
      \vskip1ex
      The function \texttt{unname()} removes the \texttt{namesv} attribute.
      \vskip1ex
      The function \texttt{structure()} adds attributes (specified as \texttt{symbol=value} pairs) to an object, and returns it.
    \column{0.5\textwidth}
      \vspace{-1em}
      <<echo=TRUE,eval=TRUE>>=
vectorv <- # Create named vector
  c(pi_const=pi, euler=exp(1), gamma=-digamma(1))
vectorv
names(vectorv)  # Get names of elements
vectorv["euler"]  # Get element named "euler"
names(vectorv) <- c("pie","eulery","gammy")  # Rename elements
vectorv
unname(vectorv)  # Remove names attribute
letters[5:10]  # Vector of letters
c("a", letters[5:10])  # Combine two vectors of letters
# Create named vector
structure(sample(1:5), names=paste0("el", 1:5))
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\begin{frame}[fragile,t]{Subsetting \subsecname}
\vspace{-1em}

\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      Vector elements can be \emph{subset} (indexed, referenced) using the \texttt{"[]"} operator.
      \vskip1ex
      Vectors can be \emph{subset} using vectors of:
      \begin{itemize}
        \item positive integers,
        \item negative integers,
        \item characters (names),
        \item Boolean vectors,
      \end{itemize}
      \vskip1ex
      Negative integers remove the vector elements.
      \vskip1ex
      Subsetting with \emph{zero} returns a zero-length vector.
      \vskip1ex
      A named vector can be \emph{subset} using element names.
    \column{0.5\textwidth}
      \vspace{-1em}
      <<echo=TRUE,eval=TRUE>>=
vectorv  # Named vector
# Extract second element
vectorv[2]
# Extract all elements, except the second element
vectorv[-2]
# Extract zero elements - returns zero-length vector
vectorv[0]
# Extract second and third elements
vectorv[c(FALSE, TRUE, TRUE)]
# Extract elements using their names
vectorv["eulery"]
# Extract elements using their names
vectorv[c("pie", "gammy")]
# Subset whole vector
vectorv[] <- 0
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\begin{frame}[fragile,t]{Filtering \subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      \emph{Filtering} means extracting elements from a vector that satisfy a logical condition.
      \vskip1ex
      When logical comparison operators are applied to vectors, they produce \texttt{Boolean} vectors.
      \vskip1ex
      \texttt{Boolean} vectors can then be applied to subset the original vectors, to extract their elements.
      \vskip1ex
      The function \texttt{which()} returns the indices of the \texttt{TRUE} elements of a \texttt{Boolean} \texttt{vector} or \texttt{array}.
    \column{0.5\textwidth}
      \vspace{-1em}
      <<echo=TRUE,eval=TRUE>>=
vectorv <- runif(5)
vectorv
vectorv > 0.5  # Boolean vector
# Boolean vector of elements equal to the second one
vectorv == vectorv[2]
# Extract all elements equal to the second one
vectorv[vectorv == vectorv[2]]
vectorv < 1  # Boolean vector of elements less than one
# Extract all elements greater than one
vectorv[vectorv > 1]
vectorv[vectorv > 0.5]  # Filter elements > 0.5
which(vectorv > 0.5)  # Index of elements > 0.5
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Factors}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      Factors are similar to vectors, but their elements can only take values from a set of \emph{levels}.
      \vskip1ex
      Factors are designed for categorical data which can only take certain values.
      \vskip1ex
      The function \texttt{factor()} converts a vector into a factor.
      \vskip1ex
      Factors have two attributes: \emph{class} (equal to \texttt{"factor"}) and \texttt{levels} (the allowed values).
      \vskip1ex
      Although factors aren't vectors, the data underlying a factor is an integer vector, called an \emph{encoding vector}.
      \vskip1ex
      The function \texttt{as.numeric()} extracts the encoding vector (indices) of a factor.
      \vskip1ex
      The function \texttt{as.vector()} coerces a factor to a character vector.
    \column{0.5\textwidth}
      \vspace{-1em}
      <<echo=TRUE,eval=TRUE>>=
# Create factor vector
factorv <- factor(c("b", "c", "d", "a", "c", "b"))
factorv
factorv[3]
# Get factor attributes
attributes(factorv)
# Get allowed values
levels(factorv)
# Get encoding vector
as.numeric(factorv)
is.vector(factorv)
# Coerce vector to factor
as.factor(1:5)
# Coerce factor to character vector
as.vector(as.factor(1:5))
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Tables of Categorical Data}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      The function \texttt{unique()} calculates the unique elements of an object.
      \vskip1ex
      The function \texttt{levels()} extracts the \texttt{levels} attribute of a factor (the allowed values).
      \vskip1ex
      A contingency table is a matrix that contains the frequency distribution of variables (factors) contained in a set of data.
      \vskip1ex
      The function \texttt{table()} calculates the frequency distribution of categorical data.
      \vskip1ex
      \texttt{sapply()} applies a function to a vector or a list of objects and returns a vector or a list.
    \column{0.5\textwidth}
      \vspace{-1em}
      <<echo=TRUE,eval=TRUE>>=
factorv
# Get unique elements
unique(factorv)
# Get levels attribute of the factor
levels(factorv)
# Calculate the factor elements from its levels
levels(factorv)[as.numeric(factorv)]
# Get contingency (frequency) table
table(factorv)
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Classifying Continuous Numeric Data Into Categories}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      Numeric data that represents a \emph{magnitude}, \emph{intensity}, or \emph{score} can be classified into categorical data, given a vector of \emph{breakpoints}.
      \vskip1ex
      The \emph{breakpoints} create intervals that correspond to different \emph{categories}.
      \vskip1ex
      The \emph{categories} combine elements that have a similar numeric \emph{magnitude}.
      \vskip1ex
      \texttt{findInterval()} returns the indices of the intervals specified by \texttt{"vec"} that contain the elements of \texttt{"x"}.
      \vskip1ex
      If there's an exact match, then \texttt{findInterval()} returns the same index as function \texttt{match()}.
      \vskip1ex
      If there's no exact match, then \texttt{findInterval()} finds the element of \texttt{"vec"} that is closest to, but not greater than, the element of \texttt{"x"}.
      \vskip1ex
      If all the elements of \texttt{"vec"} are greater than the element of \texttt{"x"}, then \texttt{findInterval()} returns \texttt{zero}.
      \vskip1ex
      \texttt{args()} displays the formal arguments of a function.
    \column{0.5\textwidth}
      \vspace{-1em}
      <<echo=TRUE,eval=TRUE>>=
# Display the formal arguments of findInterval
args(findInterval)
# Get index of the element of "vec" that matches 5
findInterval(x=5, vec=c(3, 5, 7))
match(5, c(3, 5, 7))
# No exact match
findInterval(x=6, vec=c(3, 5, 7))
match(6, c(3, 5, 7))
# Indices of "vec" that match elements of "x"
findInterval(x=1:8, vec=c(3, 5, 7))
# Return only indices of inside intervals
findInterval(x=1:8, vec=c(3, 5, 7), all.inside=TRUE)
# make rightmost interval inclusive
findInterval(x=1:8, vec=c(3, 5, 7), rightmost.closed=TRUE)
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Classifying Numeric Data Into Categories Example}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      Temperature can be categorized into "cold", "warm", "hot", etc.
      \vskip1ex
      A named numeric vector of \emph{breakpoints} can be used to convert a temperature into one of the \emph{categories}.
      \vskip1ex
      \emph{Breakpoints} correspond to \emph{categories} of the data.
      \vskip1ex
      The first \emph{breakpoint} should correspond to the lowest \emph{category}, and should have a value less than any of the data.
    \column{0.5\textwidth}
      \vspace{-1em}
      <<echo=TRUE,eval=TRUE>>=
# Named numeric vector of breakpoints
brea_ks <- c(freezing=0, very_cold=30, cold=50, 
             pleasant=60, warm=80, hot=90)
brea_ks
tempe_ratures <- runif(10, min=10, max=100)
feels_like <- names(
  brea_ks[findInterval(x=tempe_ratures, vec=brea_ks)])
names(tempe_ratures) <- feels_like
tempe_ratures
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Converting Numeric Data Into Factors Using \texttt{cut()}}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      The function \texttt{cut()} converts a numeric vector into a vector of factors, representing the intervals to which the numeric values belong.
      \vskip1ex
      \texttt{cut()} divides the range of values into intervals, based on a vector of breaks.
      \vskip1ex
      \texttt{cut()} then assigns factors to the numeric values, representing the intervals to which the numeric values belong.
      \vskip1ex
      The parameter \texttt{breaks} is a numeric vector of break points that divide the range of values into intervals.
      \vskip1ex
      The argument \texttt{"labels"} is a vector of labels for the intervals.
      \vskip1ex
      The argument \texttt{"right"} is a Boolean indicating if the intervals should be closed on the right (and open on the left), or vice versa.
      \vskip1ex
      \texttt{cut()} can produce the same classification as \texttt{findInterval()}, but \texttt{findInterval()} is faster than \texttt{cut()}, because it's a compiled function.
      \column{0.5\textwidth}
      \vspace{-1em}
      <<echo=(-(1:1)),eval=TRUE>>=
library(microbenchmark)
datav <- sample(0:6) + 0.1
datav
cut(x=datav, breaks=c(2, 4, 6, 8))
rbind(datav, cut(x=datav, breaks=c(2, 4, 6, 8)))
# cut() replicates findInterval()
cut(x=1:8, breaks=c(3, 5, 7), labels=1:2,
    right=FALSE)
findInterval(x=1:8, vec=c(3, 5, 7))
# findInterval() is a compiled function, so it's faster than cut()
vectorv <- rnorm(1000)
summary(microbenchmark(
  find_interval=
    findInterval(x=vectorv, vec=c(3, 5, 7)),
  cuut=
    cut(x=vectorv, breaks=c(3, 5, 7)),
  times=10))[, c(1, 4, 5)]  # end microbenchmark summary
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Plotting Histograms of Frequency Data}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      The function \texttt{hist()} calculates and plots a histogram, and returns its data \emph{invisibly}.
      \vskip1ex
      The parameter \texttt{breaks} is the number of cells of the histogram.
      \vskip1ex
      If the argument \texttt{freq} is \texttt{TRUE} then the frequencies (counts) are plotted, and if it's \texttt{FALSE} then the probability density is plotted (with total area equal to $1$).
      \vskip1ex
      The function \texttt{density()} calculates a kernel estimate of the probability density for a sample of data.
      \vskip1ex
      The function \texttt{lines()} draws a line through specified points.
      <<echo=TRUE,eval=FALSE>>=
# Calculate VTI percentage returns
returns <- na.omit(rutils::etfenv$returns$VTI)
# Plot histogram
x11(width=6, height=5)
par(mar=c(1, 1, 1, 1), oma=c(2, 2, 2, 0))
madv <- mad(returns)
histp <- hist(returns, breaks=100, 
  main="", xlim=c(-5*madv, 5*madv), 
  xlab="", ylab="", freq=FALSE)
      @
    \column{0.5\textwidth}
    \vspace{-1em}
    \includegraphics[width=0.45\paperwidth]{figure/hist_vti.png}
    \vspace{-1em}
      <<echo=TRUE,eval=FALSE>>=
# Draw kernel density of histogram
lines(density(returns), col="red", lwd=2)
# Add density of normal distribution
curve(expr=dnorm(x, mean=mean(returns), sd=sd(returns)), 
      add=TRUE, type="l", lwd=2, col="blue")
title(main="VTI Return Distribution", line=0)
# Add legend
legend("topright", inset=0.05, cex=0.8, title=NULL,
  leg=c("VTI", "Normal"), bty="n",
  lwd=6, bg="white", col=c("red", "blue"))
# Total area under histogram
sum(diff(histp$breaks) * histp$density)
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Matrices}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}

\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      The function \texttt{matrix()} creates a matrix from a vector, and the matrix dimensions.
      \vskip1ex
      By default \texttt{matrix()} creates matrices column-wise, unless the argument \texttt{byrow=TRUE} is used.
      \vskip1ex
      The elements of matrices can be subset (referenced) using the \texttt{"[]"} operator.
      \vskip1ex
      The functions \texttt{nrow()} and \texttt{ncol()} return the number of rows and columns of a matrix.
      \vskip1ex
      The functions \texttt{NROW()} and \texttt{NCOL()} also return the number of rows or columns of a matrix, but they can also be applied to vectors, and treat vectors as single column matrices.
    \column{0.5\textwidth}
      \vspace{-1em}
      <<echo=TRUE,eval=TRUE>>=
matrixv <- matrix(5:10, nrow=2, ncol=3)  # Create a matrix
matrixv  # By default matrices are constructed column-wise
# Create a matrix row-wise
matrix(5:10, nrow=2, byrow=TRUE)
matrixv[2, 3]  # Extract third element from second row
matrixv[2, ]  # Extract second row
matrixv[, 3]  # Extract third column
matrixv[, c(1,3)]  # Extract first and third column
matrixv[, -2]  # Remove second column
# Subset whole matrix
matrixv[] <- 0
# Get the number of rows or columns
nrow(vectorv); ncol(vectorv)
NROW(vectorv); NCOL(vectorv)
nrow(matrixv); ncol(matrixv)
NROW(matrixv); NCOL(matrixv)
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Matrix Attributes}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      Arrays are vectors with a dimension attribute.
      \vskip1ex
      Matrices are two-dimensional arrays.
      \vskip1ex
      The dimension attribute of a matrix is an integer vector of length 2 (nrow, ncol).
      \vskip1ex
      The \texttt{dimnames} attribute is a list, with vector elements containing row and column names.
      \vskip1ex
      A named matrix can be subset using row and column names.
    \column{0.5\textwidth}
      \vspace{-1em}
      <<echo=TRUE,eval=TRUE>>=
attributes(matrixv)  # Get matrix attributes
dim(matrixv)  # Get dimension attribute
class(matrixv)  # Get class attribute
rownames(matrixv) <- c("row1", "row2")  # Rownames attribute
colnames(matrixv) <- c("col1", "col2", "col3")  # Colnames attribute
matrixv
matrixv["row2", "col3"]  # Third element from second row
names(matrixv)  # Get the names attribute
dimnames(matrixv)  # Get dimnames attribute
attributes(matrixv)  # Get matrix attributes
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Matrix Subsetting}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      Matrices can be subset in a similar way as Vectors, either by indices (integers), by characters (names), or \texttt{Boolean} vectors.
      \vskip1ex
      Subsetting a matrix to a single row or column produces a vector, unless the parameter \texttt{"drop=FALSE"} is used.
      \vskip1ex
      Subsetting with the parameter \texttt{"drop=FALSE"} prevents the implicit coercion and preserves the matrix \emph{class}.
      \vskip1ex
      This is an example of implicit coercion in \texttt{R}, which can cause difficult to trace bugs.
    \column{0.5\textwidth}
      \vspace{-1em}
      <<echo=TRUE,eval=TRUE>>=
matrixv  # matrix with column names
matrixv[1, ]  # Subset rows by index
matrixv[, "col1"]  # Subset columns by name
matrixv[, c(TRUE, FALSE, TRUE)]  # Subset columns Boolean vector
matrixv[1, ]  # Subsetting can produce a vector!
class(matrixv); class(matrixv[1, ])
is.matrix(matrixv[1, ]); is.vector(matrixv[1, ])
matrixv[1, , drop=FALSE]  # Drop=FALSE preserves matrix
class(matrixv[1, , drop=FALSE])
is.matrix(matrixv[1, , drop=FALSE]); is.vector(matrixv[1, , drop=FALSE])
      @
  \end{columns}
\end{block}

\end{frame}



%%%%%%%%%%%%%%%
\section{Operators}


%%%%%%%%%%%%%%%
\subsection{Logical Operators}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      \texttt{R} has the following logical operators:
      \begin{itemize}
        \item \texttt{"<"} less than,
        \item \texttt{"<="} less than or equal to,
        \item \texttt{">"} greater than,
        \item \texttt{">="} greater than or equal to,
        \item \texttt{"=="} exactly equal to,
        \item \texttt{"!="} not equal to,
        \item \texttt{"!x"} Not \texttt{x},
        \item \texttt{"x \& y"} \texttt{x} AND \texttt{y},
        \item \texttt{"x | y"} \texttt{x} OR \texttt{y},
      \end{itemize}
      These operators are applied to vectors element-wise.
    \column{0.5\textwidth}
      \vspace{-1em}
        <<echo=(-(1:1))>>=
rm(list=ls())
TRUE | FALSE
TRUE | NA
vector1 <- c(2, 4, 6)
vector1 < 5  # Element-wise comparison
(vector1 < 5) & (vector1 > 3)
vector1[(vector1 < 5) & (vector1 > 3)]
vector2 <- c(-10, 0, 10)
vector1 < vector2
c(FALSE, TRUE, FALSE) & c(TRUE, TRUE, FALSE)
c(FALSE, TRUE, FALSE) | c(TRUE, TRUE, FALSE)
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Long Form Logical Operators}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      \texttt{R} also has two long form logical operators:
      \begin{itemize}
        \item \texttt{"x \&\& y"} \texttt{x} AND \texttt{y},
        \item \texttt{"x || y"} \texttt{x} OR \texttt{y},
      \end{itemize}
      These operators differ from the short form operators in two ways:
      \begin{itemize}
        \item They only evaluate the first elements of their vector arguments,
        \item They short-circuit (stop evaluation as soon as the expression is determined),
      \end{itemize}
      {\color{red}{Rule of Thumb}}
      \begin{itemize}
        \item Use \texttt{"\&\&"} and \texttt{"||"} in if-clauses,
      \end{itemize}
    \column{0.5\textwidth}
      \vspace{-1em}
        <<echo=(-(1:1))>>=
rm(list=ls())
c(FALSE, TRUE, FALSE) && c(TRUE, TRUE, FALSE)
c(FALSE, TRUE, FALSE) || c(TRUE, TRUE, FALSE)
echo_true <- function() {cat("echo_true\t"); TRUE}
echo_false <- function() {cat("echo_false\t"); FALSE}
echo_true() | echo_false()
echo_true() || echo_false()  # echo_false() isn't evaluated at all!
vectorv <- c(2, 4, 6)
# Works (does nothing) using '&&'
if (is.matrix(vectorv) && (vectorv[2, 3] > 0)) {
  vectorv[2, 3] <- 1
}
# No short-circuit so fails (produces an error)
if (is.matrix(vectorv) & (vectorv[2, 3] > 0)) {
  vectorv[2, 3] <- 1
}
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Arithmetic Operators}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      Arithmetic \emph{operators} perform arithmetic operations on \texttt{numeric} or \texttt{complex} vectors,
      \begin{itemize}
        \item "\texttt{+}" performs addition,
        \item "\texttt{-}" performs subtraction,
        \item "\texttt{*}" performs multiplication,
        \item "\texttt{/}" performs division,
        \item "\texttt{\textasciicircum{}}" and "\texttt{**}" perform exponentiation,
      \end{itemize}
    \column{0.5\textwidth}
      \vspace{-1em}
      <<echo=TRUE,eval=FALSE>>=
?Arithmetic
4.7 * 0.5  # Multiplication
4.7 / 0.5  # division
# Exponentiation
2**3
2^3
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Comparing Objects With \texttt{identical()} and \texttt{all.equal()}}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      The function \texttt{identical()} tests if two objects are exactly the same, and always returns a single logical \texttt{TRUE} or \texttt{FALSE} (never \texttt{NA} or logical \texttt{vectors}).
      \vskip1ex
      For atomic arguments \texttt{identical()} often gives the same result as the \texttt{"=="} operator, but it's not synonymous with it in general.
      \vskip1ex
      The \texttt{"=="} operator applies the \emph{recycling rule} to vector arguments and returns logical \texttt{vectors}, but \texttt{identical()} doesn't and returns a single logical value.
      \vskip1ex
      The function \texttt{all.equal()} tests the equality of two objects to within the square root of the \emph{machine precision}.
      \vskip1ex
      The variable \texttt{.Machine} contains information about the numerical characteristics of the computer \texttt{R} is running on, such as the largest \texttt{double} and \texttt{integer} numbers, and the \emph{machine precision}.
    \column{0.5\textwidth}
      \vspace{-1em}
      <<echo=TRUE,eval=FALSE>>=
numv <- 2
numv==2
identical(numv, 2)

identical(numv, NULL)
# This doesn't work:
# numv==NULL
is.null(numv)

vectorv <- c(2, 4, 6)
vectorv==2
identical(vectorv, 2)

# numv is equal to "1.0" within machine precision
numv <- 1.0 + 2*sqrt(.Machine$double.eps)
all.equal(numv, 1.0)

# Info machine precision of computer R is running on
# ?.Machine
# Machine precision
.Machine$double.eps
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Lookup and Matching Using \texttt{which()} and \texttt{match()}}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      The function \texttt{which()} returns the indices of the \texttt{TRUE} elements of a \texttt{Boolean} \texttt{vector} or \texttt{array}.
      \vskip1ex
      If the argument is an \texttt{array} and \texttt{arr.ind=TRUE}, then \texttt{which()} returns a matrix with rows containing the indices of the \texttt{TRUE} elements.
      \vskip1ex
      The functions \texttt{which.max()} and \texttt{which.min()} return the index of the minimum or maximum of a \texttt{numeric} or \texttt{Boolean} vector.
      \vskip1ex
      \texttt{match()} returns the index of the vector element that \emph{exactly} matches its first argument.
      \vskip1ex
      If it doesn't find an exact match then it returns \texttt{NA}.
      \vskip1ex
      The expressions \texttt{match(x, vec\_tor)} and \texttt{min(which(vec\_tor == x))} produce the same result, but \texttt{match()} can be faster for large vectors.
    \column{0.5\textwidth}
      \vspace{-1em}
      <<echo=TRUE,eval=FALSE>>=
vectorv <- sample(1e3, 1e3)
matrixv <- matrix(vectorv, ncol=4)
which(vectorv == 5)
match(5, vectorv)
# Equivalent but slower than above
(1:NROW(vectorv))[vectorv == 5]
which(vectorv < 5)
# Find indices of TRUE elements of Boolean matrix
which((matrixv == 5)|(matrixv == 6), arr.ind=TRUE)
# Equivalent but slower than above
arrayInd(which((matrixv == 5)|(matrixv == 6)),
         dim(matrixv), dimnames(matrixv))
# Find index of largest element
which.max(vectorv)
which(vectorv == max(vectorv))
# Find index of smallest element
which.min(vectorv)
# Benchmark match() versus which()
all.equal(match(5, vectorv),
          min(which(vectorv == 5)))
library(microbenchmark)
summary(microbenchmark(
  match=match(5, vectorv),
  which=min(which(vectorv == 5)),
  times=10))[, c(1, 4, 5)]  # end microbenchmark summary
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Lookup and Matching Using \texttt{\%in\%} and \texttt{any()}}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      The binary operator \texttt{\%in\%} returns a \texttt{Boolean} \texttt{vector} with \texttt{TRUE} values corresponding to elements that have matches.
      \vskip1ex
      \texttt{\%in\%} is a wrapper for \texttt{match()} defined as follows: 
      \texttt{"\%in\%" <- function(x, table) match(x, table, nomatch=0) > 0}.
      \vskip1ex
      \texttt{\%in\%} never returns \texttt{NA}, so it's preferred in \texttt{if()} statements.
      \vskip1ex
      \texttt{any()} returns \texttt{TRUE} if at least one element of a \texttt{Boolean} vector is \texttt{TRUE}, and \texttt{FALSE} otherwise.
      \vskip1ex
      The function \texttt{pmatch()} performs partial matching of strings.
    \column{0.5\textwidth}
      \vspace{-1em}
      <<echo=TRUE,eval=FALSE>>=
# Does 5 belong in vectorv?
5 %in% vectorv
match(5, vectorv, nomatch=0) > 0
# Does (-5) belong in vectorv?
(-5) %in% vectorv
c(5, -5) %in% vectorv
match(-5, vectorv)
# Equivalent to "5 %in% vectorv"
any(vectorv == 5)
# Equivalent to "(-5) %in% vectorv"
any(vectorv == (-5))
# Any negative values in vectorv?
any(vectorv < 0)
# Example of use in if() statement
if (any(vectorv < 2))
  cat("vector contains small values\n")
# Partial matching of strings
pmatch("med", c("mean", "median", "mode"))
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Finding Closest Match Using \texttt{findInterval()}}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      The function \texttt{match()} returns the index of the vector element that \emph{exactly} matches its first argument.
      \vskip1ex
      If \texttt{match()} doesn't find an exact match then it returns \texttt{NA}.
      \vskip1ex
      The function \texttt{findInterval()} returns the indices of the intervals specified by \texttt{"vec"} that contain the elements of \texttt{"x"}.
      \vskip1ex
      If there's an exact match, then \texttt{findInterval()} returns the same index as function \texttt{match()}.
      \vskip1ex
      If there's no exact match, then \texttt{findInterval()} finds the element of \texttt{"vec"} that is closest to, but not greater than, the element of \texttt{"x"}.
    \column{0.5\textwidth}
      \vspace{-1em}
      <<echo=TRUE,eval=FALSE>>=
str(findInterval)
# Get index of the element of "vec" that matches 5
findInterval(x=5, vec=c(3, 5, 7))
match(5, c(3, 5, 7))
# No exact match
findInterval(x=6, vec=c(3, 5, 7))
match(6, c(3, 5, 7))
# Indices of "vec" that match elements of "x"
findInterval(x=1:8, vec=c(3, 5, 7))
# Return only indices of inside intervals
findInterval(x=1:8, vec=c(3, 5, 7),
             all.inside=TRUE)
# Make rightmost interval inclusive
findInterval(x=1:8, vec=c(3, 5, 7),
             rightmost.closed=TRUE)
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Assignment Operators}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      The standard assignment operator in \texttt{R} is \texttt{"<-"}.
      \vskip1ex
      Both \texttt{"<-"} and \texttt{"="} are valid assignment operators in \texttt{R}.
      \vskip1ex
      The \texttt{"<-"} operator may cause an error if \texttt{R} confuses it with the \texttt{"<"} logical operator.
      \vskip1ex
      But they differ in \emph{scope} and  \emph{precedence} (\texttt{"<-"} has higher precedence than \texttt{"="}).
      \vskip1ex
      The \texttt{"="} operator is used for named arguments in function calls.
      \vskip1ex
      When variables are assigned within an argument list using the \texttt{"="} operator, their \emph{scope} is limited to the function.
      \vskip1ex
      {\color{red}{Rule of Thumb}}:\\
      Use \texttt{"<-"} in \texttt{R} scripts and inside functions,\\
      Use \texttt{"="} only in function calls.
    \column{0.5\textwidth}
      \vspace{-1em}
            <<echo=TRUE,eval=FALSE>>=
numv1 <- 3  # "<-" and "=" are valid assignment operators
numv1
numv1 = 3
numv1
2<-3  # "<" operator confused with "<-"
2 < -3  # Add space or brackets to avoid confusion
# "=" assignment within argument list
median(x=1:10)
x  # x doesn't exist outside the function
# "<-" assignment within argument list
median(x <- 1:10)
x  # x exists outside the function
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{The \texttt{assign()} Function}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      The \texttt{assign()} function assigns a value to an object in a specified \emph{environment}, by referencing it using a character string (name).
      \vskip1ex
      \texttt{assign()} can be used to either assign values to existing variables, or to create new variables.
      \vskip1ex
      \texttt{assign()} looks for the object name in the specified \emph{environment}, and assigns a value to it.
      \vskip1ex
      If \texttt{assign()} can't find the object name, then it creates it.
      \vskip1ex
      \texttt{assign()} expects a character string as its argument.
      \vskip1ex
      If a object name is passsed to \texttt{assign()}, then it evaluates that object to get the string it contains.
      \vskip1ex
      If the object doesn't contain a string, then \texttt{assign()} produces an error.
    \column{0.5\textwidth}
      \vspace{-1em}
            <<echo=TRUE,eval=FALSE>>=
myvar <- 1  # Create new object
assign(x="myvar", value=2)  # Assign value to existing object
myvar
rm(myvar)  # Remove myvar
assign(x="myvar", value=3)  # Create new object from name
myvar
# Create new object in new environment
new_env <- new.env()  # Create new environment
assign("myvar", 3, envir=new_env)  # Assign value to name
ls(new_env)  # List objects in "new_env"
new_env$myvar
rm(list=ls())  # delete all objects
symbol <- "myvar"  # define symbol containing string "myvar"
assign(symbol, 1)  # Assign value to "myvar"
ls()
myvar
assign("symbol", "new_var")
assign(symbol, 1)  # Assign value to "new_var"
ls()
symbol <- 10
assign(symbol, 1)  # Can't assign to non-string
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Applying \texttt{assign()} to Lists of Names}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      \texttt{assign()} allows creating new objects from listv or vectors of names (character strings), such as column names.
      \vskip1ex
    \column{0.5\textwidth}
      \vspace{-1em}
            <<echo=TRUE,eval=FALSE>>=
rm(list=ls())  # delete all objects
# Create individual vectors from column names of EuStockMarkets
for (colname in colnames(EuStockMarkets)) {
# Assign column values to column names
  assign(colname, EuStockMarkets[, colname])
}  # end for
ls()
head(DAX)
head(EuStockMarkets[, "DAX"])
identical(DAX, EuStockMarkets[, "DAX"])
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Retrieving Objects Using \texttt{get()}}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      The function \texttt{get()} accepts a character string and returns the value of the corresponding object in a specified \emph{environment}.
      \vskip1ex
      \texttt{get()} retrieves objects that are referenced using character strings, instead of their names.
      \vskip1ex
      The functions \texttt{get()} and \texttt{assign()} allow retrieving and assigning values to objects that are referenced using character strings.
      \vskip1ex
      The function \texttt{mget()} accepts a vector of strings and returns a list of the corresponding objects.
    \column{0.5\textwidth}
      \vspace{-1em}
            <<echo=TRUE,eval=FALSE>>=
# Create new environment
test_env <- new.env()
# Pass string as name to create new object
assign("myvar1", 2, envir=test_env)
# Create new object using $ string referencing
test_env$myvar2 <- 1
# List objects in new environment
ls(test_env)
# Reference an object by name
test_env$myvar1
# Reference an object by string name using get
get("myvar1", envir=test_env)
# Retrieve and assign value to object
assign("myvar1",
       2*get("myvar1", envir=test_env),
       envir=test_env)
get("myvar1", envir=test_env)
# Return all objects in an environment
mget(ls(test_env), envir=test_env)
# delete environment
rm(test_env)
      @
  \end{columns}
\end{block}

\end{frame}



%%%%%%%%%%%%%%%
\section{Control Structures}


%%%%%%%%%%%%%%%
\subsection{The Parenthesis \texttt{"()"} and Curly Braces \texttt{"\{\}"} Operators}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      The parenthesis \texttt{"()"} and curly braces \texttt{"\{\}"} operators are used to enclose and to group (combine) expressions.
      \vskip1ex
      The parenthesis \texttt{"()"} and curly braces \texttt{"\{\}"} operators are functions, and they return values.
      \vskip1ex
      An expression enclosed by the parenthesis \texttt{"()"} operator is evaluated separatately from other expressions, and its result is returned.
      \vskip1ex
      Enclosing expressions in parenthesis makes them less ambiguous.
      \vskip1ex
      The curly braces \texttt{"\{\}"} operator can group several expressions, that can be written either on separate lines, or be separated by the semicolon \texttt{";"} operator.
      \vskip1ex
      The curly braces \texttt{"\{\}"} operator returns the last expression it encloses.
      \vskip1ex
      Both the parenthesis \texttt{"()"} and curly braces \texttt{"\{\}"} operators are functions, and executing them requires a little additional processing time.
      \vskip1ex
      The square braces (brackets) \texttt{"[]"} operator subsets (references) the elements of vectors, matrices, and listv.
    \column{0.5\textwidth}
      \vspace{-1em}
        <<echo=(-(1:1))>>=
rm(list=ls())
# expressions enclosed in parenthesis are less ambiguous
-2:5
(-2):5
-(2:5)
# expressions enclosed in parenthesis are less ambiguous
-2*3+5
-2*(3+5)

# expressions can be separated by semicolons or by lines
{1+2; 2*3; 1:5}
# or
{1+2
2*3
1:5}

matrixv <- matrix(nr=3, nc=4)
matrixv <- 0
# subset whole matrix
matrixv[] <- 0

# parenthesis and braces require a little additional processing time
library(microbenchmark)
summary(microbenchmark(
  basep=sqrt(rnorm(10000)^2),
  parven=sqrt(((((rnorm(10000)^2))))),
  bra_ce=sqrt({{{{rnorm(10000)^2}}}}),
  times=10))[, c(1, 4, 5)]  # end microbenchmark summary
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{The \texttt{"if () else"} Control Statement}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      \texttt{R} has the familiar \texttt{"if () \{...\} else \{...\}"} statement to control execution flow depending on logical conditions.
      \vskip1ex
      The logical conditions must be either a \texttt{Boolean} or \texttt{numeric} type, otherwise an error is produced.
      \vskip1ex
      The \texttt{"else"} statement can also be omitted.
      \vskip1ex
      \texttt{"if"} statements can be nested using multiple \texttt{"else if"} statements.
    \column{0.5\textwidth}
      \vspace{-1em}
        <<echo=(-(1:1))>>=
rm(list=ls())
numv1 <- 1

if (numv1) {  # numeric zero is FALSE, all other numbers are TRUE
  numv2 <- 4
} else if (numv1 == 0) {  # 'else if' together on same line
  numv2 <- 0
} else {  # 'else' together with curly braces
  numv2 <- -4
}  # end if

numv2
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{The \texttt{switch()} Control Statement}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      The function \texttt{switch()} matches its first argument \texttt{"EXPR"} with one of the symbols in the following arguments, evaluates the corresponding expression, and returns it.
      \vskip1ex
      The arguments that follow the first argument \texttt{"EXPR"} should be given as \emph{symbol=value} pairs.
      \vskip1ex
      If \texttt{"EXPR"} is a character string, then the expression bound to that symbol is returned by \texttt{switch()}.
      \vskip1ex
      If \texttt{"EXPR"} is an integer, then \texttt{switch()} returns the expression from that position.
      \vskip1ex
      If \texttt{switch()} can't match \texttt{"EXPR"} to any symbol, then it returns \texttt{NULL} invisibly.
      \vskip1ex
      Using \texttt{switch()} is a convenient alternative to a cascade of \texttt{"if () else"} statements.
      \vskip1ex
      The function \texttt{match.arg()} matches a string to one of the possible values, and returns the matched value, or produces an \texttt{error} if it can't match it.
    \column{0.5\textwidth}
      \vspace{-1em}
        <<echo=TRUE>>=
switch("a", a="aaahh", b="bee", c="see", d=2,
       "else this")
switch("c", a="aaahh", b="bee", c="see", d=2,
       "else this")
switch(3, a="aaahh", b="bee", c="see", d=2,
       "else this")
switch("cc", a="aaahh", b="bee", c="see", d=2,
       "else this")
# measure of central tendency
centra_lity <- function(input,
            method=c("mean", "mean_narm", "median")) {
# validate "method" argument
  method <- match.arg(method)
  switch(method,
         mean=mean(input),
         mean_narm=mean(input, na.rm=TRUE),
         median=median(input))
}  # end centra_lity
myvar <- rnorm(100, mean=2)
centra_lity(myvar, "mean")
centra_lity(myvar, "mean_narm")
centra_lity(myvar, "median")
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Iteration Using \texttt{for()} and \texttt{while()} Loops}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      The \texttt{for()} loop statement:
      \vspace{-1em}
      <<echo=TRUE,eval=FALSE>>=
for (indeks in vectorv) {ex_pressions}
@
      \vspace{-1em}
      iterates the \emph{dummy} variable \texttt{in\_dex} over the elements of the vector or list \texttt{vec\_tor}, and evaluates in a loop the \texttt{ex\_pressions} contained in the body of the \texttt{for()} loop.
      \vskip1ex
      Upon loop exit the \emph{dummy} variable \texttt{in\_dex} is left equal to the last element of the vector \texttt{vec\_tor}.
      \vskip1ex
      \texttt{while()} loops start by testing their logical condition, and they repeat executing the loop body until that condition is \texttt{FALSE}.
      \vskip1ex
      But \texttt{while()} loops risk producing infinite loops if not written
properly, so \alert{Use Them With Care!}
    \column{0.5\textwidth}
      \vspace{-1em}
        <<echo=(-(1:1))>>=
rm(list=ls())
color_list <- list("red", "white", "blue")
# loop over list
for (some_color in color_list) {
  print(some_color)
}  # end for
# loop over vector
for (indeks in 1:3) {
  print(color_list[[indeks]])
}  # end for

# while loops require initialization
indeks <- 1
# while loop
while (indeks < 4) {
  print(color_list[[indeks]])
  indeks <- indeks + 1
}  # end while
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Performing Loops Using \texttt{for()} and \texttt{apply()}}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      The \texttt{for()} loop doesn't return a value, so values calculated in the \texttt{for()} loop body must be assigned to variables in the parent environment, or otherwise they are lost.
      \vskip1ex
      The expressions in the \texttt{for()} loop body have access to variables in the parent environment in which the \texttt{for()} loop is executed, and they can modify those variables.
      \vskip1ex
      So even though \texttt{for()} loops don't return a value, they can be used to perform calculations on variables in the parent environment, but this is discouraged since it can produce errors that are hard to debug.
      \vskip1ex
      {\color{red}{Rule of Thumb:}}\\
      \begin{itemize}
        \item \texttt{for()} loops are preferred for producing \emph{side effects}, like plotting or reading and writing data to files,
        \item \texttt{apply()} loops are preferred for performing calculations which produce vectors or matrices of values,
      \end{itemize}
    \column{0.5\textwidth}
      \vspace{-1em}
        <<echo=(-(1:1))>>=
rm(list=ls())
# loop over a vector and overwrite it
vectorv <- integer(7)
for (i in 1:7) {
  cat("Changing element:", i, "\n")
  vectorv[i] <- i^2
}  # end for
# equivalent way (without cat side effect)
for (i in seq_along(vectorv)) 
  vectorv[i] <- i^2

# sapply() loop returns vector of values
vectorv <- sapply(seq_along(vectorv), 
                  function(x) (x^2))
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Fibonacci Sequence Using \texttt{for()} Loop}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      The \emph{Fibonacci} sequence of integers is defined by the recurrence relation:
      \begin{displaymath}
        F_n = F_{n-1} + F_{n-2},
      \end{displaymath}
      \begin{displaymath}
        F1 = 0, F2 = 1,
      \end{displaymath}
      \begin{displaymath}
        F_n = 0, 1, 1, 2, 3, 5, 8, 13, \ldots
      \end{displaymath}
      The \emph{Fibonacci} sequence was invented by the \emph{Indian} mathematician Virahanka in the 8th century AD, and later described by the Italian mathematician \emph{Fibonacci} in his famous treatise \emph{Liber Abaci}.
      \vskip1ex
      Very often variables are initialized to \texttt{NULL} before the start of iteration.
      \vskip1ex
      A more efficicent way to perform iteration is by pre-allocating the vector.
      \vskip1ex
      The function \texttt{numeric()} returns an zero length \texttt{numeric} vector.
      \vskip1ex
      The function \texttt{numeric(k)} returns a \texttt{numeric} vector of zeros of length \texttt{k}.
    \column{0.5\textwidth}
      \vspace{-1em}
        <<echo=(-(1:1))>>=
rm(list=ls())
# fib_seq <- numeric()  # zero length numeric vector
# pre-allocate vector instead of "growing" it
fib_seq <- numeric(10)
fib_seq[1] <- 0  # initialize
fib_seq[2] <- 1  # initialize
for (i in 3:10) {  # perform recurrence loop
  fib_seq[i] <- fib_seq[i-1] + fib_seq[i-2]
}  # end for
fib_seq
      @
  \end{columns}
\end{block}

\end{frame}




%%%%%%%%%%%%%%%
\section{Manipulating Vectors and Matrices}


%%%%%%%%%%%%%%%
\subsection{Allocating Memory to Vectors and Matrices}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      \texttt{R} automatically allocates memory to new objects as needed during runtime, but at the cost of slowing down calculations.
      \vskip1ex
      Allocating memory of the correct \emph{mode} speeds up calculations by avoiding automatic memory allocation by \texttt{R}.
      \vskip1ex
      The functions \texttt{character()}, \texttt{integer()}, and \texttt{numeric()} return zero-length vectors of the specified \emph{mode}.
      \vskip1ex
      Zero length vectors are not the same as \texttt{NULL} objects.
      \vskip1ex
      The function \texttt{character(k)} returns a \texttt{character} vector of empty strings of length \texttt{k}.
      \vskip1ex
      The function \texttt{integer(k)} returns a \texttt{integer} vector of zeros of length \texttt{k}.
      \vskip1ex
      The function \texttt{numeric(k)} returns a \texttt{numeric} vector of zeros of length \texttt{k}.
      \vskip1ex
      The function \texttt{vector()} by default returns a \texttt{Boolean} vector, unless the \emph{mode} is specified.
      \vskip1ex
      The function \texttt{matrix()} by default returns a \texttt{Boolean} matrix containing \texttt{NA} values, unless the \emph{mode} is specified.
    \column{0.5\textwidth}
      \vspace{-1em}
        <<echo=TRUE>>=
# Allocate character vector
character()
character(5)
is.character(character(5))
# Allocate integer vector
integer()
integer(5)
is.integer(integer(5))
is.numeric(integer(5))
# Allocate numeric vector
numeric()
numeric(5)
is.integer(numeric(5))
is.numeric(numeric(5))
# Allocate Boolean vector
vector()
vector(length=5)
# Allocate numeric vector
vector(length=5, mode="numeric")
is.null(vector())
# Allocate Boolean matrix
matrix()
is.null(matrix())
# Allocate integer matrix
matrix(NA_integer_, nrow=3, ncol=2)
is.integer(matrix(NA_integer_, nrow=3, ncol=2))
# Allocate numeric matrix
matrix(NA_real_, nrow=3, ncol=2)
is.numeric(matrix(NA_real_, nrow=3, ncol=2))
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Logical Operators Applied to Vectors and Matrices}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      When logical operators are applied to vectors and matrices, they are applied element-wise, producing \texttt{Boolean} vectors and matrices.
    \column{0.5\textwidth}
      \vspace{-1em}
        <<echo=TRUE>>=
vectorv <- sample(1:9)
vectorv
vectorv < 5  # Element-wise comparison
vectorv == 5  # Element-wise comparison
matrixv <- matrix(vectorv, ncol=3)
matrixv
matrixv < 5  # Element-wise comparison
matrixv == 5  # Element-wise comparison
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Coercing Vectors Into Matrices}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      Vectors can be coerced into matrices by adding a dimension attribute.
      \vskip1ex
      The \texttt{dimnames} attribute can be assigned a named list to convert it into a named matrix.
      \vskip1ex
      The function \texttt{structure()} adds attributes (specified as \texttt{symbol=value} pairs) to an object, and returns it.
    \column{0.5\textwidth}
      \vspace{-1em}
            <<echo=TRUE,eval=FALSE>>=
matrixv <- 1:6  # Create a vector
class(matrixv)  # Get its class
# Is it vector or matrix?
c(is.vector(matrixv), is.matrix(matrixv))
structure(matrixv, dim=c(2, 3))  # Matrix object
# Adding dimension attribute coerces into matrix
dim(matrixv) <- c(2, 3)
class(matrixv)  # Get its class
# Is it vector or matrix?
c(is.vector(matrixv), is.matrix(matrixv))
# Assign dimnames attribute
dimnames(matrixv) <- list(rows=c("row1", "row2"),
                        columns=c("col1", "col2", "col3"))
matrixv
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Coercing Matrices Into Other Types}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      Matrices can be explicitly coerced using the \texttt{"as.*"} coercion functions.
      \vskip1ex
      But coercion functions strip the \emph{attributes} from an object.
    \column{0.5\textwidth}
      \vspace{-1em}
            <<echo=TRUE,eval=FALSE>>=
matrixv <- matrix(1:10, 2, 5)  # Create matrix
matrixv
# as.numeric strips dim attribute from matrix
as.numeric(matrixv)
# Explicitly coerce to "character"
matrixv <- as.character(matrixv)
c(typeof(matrixv), mode(matrixv), class(matrixv))
# Coercion converted matrix to vector
c(is.matrix(matrixv), is.vector(matrixv))
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Binding Vectors and Matrices Together}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      Vectors can be bound into matrices using the functions \texttt{cbind()} and \texttt{rbind()}.
      \vskip1ex
      The \emph{recycling rule} allows operations on vectors of different lengths:\\
      \begin{enumerate}
        \item Vectors are scanned from left to right,
        \item Shorter vectors are extended in length by recycling their values until they match the length of longer vectors,
      \end{enumerate}
    \column{0.5\textwidth}
      \vspace{-1em}
            <<echo=TRUE,eval=FALSE>>=
vector1 <- 1:3  # Define vector
vector2 <- 6:4  # Define vector
# Bind vectors into columns
cbind(vector1, vector2)
# Bind vectors into rows
rbind(vector1, vector2)
# Extend to four elements
vector2 <- c(vector2, 7)
# Recycling rule applied
cbind(vector1, vector2)
# Another example of recycling rule
1:6 + c(10, 20)
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Replicating Objects Using \texttt{rep()}}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      The function \texttt{rep()} replicates vectors and listv a given number of times.
      \vskip1ex
      \texttt{rep()} accepts a vector or list \texttt{"x"}, and an integer specifying the type and number of replications.
      \vskip1ex
      Argument \texttt{"times"} replicates the whole vector a given number of times.
      \vskip1ex
      Argument \texttt{"each"} replicates each vector element a given number of times.
      \vskip1ex
      Argument \texttt{"length.out"} replicates the whole vector a certain number of times, so that the output vector length is equal to \texttt{"length.out"}.
    \column{0.5\textwidth}
      \vspace{-1em}
            <<echo=TRUE,eval=FALSE>>=
# Replicate a single element
rep("a", 5)
# Replicate the whole vector several times
rep(c("a", "b"), 5)
rep(c("a", "b"), times=5)
# Replicate the first element, then the second, etc.
rep(c("a", "b"), each=5)
# Replicate to specified length
rep(c("a", "b"), length.out=5)
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Multiplying Vectors and Matrices}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      The multiplication \texttt{"*"} \emph{operator} performs \emph{element-wise} (\emph{element-by-element}) multiplication of vectors and matrices.
      \vskip1ex
      By default the matrix elements are multiplied column-wise by the vector elements: the first matrix element in the first column is multiplied by the first vector element, then the second matrix column is multiplied by the remaining vector elements, etc.
      \vskip1ex
      The \emph{recycling rule} is applied to the vector elements as needed.
      \vskip1ex
      The transpose function \texttt{t()} can be applied if we want to perform row-wise multiplication.
      \vskip1ex
      But the transpose function \texttt{t()} is very slow for large matrices.
      \vskip1ex
      A better choice is to use functions \texttt{lapply()} and \texttt{do.call()}.
     \column{0.5\textwidth}
      \vspace{-1em}
      <<echo=TRUE>>=
# Define vector and matrix
vector1 <- c(2, 4, 3)
matrixv <- matrix(sample(1:12), ncol=3)
# Multiply columns of matrix by vector
vector1*matrixv
# Or
matrixv*vector1
# Multiply rows of matrix by vector
t(vector1*t(matrixv))
# Multiply rows of matrix by vector - transpose is very slow
product <- lapply(1:NCOL(matrixv), 
  function(x) vector1[x]*matrixv[, x])
do.call(cbind, product)
library(microbenchmark)
summary(microbenchmark(
  trans=t(vector1*t(matrixv)),
  lapp={
    product <- lapply(1:NCOL(matrixv), function(x) vector1[x]*matrixv[, x])
    do.call(cbind, product)
  },
  times=10))[, c(1, 4, 5)]  # end microbenchmark summary
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Matrix Inner Multiplication}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      The \texttt{\%*\%} operator performs \emph{inner} (\emph{scalar}) multiplication of vectors and matrices.
      \vskip1ex
      \emph{Inner} multiplication multiplies the rows of one matrix with the columns of another matrix, so that each pair produces a single number:
      \begin{displaymath}
        C_{i,j} = \sum_{k=1}^n A_{i,k} B_{k,j}
      \end{displaymath}
      \emph{Inner} multiplication produces a vector or matrix with a reduced dimension.
      \vskip1ex
      \emph{Inner} multiplication requires the dimensions of the matrices to be \emph{conformable} (number of columns in the first matrix must be equal to the number of rows in the second).
      \vskip1ex
      The function \texttt{drop()} removes any dimensions of length \emph{one}.
      \vskip1ex
      The functions \texttt{rowSums()} and \texttt{colSums()} calculate the sums of rows and columns, and they're very fast because they pass their data to compiled \texttt{C++} code.
    \column{0.5\textwidth}
      \vspace{-1em}
      <<echo=(-(1:1))>>=
vector1
vector2 <- 6:4  # Define vector
# Multiply two vectors element-by-element
vector1 * vector2
# Calculate inner product
vector1 %*% vector2
# Calculate inner product and drop dimensions
drop(vector1 %*% vector2)
# Multiply columns of matrix by vector
matrixv %*% vector1  # Single column matrix
drop(matrixv %*% vector1)  # vector
rowSums(t(vector1 * t(matrixv)))
# using rowSums() and t() is 10 times slower than %*%
library(microbenchmark)
summary(microbenchmark(
  inner=drop(matrixv %*% vector1),
  transp=rowSums(t(vector1 * t(matrixv))),
  times=10))[, c(1, 4, 5)]  # end microbenchmark summary
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Matrix Transpose}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      The function \texttt{t()} returns the transpose of a matrix.
      \vskip1ex
      The function \texttt{crossprod()} also performs \emph{inner} (\emph{scalar}) multiplication, exactly the same as the \texttt{\%*\%} operator, but is slightly faster.
    \column{0.5\textwidth}
      \vspace{-1em}
      <<echo=(-(1:1)),eval=FALSE>>=
library(microbenchmark)
# Multiply matrix by vector fails because dimensions aren't conformable
vector1 %*% matrixv
# Works after transpose
drop(vector1 %*% t(matrixv))
# Calculate inner product
crossprod(vector1, vector2)
# Create matrix and vector
matrixv <- matrix(1:3000, ncol=3)
tmatrixv <- t(matrixv)
vectorv <- 1:3
# crossprod() is slightly faster than "%*%" operator
summary(microbenchmark(
  cross_prod=crossprod(tmatrixv, vectorv),
  inner_prod=matrixv %*% vectorv,
  times=10))[, c(1, 4, 5)]  # end microbenchmark summary
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Matrix Outer Multiplication}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      An \emph{outer} product consists of all possible products of pairs of elements of two objects:
      \begin{displaymath}
        C_{i,j} = A_i \cdot B_j
      \end{displaymath}
      An \emph{outer} product of a function consists of applying it to all possible pairs of elements of two objects:
      \begin{displaymath}
        C_{i,j} = f(A_i, B_j)
      \end{displaymath}
      \emph{Outer} multiplication produces an object with dimension equal to the sum of the factors' dimensions, and with the number of elements equal to the product of the factors' elements.
      \vskip1ex
      The function \texttt{outer()} calculates the \emph{outer} product of two matrices, and by default multiplies the elements of its arguments.
      \vskip1ex
      \texttt{outer()} can also calculate the values of a vectorized function of two variables passed to the \texttt{"FUN"} argument.
    \column{0.5\textwidth}
      \vspace{-1em}
      <<echo=TRUE>>=
# Define named vectors
vector1 <- sample(1:4)
names(vector1) <- paste0("row", 1:4, "=", vector1)
vector1
vector2 <- sample(1:3)
names(vector2) <- paste0("col", 1:3, "=", vector2)
vector2
# Calculate outer product of two vectors
matrixv <- outer(vector1, vector2)
matrixv
# Calculate vectorized function spanned over two vectors
matrixv <- outer(vector1, vector2,
                 FUN=function(x1, x2) x2*sin(x1))
matrixv
      @
  \end{columns}
\end{block}

\end{frame}




%%%%%%%%%%%%%%%
\section{Functions}


%%%%%%%%%%%%%%%
\subsection{\secname \hskip0.4em in \texttt{R}}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      \texttt{R} functions have three components:
      \begin{itemize}
        \item a list of formal arguments,
        \item a body containing \texttt{R} code,
        \item an environment,
      \end{itemize}
      An \texttt{R} function plus its environment is referred to as a function \emph{closures}.
      \vskip1ex
      The function body should be enclosed in curly braces \texttt{\{\}}, unless it contains a single command, then it doesn't have to enclosed.
      \vskip1ex
      The function body doesn't require a \texttt{return} statement, since by default \texttt{R} functions return the last statement evaluated in the body.
      \vskip1ex
      \texttt{args()} displays the formal arguments of a function.
    \column{0.5\textwidth}
      \vspace{-1em}
        <<echo=TRUE,eval=FALSE>>=
# Define a function with two arguments
testfun <- function(first_arg, second_arg) {  # Body
  first_arg + second_arg  # Returns last evaluated statement
}  # end testfun

testfun(1, 2)  # Apply the function
args(testfun)  # Display argument

# Define function that uses variable from enclosure environment
testfun <- function(first_arg, second_arg) {
  first_arg + second_arg + globv
}  # end testfun

testfun(3, 2)  # error - globv doesn't exist yet!
globv <- 10  # Create globv
testfun(3, 2)  # Now works
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Return Values of \secname}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      The function body doesn't require a \texttt{return} statement, since by default \texttt{R} functions return the last statement evaluated in the body.
      \vskip1ex
      \texttt{return()} statements are inserted in logical branches to terminate function execution and return its intended value.
    \column{0.5\textwidth}
      \vspace{-1em}
        <<echo=TRUE,eval=FALSE>>=
# Define function that returns NULL for non-numeric argument
testfun <- function(input) {
  if (!is.numeric(input)) {
    warning(paste("argument", input, "isn't numeric"))
    return(NULL)
  }
  2*input
}  # end testfun

testfun(2)
testfun("hello")
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{\secname \hskip0.4em That Return \texttt{invisible}}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      If a return value is wrapped in the function \texttt{invisible()} then the return value isn't printed.
      \vskip1ex
      But if the function is assigned to a variable, then its return value is assigned to that variable.
      \vskip1ex
      \texttt{invisible()} allows creating functions whose return values can be assigned, but which do not print when they're not assigned.
      \vskip1ex
      The function \texttt{load()} reads data from \texttt{.RData} files, and \emph{invisibly} returns a vector of names of objects created in the workspace.
    \column{0.5\textwidth}
      \vspace{-1em}
        <<echo=TRUE,eval=FALSE>>=
# Define a function that returns invisibly
return_invisible <- function(input) {
  invisible(input)
}  # end return_invisible

return_invisible(2)

globv <- return_invisible(2)
globv

rm(list=ls())  # Remove all objects
# Load objects from file
loaded <- load(file="/Users/jerzy/Develop/data/my_data.RData")
loaded  # Vector of loaded objects
ls()  # List objects
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Binding Function Arguments}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      The formal arguments of a function are defined in its argument list.
      \vskip1ex
      When a function is called, it's passed a list of actual function arguments.
      \vskip1ex
      Formal arguments can be \emph{bound} to actual arguments either by name or by position:
      \begin{itemize}
        \item by name: formal arguments are \emph{bound} to actual arguments with the same name,
        \item by position: the first formal argument is \emph{bound} to the first actual argument, etc.
      \end{itemize}
      \emph{Binding} by name takes precedence over \emph{binding} by position: first all the named arguments are \emph{bound}, then the remaining arguments are \emph{bound} by position.
      \vskip1ex
      Partial argument names are \emph{bound} to full names.
    \column{0.5\textwidth}
      \vspace{-1em}
        <<echo=TRUE,eval=FALSE>>=
testfun <- function(first_arg, second_arg) {
# Last statement of function is return value
  first_arg + 2*second_arg
}  # end testfun
testfun(first_arg=3, second_arg=2)  # Bind by name
testfun(first=3, second=2)  # Partial name binding
testfun(3, 2)  # Bind by position
testfun(second_arg=2, 3)  # mixed binding
testfun(3, 2, 1)  # Too many arguments
testfun(2)  # Not enough arguments
      @
      \vspace{-1em}
      All the actual arguments must be \emph{bound} to formal arguments, and if not then an \texttt{"unused argument"} error is produced.
      \vskip1ex
      If there aren't enough formal arguments, then an \texttt{"argument is missing"} error is produced,
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Default Values for Arguments}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      Formal arguments may be assigned default values, so that when the actual arguments are missing then their default values are used instead.
      \vskip1ex
      Default values are often assigned to function parameters, that determine the function's behavior.
      \vskip1ex
      Default values can be specified as a vector of strings, representing the possible values of a function's parameter.
      \vskip1ex
      The function \texttt{match.arg()} matches a string to one of the possible values, and returns the matched value, or produces an \texttt{error} if it can't match it.
      \vskip1ex
      The function \texttt{str()} displays the structure of an \texttt{R} object, for example a function name and its formal arguments.
    \column{0.5\textwidth}
      \vspace{-1em}
        <<echo=TRUE,eval=FALSE>>=
# Function "paste" has two arguments with default values
str(paste)
# Default values of arguments can be specified in argument list
testfun <- function(first_arg, ratio=1) {
  ratio*first_arg
}  # end testfun
testfun(3)  # Default value used for second argument
testfun(3, 2)  # Default value over-ridden
# Default values can be a vector of strings
testfun <- function(input=c("first_val", "second_val")) {
  input <- match.arg(input)  # Match to arg list
  input
}  # end testfun
testfun("second_val")
testfun("se")  # Partial name binding
testfun("some_val")  # Invalid string
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Function for Calculating Skew}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      \texttt{R} provides an easy way for users to write functions.
      \vskip1ex
      Formal function arguments can be bound to input variables by position or by name.
      \vskip1ex
      If the function arguments are missing then their default value is used.
      \vskip1ex
      Functions return the value of the last expression that is evaluated.
      \vskip1ex
      \texttt{datasets} is a \texttt{base} package containing various datasets, for example: \texttt{EuStockMarkets}.
      \vskip1ex
      The \texttt{EuStockMarkets} dataset contains daily closing prices of european stock indices.
    \column{0.5\textwidth}
      \vspace{-1em}
        <<echo=TRUE,eval=FALSE>>=
# DAX percentage returns
returns <- rutils::diffit(log(EuStockMarkets[, 1]))
# calc_skew() calculates skew of time series of returns
# Default is normal time series
calc_skew <- function(returns=rnorm(1000)) {
  # Number of observations
  nrows <- NROW(returns)
  # Standardize returns
  returns <- (returns - mean(returns))/sd(returns)
  # Calculate skew - last statement automatically returned
  nrows*sum(returns^3)/((nrows-1)*(nrows-2))
}  # end calc_skew

# Calculate skew of DAX returns
# Bind arguments by name
calc_skew(returns=returns)
# Bind arguments by position
calc_skew(returns)
# Use default value of arguments
calc_skew()
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{The dots \texttt{"..."} Function Argument}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      The dots \texttt{"..."} function argument is a formal argument without a name, as opposed to the other formal arguments which all have names.
      \vskip1ex
      The dots \texttt{"..."} bind with any number of additional arguments, that aren't already bound by name or position to the named arguments.
      \vskip1ex
      The dots \texttt{"..."} are used when the number of arguments isn't known in advance, and allows functions to accept an indefinite number of arguments.
      \vskip1ex
      The dots \texttt{"..."} are sometimes placed \emph{after} the named arguments, to allow passing of additional parameters into a function.
      \vskip1ex
      \emph{Functionals} often place the dots \texttt{"..."} argument \emph{after} the named arguments, to allow passing the dots \texttt{"..."} to the function being called by the \emph{functional}.
    \column{0.5\textwidth}
      \vspace{-1em}
        <<echo=TRUE>>=
str(plot)  # Dots for additional plot parameters
bind_dots <- function(input, ...) {
  paste0("input=", input,
         ", dots=", paste(..., sep=", "))
}  # end bind_dots
bind_dots(1, 2, 3)  # "input" bound by position
bind_dots(2, input=1, 3)  # "input" bound by name
bind_dots(1, 2, 3, foo=10)  # Named argument bound to dots
bind_dots <- function(arg1, arg2, ...) {
  arg1 + 2*arg2 + sum(...)
}  # end bind_dots
bind_dots(3, 2)  # Bind arguments by position
bind_dots(3, 2, 5, 8)  # Extra arguments bound to dots
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Argument Binding With dots \texttt{"..."} Argument}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      The dots \texttt{"..."} argument is sometimes placed \emph{before} the named arguments, so that a function can accept an indefinite number of arguments, without binding them by position with the named arguments.
      \vskip1ex
      When the dots \texttt{"..."} are placed \emph{before} the named arguments, the named arguments are often assigned default values, so they don't have to be bound to a value in the call.
      \vskip1ex
      Arguments that appear after the dots \texttt{"..."} must be \emph{bound} by their full name, and can't be partially \emph{bound}.
    \column{0.5\textwidth}
      \vspace{-1em}
        <<echo=TRUE>>=
str(sum)  # Dots before other arguments
sum(1, 2, 3)  # Dots bind before other arguments
sum(1, 2, NA, 3, na.rm=TRUE)
bind_dots <- function(..., input) {
  paste0("input=", input,
         ", dots=", paste(..., sep=", "))
}  # end bind_dots
# Arguments after dots must be bound by full name
bind_dots(1, 2, 3, input=10)
bind_dots(1, 2, 3, input=10, foo=4)  # Dots bound
bind_dots(1, 2, 3)  # "input" not bound
bind_dots <- function(..., input=10) {
  paste0("input=", input,
         ", dots=", paste(..., sep=", "))
}  # end bind_dots
bind_dots(1, 2, 3)  # "input" not bound, but has default
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Wrapper \secname \hskip0.4em With dots \texttt{"..."} Argument}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      \emph{Wrapper} functions provide a convenient user interface to functions, by assigning default argument values, validating data, and formatting the output.
      \vskip1ex
      \emph{Wrapper} functions are designed to perform the actions of other functions, while reducing their complexity.
      \vskip1ex
      The dots \texttt{"..."} argument of the \emph{wrapper} function allows passing additional arguments on to the wrapped function.
      \vskip1ex
      \emph{Wrapper} functions should be used with caution, since wrapping a function creates extra code (overhead), which slows down \texttt{R}.
    \column{0.5\textwidth}
      \vspace{-1em}
        <<echo=TRUE,eval=FALSE>>=
# Wrapper for mean() with default na.rm=TRUE
my_mean <- function(x, na.rm=TRUE, ...) {
  mean(x=x, na.rm=na.rm, ...)
}  # end my_mean
foo <- sample(c(1:10, NA, rep(0.1, t=5)))
mean(c(foo, NA))
mean(c(foo, NA), na.rm=TRUE)
my_mean(c(foo, NA))
my_mean(c(foo, NA), trim=0.4)  # Pass extra argument
# Wrapper for saving data into default directory
save_data <- function(...,
                      file=stop("error: no file name"),
                      my_dir="/Users/jerzy/Develop/data") {
# Create file path
  file <- file.path(my_dir, file)
  save(..., file=file)
}  # end save_data
foo <- 1:10
save_data(foo, file="scratch.RData")
save_data(foo, file="scratch.RData", my_dir="/Users/jerzy/Develop")
# Wrapper for testing negative arguments
stop_if_neg <- function(input) {
  if (!is.numeric(input) || input<0)
    stop("argument not numeric or negative")
}  # end stop_if_neg
# Wrapper for sqrt()
my_sqrt <- function(input) {
  stop_if_neg(input)
  sqrt(input)
}  # end my_sqrt
my_sqrt(2)
my_sqrt(-2)
my_sqrt(NA)
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Recursive \secname \hskip0.4em with dots \texttt{"..."} Argument}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      \emph{Recursive} functions can also accept the dots \texttt{"..."} argument.
      \vskip1ex
      The dots \texttt{"..."} argument can be referenced inside a function by first converting it into a list using \texttt{"list(...)"}.
      \vskip1ex
      The function \texttt{missing()} returns \texttt{TRUE} if an argument is missing, and \texttt{FALSE} otherwise.
    \column{0.5\textwidth}
      \vspace{-1em}
        <<echo=TRUE,eval=FALSE>>=
# Recursive function sums its argument list
sum_dots <- function(input, ...) {
  if (missing(...)) {  # Check if dots are empty
    return(input)  # just one argument left
  } else {
    input + sum_dots(...)  # Sum remaining arguments
  }  # end if
}  # end sum_dots
sum_dots(1, 2, 3, 4)
# Recursive function sums its argument list
sum_dots <- function(input, ...) {
  if (NROW(list(...)) == 0) {  # Check if dots are empty
    return(input)  # just one argument left
  } else {
    input + sum_dots(...)  # Sum remaining arguments
  }  # end if
}  # end sum_dots
sum_dots(1, 2, 3, 4)
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Recursive Function for Calculating Fibonacci Sequence}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      \emph{Recursive} functions call themselves in their own body.
      \vskip1ex
      The \emph{Fibonacci} sequence of integers is defined by the recurrence relation:
      \begin{displaymath}
        F_n = F_{n-1} + F_{n-2},
      \end{displaymath}
      \begin{displaymath}
        F1 = 0, F2 = 1,
      \end{displaymath}
      \begin{displaymath}
        F_n = 0, 1, 1, 2, 3, 5, 8, 13, \ldots
      \end{displaymath}
      The \emph{Fibonacci} sequence was invented by \emph{Indian} mathematicians, and later described by the Italian mathematician \emph{Fibonacci} in his famous treatise \emph{Liber Abaci}.
    \column{0.5\textwidth}
      \vspace{-1em}
        <<echo=TRUE>>=
fibonacci <- function(nrows) {
  if (nrows > 2) {
    fib_seq <- fibonacci(nrows-1)  # Recursion
    c(fib_seq, sum(tail(fib_seq, 2)))  # Return this
  } else {
    c(0, 1)  # Initialize and return
  }
}  # end fibonacci
fibonacci(10)
tail(fibonacci(9), 2)
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Exploring Functions}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      If a function name is called alone without arguments, then \texttt{R} displays the function code (but it must be on the search path).
      \vskip1ex
      Non-visible objects can't be viewed by calling their name.
      \vskip1ex
      The function \texttt{getAnywhere()} displays information about \texttt{R} objects, including non-visible objects.
      \vskip1ex
      The function \texttt{getAnywhere()} also displays \texttt{R} objects that aren't on the search path.
    \column{0.5\textwidth}
      \vspace{-1em}
      <<echo=TRUE,eval=FALSE>>=
# Show the function code
plot.default
# Display function
getAnywhere(plot.default)
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Function Environments}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      When a function is called, a new \emph{evaluation} environment is created.
      \vskip1ex
      The \emph{evaluation} environment contains the function arguments and locally defined variables.
      \vskip1ex
      \texttt{R} evaluates variables inside functions by searching first in the \emph{evaluation} environment, then the \emph{enclosure} environment, then the \texttt{R} search path.
      \vskip1ex
      The enclosure of the \emph{evaluation} environment is the environment where the function was defined.
      \vskip1ex
      The enclosure of functions defined in the workspace is the \emph{global} environment.
      \vskip1ex
      The enclosure of functions defined in packages is the package \emph{namespace}.
      \vskip1ex
      Objects defined in the function enclosure can be referenced inside the function.
    \column{0.5\textwidth}
      \vspace{-1em}
        <<echo=(-1)>>=
rm(list=ls())
globv <- 1  # Define a global variable
ls(environment())  # Get all variables in environment
func_env <- function() {  # Explore function environments
  locvar <- 1  # Define a local variable
  cat('objects in evaluation environment:\t',
      ls(environment()), '\n')
  cat('objects in enclosing environment:\t',
      ls(parent.env(environment())), '\n')
  cat('this is the enclosing environment:')
  parent.env(environment())  # Return enclosing environment
}  # end func_env
func_env()

environment(func_env)
environment(print)  # Package namespace is the enclosure
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Side effects Using the Super-assignment Operator \texttt{"<<-"}}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      Function \emph{side effects} are operations on objects outside a function's \emph{evaluation} environment.
      \vskip1ex
      The functions \texttt{plot()} and \texttt{load()} are examples of functions that produce \emph{side effects}.
      \vskip1ex
      \texttt{load()} reads data from an \texttt{.RData} file, and creates objects in the workspace that are contained in the \texttt{.RData} file.
      \vskip1ex
      The super-assignment operator \texttt{"<<-"} allows creating functions that produce \emph{side effects}.
      \vskip1ex
      The super-assignment operator \texttt{"<<-"} modifies or creates variables in the \emph{enclosing} environment in which a function was \emph{defined} (\emph{lexical} scoping).
      \vskip1ex
      If a function was \emph{defined} in the \emph{global} environment then that's the function's \emph{enclosing} environment, and the \texttt{"<<-"} operator operates on variables in the \emph{global} environment.
    \column{0.5\textwidth}
      \vspace{-1em}
        <<echo=(-(1:1))>>=
setwd("/Users/jerzy/Develop/lecture_slides/data")
rm(list=ls())  # Remove all objects
ls()  # List objects
# Load objects from file (side effect)
load(file="my_data.RData")
ls()  # List objects
globv <- 1  # Define a global variable
# Explore function scope and side effects
side_effect <- function() {
  cat("global globv =", globv, "\n")
# Define local "globv" variable
  globv <- 10
  cat("local globv =", globv, "\n")
  # Re-define the global "globv"
  globv <<- 2
  cat("local globv =", globv, "\n")
}  # end side_effect
side_effect()
# Global variable was modified as side effect
globv
      @
  \end{columns}
\end{block}

\end{frame}



%%%%%%%%%%%%%%%
\section{Functionals}


%%%%%%%%%%%%%%%
\subsection{Functions as First Class Objects}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      Functions in \texttt{R} are \emph{first class objects}, which means they can be treated like any other \texttt{R} object:
      \begin{itemize}
        \item Functions can be passed as arguments to other functions,
        \item Functions can be nested (defined inside other functions),
        \item Functions can return functions as their return value,
      \end{itemize}
      \emph{Higher order} functions are \texttt{R} functions that either accept a function as their argument (input) or return a function as their value (output).
    \column{0.5\textwidth}
      \vspace{-1em}
        <<echo=TRUE,eval=FALSE>>=
# Create functional that accepts a function as input argument
testfun <- function(func_name) {
# Calculates statistic on random numbers
  set.seed(1)
  func_name(runif(1e4))  # Apply the function name
}  # end testfun
testfun(mean)
testfun(sd)
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Functionals}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      \emph{Functionals} are functions that accept a function or a function name (string) as one of their input arguments.
      \vskip1ex
      \emph{Functionals} are able to execute function calls using the function names.
      \vskip1ex
      The function \texttt{match.fun()} returns a function name that is specified by a string.
      \vskip1ex
      \emph{Functionals} that call \texttt{match.fun()} are able to accept a string as a function name, because \texttt{match.fun()} converts it to a function.
      \vskip1ex
      \texttt{match.fun()} produces an error condition if it fails to find a function with the specified name.
    \column{0.5\textwidth}
      \vspace{-1em}
        <<echo=TRUE,eval=FALSE>>=
# Functional accepts function name and additional argument
testfun <- function(func_name, input) {
# Produce function name from argument
  func_name <- match.fun(func_name)
# Execute function call
  func_name(input)
}  # end testfun
testfun(sqrt, 4)
# String also works because match.fun() converts it to a function
testfun("sqrt", 4)
str(sum)  # Sum() accepts multiple arguments
# Functional can't accept indefinite number of arguments
testfun(sum, 1, 2, 3)
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Functionals with dots \texttt{"..."} Argument}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      The dots \texttt{"..."} argument in \emph{functionals} can be used to pass additional arguments to the function being called by the \emph{functional}.
      \vskip1ex
      If named values are passed to the dots \texttt{"..."} argument, then the \emph{functional} can bind them to the correct formal arguments of the function being called by the \emph{functional}.
    \column{0.5\textwidth}
      \vspace{-1em}
        <<echo=TRUE,eval=FALSE>>=
# Functional accepts function name and dots '...' argument
testfun <- function(func_name, ...) {
  func_name <- match.fun(func_name)
  func_name(...)  # Execute function call
}  # end testfun
testfun(sum, 1, 2, 3)
testfun(sum, 1, 2, NA, 4, 5)
testfun(sum, 1, 2, NA, 4, 5, na.rm=TRUE)
# Function with three arguments and dots '...' arguments
testfun <- function(input, param1, param2, ...) {
  c(input=input, param1=param1, param2=param2, dots=c(...))
}  # end testfun
testfun(1, 2, 3, param2=4, param1=5)
testfun(testfun, 1, 2, 3, param2=4, param1=5)
testfun(testfun, 1, 2, 3, 4, 5)
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Anonymous Functions}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      \texttt{R} allows defining functions without assigning a name to them.
      \vskip1ex
      \emph{Anonymous} functions are functions that are not assigned to a name.
      \vskip1ex
      \emph{Anonymous} functions can be passed as arguments to \emph{functionals}.
    \column{0.5\textwidth}
      \vspace{-1em}
        <<echo=TRUE,eval=FALSE>>=
# Simple anonymous function
(function(x) (x + 3)) (10)
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Functionals with Anonymous Functions}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      \emph{Anonymous} functions can be passed as arguments to \emph{functionals}.
      \vskip1ex
      \emph{Anonymous} functions can also be used as default values for function arguments.
    \column{0.5\textwidth}
      \vspace{-1em}
        <<echo=TRUE,eval=FALSE>>=
# Anonymous function passed to testfun
testfun(func_name=(function(x) (x + 3)), 5)
# Anonymous function is default value
testfun <-
  function(..., func_name=function(x, y, z) {x+y+z}) {
    func_name <- match.fun(func_name)
    func_name(...)  # Execute function call
}  # end testfun
testfun(2, 3, 4)  # Use default func_name
testfun(2, 3, 4, 5)
# Func_name bound by name
testfun(func_name=sum, 2, 3, 4, 5)
# Pass anonymous function to func_name
testfun(func_name=function(x, y, z) {x*y*z},
            2, 3, 4)
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Executing Function Calls Using the \texttt{do.call()} Functional}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      The functional \texttt{do.call()} executes a function call using a function name and a list of arguments.
      \vskip1ex
      \texttt{do.call()} allows calling a function on arguments that are elements of a list.
      \vskip1ex
      \texttt{do.call()} passes the list elements individually, instead of passing the whole list as one argument:\\
      \texttt{do.call(fun, list)=
      fun(list[[1]], list[[2]], \ldots)}
      \vskip1ex
      \texttt{do.call()} can be called inside other \emph{functionals} to allow them to execute function calls.
      \vskip1ex
      The function \texttt{str()} displays the structure of an \texttt{R} object, for example a function name and its formal arguments.
      \vskip1ex
      The function \texttt{do\_call()} from package \emph{rutils} performs the same operation as \texttt{do.call()}, but using recursion, which is much faster and uses less memory.
    \column{0.5\textwidth}
      \vspace{-1em}
        <<echo=TRUE,eval=FALSE>>=
str(sum)  # Sum() accepts multiple arguments
# Sum() can't accept list of arguments
sum(list(1, 2, 3))
str(do.call)  # "what" argument is a function
# Do.call passes list elements into "sum" individually
do.call(sum, list(1, 2, 3))
do.call(sum, list(1, 2, NA, 3))
do.call(sum, list(1, 2, NA, 3, na.rm=TRUE))
# Functional accepts list with function name and arguments
testfun <- function(list_arg) {
# Produce function name from argument
  func_name <- match.fun(list_arg[[1]])
# Execute function call uing do.call()
  do.call(func_name, list_arg[-1])
}  # end testfun
arg_list <- list("sum", 1, 2, 3)
testfun(arg_list)
# do_call() performs same operation as do.call()
all.equal(
  do.call(sum, list(1, 2, NA, 3, na.rm=TRUE)),
  rutils::do_call(sum, list(1, 2, NA, 3), na.rm=TRUE))
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Performing Loops Using the \texttt{apply()} \secname}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      An important example of \emph{functionals} are the \texttt{apply()} functionals.
      \vskip1ex
      The functional \texttt{apply()} returns the result of applying a function to the rows or columns of an array or matrix.
      \vskip1ex
      If \texttt{MARGIN=1} then the function will be applied over the matrix \emph{rows,}
      \vskip1ex
      If \texttt{MARGIN=2} then the function will be applied over the matrix \emph{columns}.
      \vskip1ex
      \texttt{apply()} performs a loop over the list of objects, and can replace \texttt{"for"} loops in \texttt{R}.
    \column{0.5\textwidth}
      \vspace{-1em}
        <<echo=(-1)>>=
rm(list=ls())
str(apply)  # Get list of arguments
# Create a matrix
matrixv <- matrix(6:1, nrow=2, ncol=3)
matrixv
# Sum the rows and columns
rowsumv <- apply(matrixv, 1, sum)
colsumv <- apply(matrixv, 2, sum)
matrixv <- cbind(c(sum(rowsumv), rowsumv),
                  rbind(colsumv, matrixv))
dimnames(matrixv) <- list(c("colsumv", "row1", "row2"),
                         c("rowsumv", "col1", "col2", "col3"))
matrixv
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{The \texttt{apply()} Functional with dots \texttt{"..."} Argument}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      The dots \texttt{"..."} argument in \texttt{apply()} is designed to pass additional arguments to the function being called by \texttt{apply()}.
      \vskip1ex
      The additional arguments to \texttt{apply()} must be \emph{bound} by their full (complete) names.
      <<echo=TRUE,eval=FALSE>>=
str(apply)  # Get list of arguments
matrixv <- matrix(sample(12), nrow=3, ncol=4)  # Create a matrix
matrixv
apply(matrixv, 2, sort)  # Sort matrix columns
apply(matrixv, 2, sort, decreasing=TRUE)  # Sort decreasing order
      @
    \column{0.5\textwidth}
        <<echo=TRUE,eval=FALSE>>=
matrixv[2, 2] <- NA  # Introduce NA value
matrixv
# Calculate median of columns
apply(matrixv, 2, median)
# Calculate median of columns with na.rm=TRUE
apply(matrixv, 2, median, na.rm=TRUE)
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{The \texttt{apply()} Functional with Anonymous Functions}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      The \texttt{apply()} functional combined with \emph{anonymous} functions can be used to loop over function parameters.
      \vskip1ex
      The dots \texttt{"..."} argument in \texttt{apply()} is designed to pass additional arguments to the function being called by \texttt{apply()}.
      \vskip1ex
      The additional arguments to \texttt{apply()} must be \emph{bound} by their full (complete) names.
    \column{0.5\textwidth}
      \vspace{-1em}
        <<echo=(-1)>>=
rm(list=ls())
# DAX percentage returns
returns <- rutils::diffit(log(EuStockMarkets[, 1]))
library(moments)  # Load package moments
str(moment)  # Get list of arguments
# Apply moment function
moment(x=returns, order=3)
# 4x1 matrix of moment orders
orderv <- as.matrix(1:4)
# Anonymous function allows looping over function parameters
apply(X=orderv, MARGIN=1,
      FUN=function(orderp) {
          moment(x=returns, order=orderp)
        }  # end anonymous function
      )  # end apply

# Another way of passing parameters into moment() function
apply(X=orderv, MARGIN=1, FUN=moment, x=returns)
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{\texttt{apply()} Calling Functions with Multiple Arguments}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      When \texttt{apply()} calls a function with multiple arguments, then care must be taken for proper argument binding.
      \vskip1ex
      The dots \texttt{"..."} argument in \texttt{apply()} allows passing additional arguments to the function being called by \texttt{apply()}.
      \vskip1ex
      The additional arguments to \texttt{apply()} must be \emph{bound} by their full (complete) names.
      \vskip1ex
      The values of the \texttt{"X"} argument in \texttt{apply()} are \emph{bound} by position to the first unused argument in the function being called by \texttt{apply()}.
    \column{0.5\textwidth}
      \vspace{-1em}
        <<echo=TRUE>>=
# Function with three arguments
testfun <- function(arg1, arg2, arg3) {
  c(arg1=arg1, arg2=arg2, arg3=arg3)
}  # end testfun
testfun(1, 2, 3)
datav <- as.matrix(1:4)
# Pass datav to arg1
apply(X=datav, MAR=1, FUN=testfun, arg2=2, arg3=3)
# Pass datav to arg2
apply(X=datav, MAR=1, FUN=testfun, arg1=1, arg3=3)
# Pass datav to arg3
apply(X=datav, MAR=1, FUN=testfun, arg1=1, arg2=2)
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{The \texttt{lapply()} Functional}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      The functional \texttt{lapply()} is a specialized version of the functional \texttt{apply()}.
      \vskip1ex
      \texttt{lapply()} applies a function to a list of objects and returns a list.
      \vskip1ex
      The function \texttt{unlist()} collapses a list with atomic elements into a vector (which can cause type coercion).
      \vskip1ex
      {\color{red}{Rule of Thumb}}\\
      It's often better to use \texttt{lapply()}, since \texttt{apply()} and \texttt{sapply()} attempt to coerce their output into a vector or matrix, which may cause them to fail.
    \column{0.5\textwidth}
      \vspace{-1em}
        <<echo=TRUE,eval=FALSE>>=
# Vector of means of numeric columns
sapply(iris[, -5], mean)
# List of means of numeric columns
lapply(iris[, -5], mean)
# Lapply using anonymous function
unlist(lapply(iris,
              function(column) {
                if (is.numeric(column)) mean(column)
              }  # end anonymous function
              )  # end lapply
       )  # end unlist
unlist(sapply(iris, function(column) {
  if (is.numeric(column)) mean(column)}))
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{The \texttt{sapply()} Functional}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      The \texttt{sapply()} functional is a specialized version of the \texttt{apply()} functional.
      \vskip1ex
      \texttt{sapply()} applies a function to a vector or a list of objects and returns a vector or a list.
      \vskip1ex
      \texttt{sapply()} tries to return a vector, but if the elements can't be combined into a vector, then it returns a list.
      \vskip1ex
      When \texttt{sapply()} is given a data frame, it interretsp it as a list, and applies the function to each element (column) of the data frame.
    \column{0.5\textwidth}
      \vspace{-1em}
        <<echo=TRUE,eval=FALSE>>=
sapply(6:10, sqrt)  # Sapply on vector
sapply(list(6, 7, 8, 9, 10), sqrt)  # Sapply on list

# Calculate means of iris data frame columns
sapply(iris, mean)  # Returns NA for Species

# Create a matrix
matrixv <- matrix(sample(100), ncol=4)
# Calculate column means using apply
apply(matrixv, 2, mean)

# Calculate column means using sapply, with anonymous function
sapply(1:NCOL(matrixv),
       function(col_index) {  # Anonymous function
         mean(matrixv[, col_index])
  }  # end anonymous function
)  # end sapply
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{\texttt{sapply()} Returning Matrices}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      If the function called by \texttt{sapply()} returns a vector, then \texttt{sapply()} returns a matrix, if possible.
      \vskip1ex
      The vectors returned by the function are arranged to form columns of the matrix returned by \texttt{sapply()}.
      \vskip1ex
      But if the function returns vectors of different lengths, then \texttt{sapply()} cannot return a matrix, and returns a list instead.
      \vskip1ex
      This behavior of \texttt{sapply()} can cause run-time errors.
      \vskip1ex
      The function \texttt{vapply()} is similar to \texttt{sapply()}, but it always attempts to simplify its output to a matrix, and if it can't then it produces an error.
      \vskip1ex
      \texttt{vapply()} requires the argument \texttt{FUN.VALUE} that specifes the output format of the function called by \texttt{vapply()}.
    \column{0.5\textwidth}
      \vspace{-1em}
        <<echo=TRUE,eval=FALSE>>=
# Vectors form columns of matrix returned by sapply
sapply(2:4, function(num) c(el1=num, el2=2*num))
# Vectors of different lengths returned as list
sapply(2:4, function(num) 1:num)
# vapply is similar to sapply
vapply(2:4, function(num) c(el1=num, el2=2*num),
       FUN.VALUE=c(row1=0, row2=0))
# vapply produces an error if it can't simplify
vapply(2:4, function(num) 1:num,
       FUN.VALUE=c(row1=0, row2=0))
      @
  \end{columns}
\end{block}

\end{frame}



%%%%%%%%%%%%%%%
\section{Plotting Probability Distributions}



%%%%%%%%%%%%%%%
\subsection{\protect\emph{Normal (Gaussian)} Probability Distribution}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      The \emph{Normal (Gaussian)} probability density function is given by:
      \begin{displaymath}
        \phi(x, \mu, \sigma) = \frac{e^{-(x-\mu)^2/2\sigma^2}}{\sigma\sqrt{2 \pi}}
      \end{displaymath}
      The \emph{Standard Normal} distribution $\phi(0, 1)$ is a special case of the \emph{Normal} $\phi(\mu, \sigma)$ with $\mu=0$ and $\sigma=1$.
      \vskip1ex
      The function \texttt{dnorm()} calculates the \emph{Normal} probability density.
      <<echo=TRUE,eval=FALSE>>=
xvar <- seq(-5, 7, length=100)
yvar <- dnorm(xvar, mean=1.0, sd=2.0)
plot(xvar, yvar, type="l", lty="solid",
     xlab="", ylab="")
title(main="Normal Density Function", line=0.5)
startp <- 3; endd <- 5  # Set lower and upper bounds
# Set polygon base
subv <- ((xvar >= startp) & (xvar <= endd))
polygon(c(startp, xvar[subv], endd),  # Draw polygon
        c(-1, yvar[subv], -1), col="red")
      @
    \column{0.5\textwidth}
    \includegraphics[width=0.5\paperwidth]{figure/norm_dist}
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{\protect\emph{Normal (Gaussian)} Probability Distributions}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      Plots of several \emph{Normal} distributions with different values of $\sigma$, using the function \texttt{curve()} for plotting functions given by their name.
      <<norm_dist_mult_curves,echo=(-(1:1)),eval=FALSE,fig.show="hide">>=
par(mar=c(7, 2, 1, 2), mgp=c(2, 1, 0), cex.lab=0.8, cex.axis=0.8, cex.main=0.8, cex.sub=0.5)
sigmavs <- c(0.5, 1, 1.5, 2)  # Sigma values
# Create plot colors
colorv <- c("red", "black", "blue", "green")
# Create legend labels
labelv <- paste("sigma", sigmavs, sep="=")
for (indeks in 1:4) {  # Plot four curves
curve(expr=dnorm(x, sd=sigmavs[indeks]),
      xlim=c(-4, 4),
      xlab="", ylab="", lwd=2,
      col=colorv[indeks],
      add=as.logical(indeks-1))
}  # end for
# Add title
title(main="Normal Distributions", line=0.5)
# Add legend
legend("topright", inset=0.05, title="Sigmas",
       labelv, cex=0.8, lwd=2, lty=1, bty="n",
       col=colorv)
      @
    \column{0.5\textwidth}
      \includegraphics[width=0.5\paperwidth]{figure/norm_dist_mult_curves-1}
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{\protect\emph{Normal} Probability Distributions Plotted as Lines}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      Plots of several \emph{Normal} distributions with different values of $\sigma$.
      <<norm_dist_mult,echo=(-(1:2)),eval=FALSE,fig.show="hide">>=
rm(list=ls())
par(mar=c(7, 2, 1, 2), mgp=c(2, 1, 0), cex.lab=0.8, cex.axis=0.8, cex.main=0.8, cex.sub=0.5)
xvar <- seq(-4, 4, length=100)
sigmavs <- c(0.5, 1, 1.5, 2)  # Sigma values
# Create plot colors
colorv <- c("red", "black", "blue", "green")
# Create legend labels
labelv <- paste("sigma", sigmavs, sep="=")
# Plot the first chart
plot(xvar, dnorm(xvar, sd=sigmavs[1]),
     type="n", xlab="", ylab="",
     main="Normal Distributions")
# Add lines to plot
for (indeks in 1:4) {
  lines(xvar, dnorm(xvar, sd=sigmavs[indeks]),
        lwd=2, col=colorv[indeks])
}  # end for
# Add legend
legend("topright", inset=0.05, title="Sigmas",
       labelv, cex=0.8, lwd=2, lty=1, bty="n",
       col=colorv)
      @
    \column{0.5\textwidth}
      \includegraphics[width=0.5\paperwidth]{figure/norm_dist_mult-1}
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{The \protect\emph{Log-normal} Probability Distribution}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      If \texttt{x} follows the \emph{Normal} distribution $\phi(x, \mu, \sigma)$, then the exponential of \texttt{x}: $y = e^x$ follows the \emph{Log-normal} distribution $\log\phi()$:
      \begin{displaymath}
        \log\phi(y, \mu, \sigma) = \frac{\exp(-(\log{y} - \mu)^2/2 \sigma^2)}{y \sigma \sqrt{2 \pi}}
      \end{displaymath}
      With mean equal to: $\bar{y} = \mathbb{E}[y] = \exp(\mu + \sigma^2/2)$, and median equal to: $\tilde{y} = \exp(\mu)$
      <<echo=TRUE,eval=FALSE>>=
# Standard deviations of log-normal distribution
sigmavs <- c(0.5, 1, 1.5)
# Create plot colors
colorv <- c("black", "red", "blue")
# Plot all curves
for (indeks in 1:NROW(sigmavs)) {
  curve(expr=dlnorm(x, sdlog=sigmavs[indeks]),
        type="l", xlim=c(0, 3), lwd=2,
        xlab="", ylab="", col=colorv[indeks],
        add=as.logical(indeks-1))
}  # end for
      @
    \column{0.5\textwidth}
      \vspace{-1em}
      \includegraphics[width=0.5\paperwidth]{figure/log_norm_dist.png}
      \vspace{-2em}
      <<echo=TRUE,eval=FALSE>>=
# Add title and legend
title(main="Log-normal Distributions", line=0.5)
legend("topright", inset=0.05, title="Sigmas",
       paste("sigma", sigmavs, sep="="),
       cex=0.8, lwd=2, lty=rep(1, NROW(sigmavs)),
       col=colorv)
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{\protect\emph{Chi-squared} Distribution}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      Let $z_1, \ldots , z_k$ be independent standard \emph{Normal} random variables.
      \vskip1ex
      Then the random variable $X = \sum_{i=1}^k z^2_i$ is distributed according to the \emph{Chi-squared} distribution with $k$ degrees of freedom: $X \sim \chi_k^2$, and its probability density function is given by:
      \begin{displaymath}
        f(x) = \frac{x^{k/2-1} \, e^{-x/2}}{2^{k/2} \, \Gamma(k/2)}
      \end{displaymath}
      \vskip1ex
      The \emph{Chi-squared} distribution with $k$ degrees of freedom has mean equal to $k$ and variance equal to $2k$.
      <<echo=(-(1:2)),eval=FALSE>>=
x11(width=6, height=5)
par(mar=c(2, 2, 2, 1), oma=c(1, 1, 1, 1))
# Degrees of freedom
degf <- c(2, 5, 8, 11)
# Plot four curves in loop
colorv <- c("red", "black", "blue", "green")
for (indeks in 1:4) {
curve(expr=dchisq(x, df=degf[indeks]),
      xlim=c(0, 20), ylim=c(0, 0.3),
      xlab="", ylab="", col=colorv[indeks],
      lwd=2, add=as.logical(indeks-1))
}  # end for
      @
    \column{0.5\textwidth}
      \vspace{-1em}
      \includegraphics[width=0.5\paperwidth]{figure/chisq_dist_mult.png}\\
      \vspace{-1em}
        <<echo=TRUE,eval=FALSE>>=
# Add title
title(main="Chi-squared Distributions", line=0.5)
# Add legend
labelv <- paste("df", degf, sep="=")
legend("topright", inset=0.05, bty="n",
       title="Degrees of freedom", labelv,
       cex=0.8, lwd=6, lty=1,
       col=colorv)
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{\protect\emph{Chi-squared} Distribution Plotted as Line}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      Let $z_1, \ldots , z_k$ be independent standard \emph{Normal} random variables.
      \vskip1ex
      Then the random variable $X = \sum_{i=1}^k z^2_i$ is distributed according to the \emph{Chi-squared} distribution with \texttt{k} degrees of freedom: $X \sim \chi_k^2$, and its probability density function is given by:
      \begin{displaymath}
        f(x) = \frac{x^{k/2-1} \, e^{-x/2}}{2^{k/2} \, \Gamma(k/2)}
      \end{displaymath}
        <<echo=(-(1:2)),eval=FALSE>>=
x11(width=6, height=5)
par(mar=c(2, 2, 2, 1), oma=c(1, 1, 1, 1))
degf <- c(2, 5, 8, 11)  # df values
# Create plot colors
colorv <- c("red", "black", "blue", "green")
# Create legend labels
labelv <- paste("df", degf, sep="=")
# Plot an empty chart
xvar <- seq(0, 20, length=100)
plot(xvar, dchisq(xvar, df=degf[1]),
     type="n", xlab="", ylab="", ylim=c(0, 0.3))
# Add lines to plot
for (indeks in 1:4) {
  lines(xvar, dchisq(xvar, df=degf[indeks]),
        lwd=2, col=colorv[indeks])
}  # end for
      @
    \column{0.5\textwidth}
      \vspace{-1em}
      \includegraphics[width=0.5\paperwidth]{figure/chisq_dist_mult.png}\\
      \vspace{-1em}
        <<echo=TRUE,eval=FALSE>>=
# Add title
title(main="Chi-squared Distributions", line=0.5)
# Add legend
legend("topright", inset=0.05,
       title="Degrees of freedom", labelv,
       cex=0.8, lwd=6, lty=1, bty="n", col=colorv)
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Fisher's \protect\emph{F-distribution}}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      Let $\chi^2_m$ and $\chi^2_n$ be independent random variables following \emph{chi-squared} distributions with $m$ and $n$ degrees of freedom.
      \vskip1ex
      Then the random variable:
      \begin{displaymath}
        F = \frac{\chi^2_m / m}{\chi^2_n / n}
      \end{displaymath}
      Follows the \emph{F-distribution} with $m$ and $n$ degrees of freedom, with the probability density function:
      \begin{displaymath}
        f(F) = \frac{\Gamma((m+n)/2) m^{m/2} n^{n/2}}{\Gamma(m/2) \Gamma(n/2)} \frac{F^{m/2-1}}{(n+mF)^{(m+n)/2}}
      \end{displaymath}
      The \emph{F-distribution} depends on the ratio $F$ and also on the degrees of freedom, $m$ and $n$.
      \vskip1ex
      The function \texttt{df()} calculates the probability density of the \emph{F-distribution}. 
      \vspace{-1em}
      <<echo=(-(1:2)),eval=FALSE>>=
x11(width=6, height=5)
par(mar=c(2, 2, 2, 1), oma=c(1, 1, 1, 1))
# Plot three curves in loop
degf <- c(3, 5, 9)  # Degrees of freedom
colorv <- c("black", "red", "blue", "green")
for (indeks in 1:NROW(degf)) {
curve(expr=df(x, df1=degf[indeks], df2=3),
      xlim=c(0, 4), xlab="", ylab="", lwd=2, 
      col=colorv[indeks], add=as.logical(indeks-1))
}  # end for
      @
    \column{0.5\textwidth}
      \vspace{-1em}
      \includegraphics[width=0.5\paperwidth]{figure/f_dist.png}\\
      \vspace{-1em}
        <<echo=TRUE,eval=FALSE>>=
# Add title
title(main="F-Distributions", line=0.5)
# Add legend
labelv <- paste("df", degf, sep="=")
legend("topright", inset=0.05, title="degrees of freedom",
       labelv, cex=0.8, lwd=2, lty=1,
       col=colorv)
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Student's \protect\emph{t-distribution}}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      Let $z_1,\ldots , z_{\nu}$ be independent standard normal random variables, with sample mean: $\bar{z}=\frac{1}{\nu} \sum_{i=1}^{\nu} z_i$ ($\mathbb{E}[\bar{z}]=\mu$) and sample variance: $\hat\sigma^2=\frac{1}{\nu-1} \sum_{i=1}^{\nu} (z_i-\bar{z})^2$
      \vskip1ex
      Then the random variable (\emph{t-ratio}):
      \begin{displaymath}
        t = \frac{\bar{z} - \mu}{\hat\sigma / \sqrt{\nu}}
      \end{displaymath}
      Follows the \emph{t-distribution} with $\nu$ degrees of freedom, with the probability density function:
      \begin{displaymath}
        f(t) = \frac{\Gamma((\nu+1)/2)}{\sqrt{\pi \nu} \, \Gamma(\nu/2)} \, (1 + t^2/\nu)^{-(\nu+1)/2}
      \end{displaymath}
      \vspace{-1em}
        <<echo=(-(1:2)),eval=FALSE>>=
x11(width=6, height=5)
par(mar=c(2, 2, 2, 1), oma=c(1, 1, 1, 1))
degf <- c(3, 6, 9)  # df values
colorv <- c("black", "red", "blue", "green")
labelv <- c("normal", paste("df", degf, sep="="))
# Plot a Normal probability distribution
curve(expr=dnorm, xlim=c(-4, 4),
      xlab="", ylab="", lwd=2)
for (indeks in 1:3) {  # Plot three t-distributions
curve(expr=dt(x, df=degf[indeks]),
      lwd=2, col=colorv[indeks+1], add=TRUE)
}  # end for
      @
    \column{0.5\textwidth}
      \vspace{-1em}
      \includegraphics[width=0.5\paperwidth]{figure/t_dist_mult.png}\\
      \vspace{-1em}
        <<echo=TRUE,eval=FALSE>>=
# Add title
title(main="t-distributions", line=0.5)
# Add legend
legend("topright", inset=0.05, bty="n",
       title="Degrees\n of freedom", labelv,
       cex=0.8, lwd=6, lty=1, col=colorv)
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Student's \protect\emph{t-distribution} Plotted as Line}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      Let $z_1,\ldots , z_{\nu}$ be independent standard normal random variables, with sample mean: $\bar{z}=\frac{1}{\nu} \sum_{i=1}^{\nu} z_i$ ($\mathbb{E}[\bar{z}]=\mu$) and sample variance: $\hat\sigma^2=\frac{1}{\nu-1} \sum_{i=1}^{\nu} (z_i-\bar{z})^2$
      \vskip1ex
      Then the random variable (\emph{t-ratio}):
      \begin{displaymath}
        t = \frac{\bar{z} - \mu}{\hat\sigma / \sqrt{\nu}}
      \end{displaymath}
      Follows the \emph{t-distribution} with $\nu$ degrees of freedom, with the probability density function:
      \begin{displaymath}
        f(t) = \frac{\Gamma((\nu+1)/2)}{\sqrt{\pi \nu} \, \Gamma(\nu/2)} \, (1 + t^2/\nu)^{-(\nu+1)/2}
      \end{displaymath}
      \vspace{-1em}
        <<echo=(-(1:2)),eval=FALSE>>=
x11(width=6, height=5)
par(mar=c(2, 2, 2, 1), oma=c(1, 1, 1, 1))
xvar <- seq(-4, 4, length=100)
degf <- c(3, 6, 9)  # df values
colorv <- c("black", "red", "blue", "green")
labelv <- c("normal", paste("df", degf, sep="="))
# Plot chart of normal distribution
plot(xvar, dnorm(xvar), type="l",
     lwd=2, xlab="", ylab="")
for (indeks in 1:3) {  # Add lines for t-distributions
  lines(xvar, dt(xvar, df=degf[indeks]),
        lwd=2, col=colorv[indeks+1])
}  # end for
      @
    \column{0.5\textwidth}
      \vspace{-1em}
      \includegraphics[width=0.5\paperwidth]{figure/t_dist_mult.png}\\
      \vspace{-1em}
        <<echo=TRUE,eval=FALSE>>=
# Add title
title(main="t-distributions", line=0.5)
# Add legend
legend("topright", inset=0.05, bty="n",
       title="Degrees\n of freedom", labelv,
       cex=0.8, lwd=6, lty=1, col=colorv)
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{\protect\emph{Cauchy} Distribution}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      The \emph{Cauchy} distribution is Student's \emph{t-distribution} with one degree of freedom $\nu=1$, with the probability density function:
      \begin{displaymath}
        f(x) = \frac{1}{\pi \sigma} \frac{1}{((x - \mu)/\sigma)^2 + 1}
      \end{displaymath}
      Where $\mu$ is the location parameter (equal to the mean) and $\sigma$ is the scale parameter.
      \vskip1ex
      Since the \emph{Cauchy} distribution has an infinite standard deviation, its measure of dispersion is the \emph{interquartile range} (IQR), which is equal to $\sigma$.
      \vskip1ex
      The \emph{interquartile range} is a \emph{robust} measure of dispersion (scale), defined as the difference between the \texttt{75th} minus the \texttt{25th} percentiles.
      \vskip1ex
      The function \texttt{dcauchy()} calculates the \emph{Cauchy} probability density.
      \vskip1ex
      The probability density of the \emph{Cauchy} distribution decreases as the second power for large values of $x$:
      \begin{displaymath}
        f(x) \propto 1/x^2
      \end{displaymath}

    \column{0.5\textwidth}
      \vspace{-1em}
      \includegraphics[width=0.5\paperwidth]{figure/cauchy_dist.png}\\
      \vspace{-1em}
        <<echo=(-(1:2)),eval=FALSE>>=
x11(width=6, height=5)
par(mar=c(2, 2, 2, 1), oma=c(1, 1, 1, 1))
# Plot the Normal and Cauchy probability distributions
curve(expr=dnorm, xlim=c(-4, 4), xlab="", ylab="", lwd=2)
curve(expr=dcauchy, lwd=3, col="blue", add=TRUE)
# Add title
title(main="Cauchy and Normal Distributions", line=0.5)
# Add legend
legend("topright", inset=0.05, bty="n",
       title=NULL,leg=c("Normal", "Cauchy"),
       cex=0.8, lwd=6, lty=1, col=c("black", "blue"))
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{\protect\emph{Pareto} Distribution and \protect\emph{Zipf's} Law}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      The probability density of Student's \emph{t-distribution} decreases as a power for large values of $x$:
      \begin{displaymath}
        f(x) \propto {\left| x \right|}^{-(\nu+1)}
      \end{displaymath}
      The probability density of the \emph{Pareto} distribution decreases as a power of the random variable $x$: 
      \begin{displaymath}
        f(x) = \alpha x^{-(\alpha + 1)}
      \end{displaymath}
      For $x > 1$ and decay parameter $\alpha > 1$.
      \vskip1ex
      The mean $\mu$ and variance $\sigma^2$ of the \emph{Pareto} distribution are equal to:
      \begin{displaymath}
        \mu = \frac{\alpha}{\alpha - 1} \qquad \sigma^2 = \frac{\alpha}{(\alpha - 1)^2 (\alpha - 2)}
      \end{displaymath}
      \emph{Zipf's law} is analogous to the \emph{Pareto} distribution, and applies to discrete variables.
      \vskip1ex
      \emph{Zipf's law} states that the frequency $f$ of a given value is inversely proportional to its rank $n$ in the frequency table: $f(n) \propto n^{-s}$.
      \vskip1ex
      For example, \emph{Zipf's law} applies to the frequency of words in a natural language.

    \column{0.5\textwidth}
      \vspace{-1em}
      \includegraphics[width=0.5\paperwidth]{figure/pareto_dist.png}\\
      \vspace{-1em}
      <<echo=(-(1:2)),eval=FALSE>>=
x11(width=6, height=5)  # Plot in window
par(mar=c(2, 2, 2, 1), oma=c(1, 1, 1, 1))
# Define Pareto function
pare_to <- function(x, alpha) 
  alpha*x^(-alpha-1)
colorv <- c("red", "blue", "green")
alpha_s <- c(1.0, 2.0, 3.0)
for (indeks in 1:3) {  # Plot three curves
  curve(expr=pare_to(x, alpha_s[indeks]),
  xlim=c(1, 2), ylim=c(0.0, 3.5),
  xlab="", ylab="", lwd=3, col=colorv[indeks],
  add=as.logical(indeks-1))
}  # end for
# Add title and legend
title(main="Pareto Distributions", line=0.5)
labelv <- paste("alpha", 1:3, sep=" = ")
legend("topright", inset=0.2, bty="n",
       title=NULL, labelv, cex=0.8, lwd=6, lty=1, 
       col=colorv)
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{\protect\emph{Poisson} Probability Distribution}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      The \emph{Poisson} distribution gives the probability of the number of events observed in an interval of space or time.
      \vskip1ex
      The \emph{Poisson} probability function is given by:
      \begin{displaymath}
        f(n; \lambda) = \frac{{\lambda^n}{\cdot}{e^{-\lambda}}}{n!}
      \end{displaymath}
      The \emph{Poisson} random variable \texttt{n} is the number of events observed in the interval.
      \vskip1ex
      The parameter $\lambda$ is the average number of events that are observed in the interval.
      \vskip1ex
      An example of a \emph{Poisson} distribution is the number of mail items received each day.
      <<poiss_dist,echo=(-(1:2)),eval=FALSE,fig.show="hide">>=
rm(list=ls())
par(mar=c(7, 2, 1, 2), mgp=c(2, 1, 0), cex.lab=0.8, cex.axis=0.8, cex.main=0.8, cex.sub=0.5)
poisson_events <- 0:11  # Poisson events
poisson_freq <- dpois(poisson_events, lambda=4)
names(poisson_freq) <- as.character(poisson_events)
# Poisson function
poissonfun <- function(x, lambda)
                    {exp(-lambda)*lambda^x/factorial(x)}
curve(expr=poissonfun(x, lambda=4), xlim=c(0, 11), main="Poisson distribution",
      xlab="No. of events", ylab="Frequency of events", lwd=2, col="red")
legend(x="topright", legend="Poisson density", title="", bty="n",
       inset=0.05, cex=0.8, bg="white", lwd=4, lty=1, col="red")
      @
    \column{0.5\textwidth}
      \includegraphics[width=0.5\paperwidth]{figure/poiss_dist-1}
  \end{columns}
\end{block}

\end{frame}



%%%%%%%%%%%%%%%
\section{Homework Assignment}


%%%%%%%%%%%%%%%
\subsection{Homework Assignment}
\begin{frame}[t]{\secname}
\vspace{-1em}

\begin{block}{Required}
  \begin{itemize}[]
    \item Study all the lecture slides in \texttt{FRE6871\_Lecture\_1.pdf}, and run all the code in \texttt{FRE6871\_Lecture\_1.R},
    \item Study the 
    \href{https://style.tidyverse.org/}{\color{blue}{\emph{RStudio Style Guide}}}.
  \end{itemize}
\end{block}

\begin{block}{Recommended}
  \begin{itemize}[]
    \item Read about the \emph{Vasicek} single factor model in \texttt{Vasicek Portfolio Default Distribution.pdf}, \texttt{BOE Credit Risk Models.pdf}, \texttt{BIS Bank Capital Model.pdf}, and in \texttt{Elizalde CDO Vasicek Credit Model.pdf}.
  \end{itemize}
\end{block}

\end{frame}


\end{document}
