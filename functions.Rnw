% Define knitr options
% !Rnw weave=knitr
% Set global chunk options
<<knitr_setup,include=FALSE,cache=FALSE>>=
library(knitr)
opts_chunk$set(prompt=TRUE, eval=FALSE, tidy=FALSE, strip.white=FALSE, comment=NA, highlight=FALSE, message=FALSE, warning=FALSE, size='tiny', fig.width=6, fig.height=5)
options(width=80, dev='pdf')
options(digits=3)
thm <- knit_theme$get("acid")
knit_theme$set(thm)
@


% Define document options
\documentclass[10pt]{beamer}
\mode<presentation>
\usetheme{AnnArbor}
% \usecolortheme{whale}
% Uncover everything in a step-wise fashion
% \beamerdefaultoverlayspecification{<+->}
% mathtools package for math symbols
% \usepackage{mathtools}
\usepackage[latin1]{inputenc}
\usepackage{hyperref}
\usepackage{fancybox}
\usepackage{url}
\usepackage[backend=bibtex,style=alphabetic]{biblatex} % bibstyle=numeric
% \bibliographystyle{amsalpha} % doesn't work
\addbibresource{FRE_lectures.bib}
% \addbibresource[location=remote]{http://www.citeulike.org/user/jerzyp}
\renewcommand\bibfont{\footnotesize}
\renewcommand{\pgfuseimage}[1]{\scalebox{0.75}{\includegraphics{#1}}} % scale bib icons
\setbeamertemplate{bibliography item}[text] % set bib icons
% \setbeamertemplate{bibliography item}{} % remove bib icons

% \usepackage{enumerate}
% \let\emph\textbf
% \let\alert\textbf
% Define colors for hyperlinks
\definecolor{links}{HTML}{2A1B81}
\hypersetup{colorlinks=true,linkcolor=,urlcolor=links}
% Make url text scriptsize
\renewcommand\UrlFont{\scriptsize}
% Make institute text italic and small
\setbeamerfont{institute}{size=\small,shape=\itshape}
\setbeamerfont{date}{size=\small}
\setbeamerfont{block title}{size=\normalsize} % shape=\itshape
\setbeamerfont{block body}{size=\footnotesize}


% Title page setup
\title[Functions]{Functions}
\subtitle{FRE6871 \& FRE7241, Spring 2021}
\institute[NYU Tandon]{NYU Tandon School of Engineering}
\titlegraphic{\includegraphics[scale=0.2]{image/tandon_long_color.png}}
\author[Jerzy Pawlowski]{Jerzy Pawlowski \emph{\href{mailto:jp3900@nyu.edu}{jp3900@nyu.edu}}}
% \email{jp3900@nyu.edu}
\date{\today}
% \pgfdeclareimage[height=0.5cm]{university-logo}{engineering_long_white}
% \logo{\pgfuseimage{engineering_long_white}}


%%%%%%%%%%%%%%%
\begin{document}


%%%%%%%%%%%%%%%
\maketitle



%%%%%%%%%%%%%%%
\section{Functions}


%%%%%%%%%%%%%%%
\subsection{\secname \hskip0.4em in \texttt{R}}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      \texttt{R} functions have three components:
      \begin{itemize}
        \item a list of formal arguments,
        \item a body containing \texttt{R} code,
        \item an environment,
      \end{itemize}
      An \texttt{R} function plus its environment is referred to as a function \emph{closures}.
      \vskip1ex
      The function body should be enclosed in curly braces \texttt{\{\}}, unless it contains a single command, then it doesn't have to enclosed.
      \vskip1ex
      The function body doesn't require a \texttt{return} statement, since by default \texttt{R} functions return the last statement evaluated in the body.
      \vskip1ex
      \texttt{args()} displays the formal arguments of a function.
    \column{0.5\textwidth}
      \vspace{-1em}
        <<echo=TRUE,eval=FALSE>>=
# Define a function with two arguments
test_func <- function(first_arg, second_arg) {  # Body
  first_arg + second_arg  # Returns last evaluated statement
}  # end test_func

test_func(1, 2)  # Apply the function
args(test_func)  # Display argument

# Define function that uses variable from enclosure environment
test_func <- function(first_arg, second_arg) {
  first_arg + second_arg + glob_var
}  # end test_func

test_func(3, 2)  # error - glob_var doesn't exist yet!
glob_var <- 10  # Create glob_var
test_func(3, 2)  # Now works
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Return Values of \secname}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      The function body doesn't require a \texttt{return} statement, since by default \texttt{R} functions return the last statement evaluated in the body.
      \vskip1ex
      \texttt{return()} statements are inserted in logical branches to terminate function execution and return its intended value.
    \column{0.5\textwidth}
      \vspace{-1em}
        <<echo=TRUE,eval=FALSE>>=
# Define function that returns NULL for non-numeric argument
test_func <- function(in_put) {
  if (!is.numeric(in_put)) {
    warning(paste("argument", in_put, "isn't numeric"))
    return(NULL)
  }
  2*in_put
}  # end test_func

test_func(2)
test_func("hello")
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{\secname \hskip0.4em That Return \texttt{invisible}}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      If a return value is wrapped in the function \texttt{invisible()} then the return value isn't printed.
      \vskip1ex
      But if the function is assigned to a variable, then its return value is assigned to that variable.
      \vskip1ex
      \texttt{invisible()} allows creating functions whose return values can be assigned, but which do not print when they're not assigned.
      \vskip1ex
      The function \texttt{load()} reads data from \texttt{.RData} files, and \emph{invisibly} returns a vector of names of objects created in the workspace.
    \column{0.5\textwidth}
      \vspace{-1em}
        <<echo=TRUE,eval=FALSE>>=
# Define a function that returns invisibly
return_invisible <- function(in_put) {
  invisible(in_put)
}  # end return_invisible

return_invisible(2)

glob_var <- return_invisible(2)
glob_var

rm(list=ls())  # Remove all objects
# Load objects from file
loaded <- load(file="C:/Develop/data/my_data.RData")
loaded  # Vector of loaded objects
ls()  # List objects
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Binding Function Arguments}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      The formal arguments of a function are defined in its argument list.
      \vskip1ex
      When a function is called, it's passed a list of actual function arguments.
      \vskip1ex
      Formal arguments can be \emph{bound} to actual arguments either by name or by position:
      \begin{itemize}
        \item by name: formal arguments are \emph{bound} to actual arguments with the same name,
        \item by position: the first formal argument is \emph{bound} to the first actual argument, etc.
      \end{itemize}
      \emph{Binding} by name takes precedence over \emph{binding} by position: first all the named arguments are \emph{bound}, then the remaining arguments are \emph{bound} by position.
      \vskip1ex
      Partial argument names are \emph{bound} to full names.
    \column{0.5\textwidth}
      \vspace{-1em}
        <<echo=TRUE,eval=FALSE>>=
test_func <- function(first_arg, second_arg) {
# Last statement of function is return value
  first_arg + 2*second_arg
}  # end test_func
test_func(first_arg=3, second_arg=2)  # Bind by name
test_func(first=3, second=2)  # Partial name binding
test_func(3, 2)  # Bind by position
test_func(second_arg=2, 3)  # mixed binding
test_func(3, 2, 1)  # Too many arguments
test_func(2)  # Not enough arguments
      @
      \vspace{-1em}
      All the actual arguments must be \emph{bound} to formal arguments, and if not then an \texttt{"unused argument"} error is produced.
      \vskip1ex
      If there aren't enough formal arguments, then an \texttt{"argument is missing"} error is produced,
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Default Values for Arguments}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      Formal arguments may be assigned default values, so that when the actual arguments are missing then their default values are used instead.
      \vskip1ex
      Default values are often assigned to function parameters, that determine the function's behavior.
      \vskip1ex
      Default values can be specified as a vector of strings, representing the possible values of a function's parameter.
      \vskip1ex
      The function \texttt{match.arg()} matches a string to one of the possible values, and returns the matched value, or produces an \texttt{error} if it can't match it.
      \vskip1ex
      The function \texttt{str()} displays the structure of an \texttt{R} object, for example a function name and its formal arguments.
    \column{0.5\textwidth}
      \vspace{-1em}
        <<echo=TRUE,eval=FALSE>>=
# Function "paste" has two arguments with default values
str(paste)
# Default values of arguments can be specified in argument list
test_func <- function(first_arg, fac_tor=1) {
  fac_tor*first_arg
}  # end test_func
test_func(3)  # Default value used for second argument
test_func(3, 2)  # Default value over-ridden
# Default values can be a vector of strings
test_func <- function(in_put=c("first_val", "second_val")) {
  in_put <- match.arg(in_put)  # Match to arg list
  in_put
}  # end test_func
test_func("second_val")
test_func("se")  # Partial name binding
test_func("some_val")  # Invalid string
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Function for Calculating Skew}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      \texttt{R} provides an easy way for users to write functions.
      \vskip1ex
      Formal function arguments can be bound to input variables by position or by name.
      \vskip1ex
      If the function arguments are missing then their default value is used.
      \vskip1ex
      Functions return the value of the last expression that is evaluated.
      \vskip1ex
      \texttt{datasets} is a \texttt{base} package containing various datasets, for example: \texttt{EuStockMarkets}.
      \vskip1ex
      The \texttt{EuStockMarkets} dataset contains daily closing prices of european stock indices.
    \column{0.5\textwidth}
      \vspace{-1em}
        <<echo=TRUE,eval=FALSE>>=
# VTI percentage returns
re_turns <- rutils::diff_it(log(Cl(rutils::etf_env$VTI)))
# calc_skew() calculates skew of time series of returns
# Default is normal time series
calc_skew <- function(re_turns=rnorm(1000)) {
  # Number of observations
  n_rows <- NROW(re_turns)
  # Standardize re_turns
  re_turns <- (re_turns - mean(re_turns))/sd(re_turns)
  # Calculate skew - last statement automatically returned
  n_rows*sum(re_turns^3)/((n_rows-1)*(n_rows-2))
}  # end calc_skew

# Calculate skew of DAX returns
# Bind arguments by name
calc_skew(re_turns=re_turns)
# Bind arguments by position
calc_skew(re_turns)
# Use default value of arguments
calc_skew()
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{The dots \texttt{"..."} Function Argument}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      The dots \texttt{"..."} function argument is a formal argument without a name, as opposed to the other formal arguments which all have names.
      \vskip1ex
      The dots \texttt{"..."} bind with any number of additional arguments, that aren't already bound by name or position to the named arguments.
      \vskip1ex
      The dots \texttt{"..."} are used when the number of arguments isn't known in advance, and allows functions to accept an indefinite number of arguments.
      \vskip1ex
      The dots \texttt{"..."} are sometimes placed \emph{after} the named arguments, to allow passing of additional parameters into a function.
      \vskip1ex
      \emph{Functionals} often place the dots \texttt{"..."} argument \emph{after} the named arguments, to allow passing the dots \texttt{"..."} to the function being called by the \emph{functional}.
    \column{0.5\textwidth}
      \vspace{-1em}
        <<echo=TRUE>>=
str(plot)  # Dots for additional plot parameters
bind_dots <- function(in_put, ...) {
  paste0("in_put=", in_put, ", dots=", paste(..., sep=", "))
}  # end bind_dots
bind_dots(1, 2, 3)  # "in_put" bound by position
bind_dots(2, in_put=1, 3)  # "in_put" bound by name
bind_dots(1, 2, 3, foo=10)  # Named argument bound to dots
bind_dots <- function(arg1, arg2, ...) {
  arg1 + 2*arg2 + sum(...)
}  # end bind_dots
bind_dots(3, 2)  # Bind arguments by position
bind_dots(3, 2, 5, 8)  # Extra arguments bound to dots
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Argument Binding With dots \texttt{"..."} Argument}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      The dots \texttt{"..."} argument is sometimes placed \emph{before} the named arguments, so that a function can accept an indefinite number of arguments, without binding them by position with the named arguments.
      \vskip1ex
      When the dots \texttt{"..."} are placed \emph{before} the named arguments, the named arguments are often assigned default values, so they don't have to be bound to a value in the call.
      \vskip1ex
      Arguments that appear after the dots \texttt{"..."} must be \emph{bound} by their full name, and can't be partially \emph{bound}.
    \column{0.5\textwidth}
      \vspace{-1em}
        <<echo=TRUE>>=
str(sum)  # Dots before other arguments
sum(1, 2, 3)  # Dots bind before other arguments
sum(1, 2, NA, 3, na.rm=TRUE)
bind_dots <- function(..., in_put) {
  paste0("in_put=", in_put,
         ", dots=", paste(..., sep=", "))
}  # end bind_dots
# Arguments after dots must be bound by full name
bind_dots(1, 2, 3, in_put=10)
bind_dots(1, 2, 3, in_put=10, foo=4)  # Dots bound
bind_dots(1, 2, 3)  # "in_put" not bound
bind_dots <- function(..., in_put=10) {
  paste0("in_put=", in_put,
         ", dots=", paste(..., sep=", "))
}  # end bind_dots
bind_dots(1, 2, 3)  # "in_put" not bound, but has default
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Wrapper \secname \hskip0.4em With dots \texttt{"..."} Argument}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      \emph{Wrapper} functions provide a convenient user interface to functions, by assigning default argument values, validating data, and formatting the output.
      \vskip1ex
      \emph{Wrapper} functions are designed to perform the actions of other functions, while reducing their complexity.
      \vskip1ex
      The dots \texttt{"..."} argument of the \emph{wrapper} function allows passing additional arguments on to the wrapped function.
      \vskip1ex
      \emph{Wrapper} functions should be used with caution, since wrapping a function creates extra code (overhead), which slows down \texttt{R}.
    \column{0.5\textwidth}
      \vspace{-1em}
        <<echo=TRUE,eval=FALSE>>=
# Wrapper for mean() with default na.rm=TRUE
my_mean <- function(x, na.rm=TRUE, ...) {
  mean(x=x, na.rm=na.rm, ...)
}  # end my_mean
foo <- sample(c(1:10, NA, rep(0.1, t=5)))
mean(c(foo, NA))
mean(c(foo, NA), na.rm=TRUE)
my_mean(c(foo, NA))
my_mean(c(foo, NA), trim=0.4)  # Pass extra argument
# Wrapper for saving data into default directory
save_data <- function(...,
                      file=stop("error: no file name"),
                      my_dir="C:/Develop/data") {
# Create file path
  file <- file.path(my_dir, file)
  save(..., file=file)
}  # end save_data
foo <- 1:10
save_data(foo, file="scratch.RData")
save_data(foo, file="scratch.RData", my_dir="C:/Develop")
# Wrapper for testing negative arguments
stop_if_neg <- function(in_put) {
  if (!is.numeric(in_put) || in_put<0)
    stop("argument not numeric or negative")
}  # end stop_if_neg
# Wrapper for sqrt()
my_sqrt <- function(in_put) {
  stop_if_neg(in_put)
  sqrt(in_put)
}  # end my_sqrt
my_sqrt(2)
my_sqrt(-2)
my_sqrt(NA)
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Recursive \secname \hskip0.4em with dots \texttt{"..."} Argument}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      \emph{Recursive} functions can also accept the dots \texttt{"..."} argument.
      \vskip1ex
      The dots \texttt{"..."} argument can be referenced inside a function by first converting it into a list using \texttt{"list(...)"}.
      \vskip1ex
      The function \texttt{missing()} returns \texttt{TRUE} if an argument is missing, and \texttt{FALSE} otherwise.
    \column{0.5\textwidth}
      \vspace{-1em}
        <<echo=TRUE,eval=FALSE>>=
# Recursive function sums its argument list
sum_dots <- function(in_put, ...) {
  if (missing(...)) {  # Check if dots are empty
    return(in_put)  # just one argument left
  } else {
    in_put + sum_dots(...)  # Sum remaining arguments
  }  # end if
}  # end sum_dots
sum_dots(1, 2, 3, 4)
# Recursive function sums its argument list
sum_dots <- function(in_put, ...) {
  if (NROW(list(...)) == 0) {  # Check if dots are empty
    return(in_put)  # just one argument left
  } else {
    in_put + sum_dots(...)  # Sum remaining arguments
  }  # end if
}  # end sum_dots
sum_dots(1, 2, 3, 4)
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Recursive Function for Calculating Fibonacci Sequence}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      \emph{Recursive} functions call themselves in their own body.
      \vskip1ex
      The \emph{Fibonacci} sequence of integers is defined by the recurrence relation:
      \begin{displaymath}
        F_n = F_{n-1} + F_{n-2},
      \end{displaymath}
      \begin{displaymath}
        F_1 = 0, F_2 = 1,
      \end{displaymath}
      \begin{displaymath}
        F_n = 0, 1, 1, 2, 3, 5, 8, 13, \ldots
      \end{displaymath}
      The \emph{Fibonacci} sequence was invented by \emph{Indian} mathematicians, and later described by the Italian mathematician \emph{Fibonacci} in his famous treatise \emph{Liber Abaci}.
    \column{0.5\textwidth}
      \vspace{-1em}
        <<echo=TRUE>>=
fibo_nacci <- function(len_gth) {
  if (len_gth > 2) {
    fib_seq <- fibo_nacci(len_gth-1)  # Recursion
    c(fib_seq, sum(tail(fib_seq, 2)))  # Return this
  } else {
    c(0, 1)  # Initialize and return
  }
}  # end fibo_nacci
fibo_nacci(10)
tail(fibo_nacci(9), 2)
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Exploring Functions}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      If a function name is called alone without arguments, then \texttt{R} displays the function code (but it must be on the search path).
      \vskip1ex
      Non-visible objects can't be viewed by calling their name.
      \vskip1ex
      The function \texttt{getAnywhere()} displays information about \texttt{R} objects, including non-visible objects.
      \vskip1ex
      The function \texttt{getAnywhere()} also displays \texttt{R} objects that aren't on the search path.
    \column{0.5\textwidth}
      \vspace{-1em}
      <<echo=TRUE,eval=FALSE>>=
# Show the function code
plot.default
# Display function
getAnywhere(plot.default)
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Internal and Primitive Functions}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      \texttt{R} is a high-level language written in lower-level languages, mostly \texttt{C++} and some \texttt{Fortran}.
      \vskip1ex
      \texttt{R} functions are either written in \texttt{R} code (\emph{interpreted} functions), or they directly call compiled \texttt{C++} or \texttt{Fortran} code (\emph{compiled} functions, also called \emph{internal} or \emph{primitive}).
      \vskip1ex
      \texttt{R} parses the code of \emph{interpreted} functions, and eventually calls compiled \texttt{C++} or \texttt{Fortran} code.
      \vskip1ex
      But this extra processing makes \emph{interpreted} functions much slower than \emph{compiled} functions.
      \vskip1ex
      Users can distinguish between \emph{interpreted} functions and \emph{compiled} functions by typing their names, and analyzing their source code.
      \vskip1ex
      The source code of \emph{interpreted} functions contains multiple lines of \texttt{R} code, or a call to function \texttt{UseMethod()} (which \emph{dispatches} \emph{methods} associated with \emph{generic} functions).
      \vskip1ex
      The source code of \emph{compiled} functions contains a single call to one of the functions that execute \emph{compiled} \texttt{C++} or \texttt{Fortran} code: \texttt{.Internal()}, \texttt{.Primitive()}, \texttt{.C()}, \texttt{.Call()}, \texttt{.Fortran()}, or \texttt{.External()}.
    \column{0.5\textwidth}
      \vspace{-1em}
      <<echo=TRUE, eval=FALSE>>=
# Sum() is a compiled primitive function
sum
# mean() is a generic function
mean
# Show all methods of mean()
methods(generic.function=mean)
# Show code for mean.default()
mean.default
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Exploring Internal and Primitive Functions}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      Several functions call compiled code: \texttt{.C()}, \texttt{.Call()}, \texttt{.Fortran()}, \texttt{.External()}, or \texttt{.Internal()} and \texttt{.Primitive()}
      \vskip1ex
      \texttt{R} \texttt{.Internal()} \texttt{.Primitive()}
      \vskip1ex
      The function \texttt{getAnywhere()} displays \texttt{R} objects, including functions.
      \vskip1ex
      If a function name is called alone then \texttt{R} displays the function code (but it must be on the search path).
      \vskip1ex
      the user can access symbols from a package that isn't attached using the double-colon operator \texttt{tools::file\_ext}

      The function \texttt{getAnywhere()} also displays \texttt{R} objects that aren't on the search path.
    \column{0.5\textwidth}
      \vspace{-1em}
        <<echo=TRUE,eval=FALSE>>=
# Get all methods for generic function "plot"
methods("plot")

getAnywhere(plot)  # Display function
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Lazy Evaluation of Function Arguments}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      \texttt{R} functions delay evaluation of their arguments until they're needed by their \texttt{R} code.
      \vskip1ex
      This is called \emph{lazy} evaluation.
      \vskip1ex
      If the function body doesn't evaluate an argument, then the function won't produce an error, even if the argument is missing.
    \column{0.5\textwidth}
      \vspace{-1em}
        <<echo=(-1)>>=
rm(list=ls())
lazy_func <- function(arg1, arg2) {  # Define function lazy_func
  2*arg1  # just multiply first argument
}  # end lazy_func
lazy_func(3, 2)  # Bind arguments by position
lazy_func(3)  # Second argument was never evaluated!
lazy_func <- function(arg1, arg2) {  # Define function lazy_func
  cat(arg1, '\n')  # Write to output
  cat(arg2)  # Write to output
}  # end lazy_func
lazy_func(3, 2)  # Bind arguments by position
lazy_func(3)  # First argument written to output
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Function Environments}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      When a function is called, a new \emph{evaluation} environment is created.
      \vskip1ex
      The \emph{evaluation} environment contains the function arguments and locally defined variables.
      \vskip1ex
      \texttt{R} evaluates variables inside functions by searching first in the \emph{evaluation} environment, then the \emph{enclosure} environment, then the \texttt{R} search path.
      \vskip1ex
      The enclosure of the \emph{evaluation} environment is the environment where the function was defined.
      \vskip1ex
      The enclosure of functions defined in the workspace is the \emph{global} environment.
      \vskip1ex
      The enclosure of functions defined in packages is the package \emph{namespace}.
      \vskip1ex
      Objects defined in the function enclosure can be referenced inside the function.
    \column{0.5\textwidth}
      \vspace{-1em}
        <<echo=(-1)>>=
rm(list=ls())
glob_var <- 1  # Define a global variable
ls(environment())  # Get all variables in environment
func_env <- function() {  # Explore function environments
  loc_var <- 1  # Define a local variable
  cat('objects in evaluation environment:\t',
      ls(environment()), '\n')
  cat('objects in enclosing environment:\t',
      ls(parent.env(environment())), '\n')
  cat('this is the enclosing environment:')
  parent.env(environment())  # Return enclosing environment
}  # end func_env
func_env()

environment(func_env)
environment(print)  # Package namespace is the enclosure
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Lexical Function Scope}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      A \emph{free} variable is a variable that's not included in the \emph{evaluation} environment.
      \vskip1ex
      Scoping rules determine how \emph{free} variables are evaluated.
      \vskip1ex
      By default \texttt{R} uses \emph{lexical} (\emph{static}) scoping, which means that variables are first evaluated in the \emph{evaluation} environment, then in the \emph{enclosing} environment in which the function was \emph{defined}, and so on.
      \vskip1ex
      \emph{Dynamic} scoping means that variables are evaluated in the environment from which the function was \emph{called}.
      \vskip1ex
      The standard assignment operator \texttt{"<-"} modifies variables in the \emph{evaluation} environment.
      \vskip1ex
      The special assignment operator \texttt{"<<-"} modifies variables in the \emph{enclosing} environment,

    \column{0.5\textwidth}
      \vspace{-1em}
        <<echo=(-1)>>=
rm(list=ls())
glob_var <- 1  # Define a global variable
probe_scope <- function() {  # Explore function scope
  loc_var <- 2*glob_var  # Define a local variable
  new_globvar <<- 11  # Define a global variable
  cat('objects in evaluation environment:\t',
      ls(environment()), '\n')
  cat('this is a local loc_var:\t', loc_var, '\n')
  cat('objects in enclosing environment:\n',
      ls(parent.env(environment())), '\n')
  cat('this is glob_var:\t', glob_var, '\n')
  glob_var <- 10  # Define local glob_var
  cat('this is the local glob_var:\t', glob_var, '\n')
}  # end probe_scope
probe_scope()
glob_var  # Global variable is unaffected
new_globvar  # new_globvar is preserved
loc_var  # Local variable is gone!
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Argument Passing in \texttt{R}}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      In general, arguments can be passed into functions either by \emph{value} or by \emph{reference}.
      \vskip1ex
      When an argument is passed by \emph{value}, then a copy of that argument is passed to the function.
      \vskip1ex
      That way if the function modifies that argument, then the original object isn't modified.
      \vskip1ex
      When an argument is passed by \emph{reference}, then a \emph{pointer} to the original object is passed to the function.
      \vskip1ex
      If the function modifies that argument, then the original object is modified as well.
      \vskip1ex
      \texttt{R} uses a hybrid method of argument passing called \emph{copy-on-modify semantics}.
      \vskip1ex
      \texttt{R} passes arguments by reference, thus saving memory space and time for copying.
      \vskip1ex
      But if the argument is modified within the function, then \texttt{R} makes a copy of it, so that the original object is unchanged.
    \column{0.5\textwidth}
      \vspace{-1em}
        <<echo=TRUE,eval=FALSE>>=
a <- 1  # Define a variable
# New variable "b" points to value of "a"
b <- a  # Define a new variable
# When "b" is modified, R makes a copy of it
b <- b+1
# Function doubles its argument and returns it
double_it <- function(in_put) {
  in_put <- 2*in_put
  cat("input argument was doubled to:", in_put, "\n")
  in_put
}
double_it(a)
a  # variable "a" is unchanged
      @
      \emph{Copy-on-modify semantics} has important implications for performance and memory usage.
      \vskip1ex
      \url{http://stackoverflow.com/questions/15759117/what-exactly-is-copy-on-modify-semantics-in-r-and-where-is-the-canonical-source}
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Side effects Using the Super-assignment Operator \texttt{"<<-"}}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      Function \emph{side effects} are operations on objects outside a function's \emph{evaluation} environment.
      \vskip1ex
      The functions \texttt{plot()} and \texttt{load()} are examples of functions that produce \emph{side effects}.
      \vskip1ex
      \texttt{load()} reads data from an \texttt{.RData} file, and creates objects in the workspace that are contained in the \texttt{.RData} file.
      \vskip1ex
      The super-assignment operator \texttt{"<<-"} allows creating functions that produce \emph{side effects}.
      \vskip1ex
      The super-assignment operator \texttt{"<<-"} modifies or creates variables in the \emph{enclosing} environment in which a function was \emph{defined} (\emph{lexical} scoping).
      \vskip1ex
      If a function was \emph{defined} in the \emph{global} environment then that's the function's \emph{enclosing} environment, and the \texttt{"<<-"} operator operates on variables in the \emph{global} environment.
    \column{0.5\textwidth}
      \vspace{-1em}
        <<echo=(-(1:1))>>=
setwd("C:/Develop/lecture_slides/data")
rm(list=ls())  # Remove all objects
ls()  # List objects
# Load objects from file (side effect)
load(file="my_data.RData")
ls()  # List objects
glob_var <- 1  # Define a global variable
# Explore function scope and side effects
side_effect <- function() {
  cat("global glob_var:\t", glob_var, "\n")
# Define local "glob_var" variable
  glob_var <- 10
# Re-define the global "glob_var"
  glob_var <<- 2
  cat("local glob_var:\t", glob_var, "\n")
}  # end side_effect
side_effect()
# Global variable was modified as side effect
glob_var
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Operators as Functions}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      Most functions in \texttt{R} are \emph{prefix} operators (where the function name is followed by a list of arguments).
      \vskip1ex
      \emph{Infix} operators (where the the function name comes in between its arguments) can also be applied using \emph{prefix} syntax.
      \vskip1ex
      In \emph{prefix} syntax, the \emph{Infix} operator name must be surrounded by single \texttt{''} or double  \texttt{""} quotes.
      \vskip1ex
      The \texttt{"["} bracket operator can also be written as a \emph{prefix} function.
    \column{0.5\textwidth}
      \vspace{-1em}
        <<echo=TRUE,eval=FALSE>>=
# Standard infix operator call syntax
2 + 3
# Infix operator applied using prefix syntax
"+"(2, 3)
# Standard bracket operator
vec_tor <- c(4, 3, 5, 6)
vec_tor[2]
# Bracket operator applied using prefix syntax
"["(vec_tor, 2)

      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Defining New Infix Operators}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      New \emph{infix} operators can be defined using the usual function definition syntax.
      \vskip1ex
      All user defined \emph{infix} operators names must be nested between \texttt{"\%"} characters.
    \column{0.5\textwidth}
      \vspace{-1em}
        <<echo=TRUE,eval=FALSE>>=
# Define infix operator that returns string
'%+%' <- function(a, b) paste(a, b, sep=" + ")
2 %+% 3
2 %+% 3 %+% 4
"hello" %+% 2 %+% 3 %+% "bye"
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Replacement Functions}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      \texttt{R} syntax allows assigning to the values returned by functions, but they must be defined as \emph{replacement} functions.
      \vskip1ex
      \emph{replacement} function names include the assignment arrow: \texttt{"name<-"}.
      \vskip1ex
      The first argument passed to the \emph{replacement} function is modified by the second argument, and then it's returned.
    \column{0.5\textwidth}
      \vspace{-1em}
        <<echo=TRUE,eval=FALSE>>=
obj_string <- "hello"
class(obj_string)
# Assign to value returned by "class" function
class(obj_string) <- "string"
class(obj_string)
# Define function last()
last <- function(vec_tor) {
  vec_tor[NROW(vec_tor)]
}  # end last
last(1:10)
# Define replacement function last()
'last<-' <- function(vec_tor, value) {
  vec_tor[NROW(vec_tor)] <- value
  vec_tor
}  # end last
x <- 1:5
last(x) <- 11
x
      @
  \end{columns}
\end{block}

\end{frame}



%%%%%%%%%%%%%%%
\section{Higher order Functions}


%%%%%%%%%%%%%%%
\subsection{Functions as First Class Objects}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      Functions in \texttt{R} are \emph{first class objects}, which means they can be treated like any other \texttt{R} object:
      \begin{itemize}
        \item Functions can be passed as arguments to other functions,
        \item Functions can be nested (defined inside other functions),
        \item Functions can return functions as their return value,
      \end{itemize}
      \emph{Higher order} functions are \texttt{R} functions that either accept a function as their argument (input) or return a function as their value (output).
    \column{0.5\textwidth}
      \vspace{-1em}
        <<echo=TRUE,eval=FALSE>>=
# Create functional that accepts a function as input argument
func_tional <- function(func_name) {
# Calculates statistic on random numbers
  set.seed(1)
  func_name(runif(1e4))  # Apply the function name
}  # end func_tional
func_tional(mean)
func_tional(sd)
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Functions That Return Functions}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      \texttt{R} functions can also return a function as their value.
      \vskip1ex
      Functions returned by a function are called \emph{closures}.
      \vskip1ex
      Functions that return closures can be used as \emph{function factories}.
    \column{0.5\textwidth}
      \vspace{-1em}
        <<echo=TRUE,eval=FALSE>>=
# Define a power function factory
make_func <- function(arg_param) {  # Wrapper function
  function(in_put) {  # Anonymous closure
    in_put^arg_param
  }
}  # end make_func

square_func <- make_func(2)  # Define square function
square_func(4)
cube_func <- make_func(3)  # Define cube function
cube_func(2)
cube_root_func <- make_func(1/3)  # Define cube root function
cube_root_func(8)
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Mutable States}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      A \emph{mutable state} is an object that is preserved between function calls.
      \vskip1ex
      Functions that return closures can also be used for creating \emph{mutable states}.
      \vskip1ex
      A function \emph{evaluation} environment is only temporary and disappears after the function returns its value.
      \vskip1ex
      But a \emph{closure} assigned to a name maintains access to the environment in which it was created.
      \vskip1ex
      Therefore the \emph{closure} maintains access to its parent function's arguments and locally defined variables.
    \column{0.5\textwidth}
      \vspace{-1em}
        <<echo=TRUE,eval=FALSE>>=
make_counter <- function() {
# Counter function with mutable state
  counter <- 0  # Initialize counter
  cat('counter = ', counter)
  function() {  # Return anonymous advance function
    counter <<- counter + 1  # Advance counter
    cat('counter = ', counter)
  }  # end advance function
}  # end make_counter

advance_counter <- make_counter()  # Create new counter
advance_counter()  # Advance counter
advance_counter()  # Advance counter
advance_counter_two <- make_counter()  # Create another counter
advance_counter_two()  # Advance counter two
advance_counter()  # Advance counter one
advance_counter_two()  # Advance counter two
advance_counter()  # Advance counter one
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Pseudo-Random Generating Function}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \emph{Mutable states} can be used to implement pseudo-random number generators,
        <<echo=TRUE,eval=FALSE>>=
# Returns the pseudo-random generating function random_generator
# the formal argument 'seed' persists in the evaluation environment of seed_random
seed_random <- function(seed) {  # Seed must be an integer
  random_number <- as.numeric(paste0('0.', seed))  # Initialize
# Random_generator returns a vector of pseudo-random numbers of length length_rand
  random_generator <- function(length_rand=1) {  # Assign function name for recursion
# Returns a vector of pseudo-random numbers of length length_rand
    random_number <<- 4*random_number*(1 - random_number)  # Logistic map
    if (length_rand == 1) {
      return(random_number)
    } else {
      return(c(random_number, random_generator(length_rand - 1)))
    }  # end if
  }  # end random_generator
}  # end seed_random

# Create a random number generating function and set seed
make_random <- seed_random(88)
make_random(10)  #  calculate vector of 10 pseudo-random numbers
ls(environment(make_random))  # List objects in scope of make_random
      @
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Bank Account Using Mutable States}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-2em}
  \begin{columns}[T]
    \column{0.5\textwidth}
        <<echo=(-(1:3))>>=
rm(list=ls())
# The super-assignment operator '<<-' adjusts the balance
# 'balance' exists in open_account evaluation environment
# Bank account example (from Venables) demonstrates mutable states
# 'balance' is persistent between function calls
open_account <- function(balance) {
# Returns function list for account operations
  list(
    deposit = function(amount) {  # Make deposit
      if (amount > 0) {
        balance <<- balance + amount  # '<<-' super-assignment operator
        cat(amount, "deposited. Your balance is now:",
            balance, "\n")
      } else {
        cat("Deposits must be positive!\n")
      }
    },  # end deposit
    withdraw = function(amount) {  # Make withdrawal
      if (amount <= balance) {
        balance <<- balance - amount  # '<<-' super-assignment operator
        cat(amount, "withdrawn. Your balance is now:",
            balance, "\n")
      } else {
        cat("You don't have that much money!\n")
      }
    },  # end withdraw
    get_balance = function() {  # Get balance
      cat("Your current balance is:", balance, "\n")
    }  # end get_balance
  )  # end list
}  # end open_account
@
    \column{0.5\textwidth}
        <<echo=TRUE,eval=FALSE>>=
# Perform account operations
# open an account with 100 deposit
my_account <- open_account(100)
ls(my_account)  # my_account is a list
# Add my_account to search path
attach(my_account)
withdraw(30)  # Withdrawal to buy groceries
deposit(100)  # Deposit paycheck to account
withdraw(200)  # Withdrawal to buy Gucci bag
get_balance()  # Get account balance

# List objects in scope of get_balance
ls(environment(get_balance))

detach(my_account)  # Remove my_account from search path
@
  \end{columns}

\end{frame}



%%%%%%%%%%%%%%%
\section{Functionals}


%%%%%%%%%%%%%%%
\subsection{Functionals}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      \emph{Functionals} are functions that accept a function or a function name (string) as one of their input arguments.
      \vskip1ex
      \emph{Functionals} are able to execute function calls using the function names.
      \vskip1ex
      The function \texttt{match.fun()} returns a function name that is specified by a string.
      \vskip1ex
      \emph{Functionals} that call \texttt{match.fun()} are able to accept a string as a function name, because \texttt{match.fun()} converts it to a function.
      \vskip1ex
      \texttt{match.fun()} produces an error condition if it fails to find a function with the specified name.
    \column{0.5\textwidth}
      \vspace{-1em}
        <<echo=TRUE,eval=FALSE>>=
# Func_tional accepts function name and additional argument
func_tional <- function(func_name, in_put) {
# Produce function name from argument
  func_name <- match.fun(func_name)
# Execute function call
  func_name(in_put)
}  # end func_tional
func_tional(sqrt, 4)
# String also works because match.fun() converts it to a function
func_tional("sqrt", 4)
str(sum)  # Sum() accepts multiple arguments
# Func_tional can't accept indefinite number of arguments
func_tional(sum, 1, 2, 3)
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Functionals with dots \texttt{"..."} Argument}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      The dots \texttt{"..."} argument in \emph{functionals} can be used to pass additional arguments to the function being called by the \emph{functional}.
      \vskip1ex
      If named values are passed to the dots \texttt{"..."} argument, then the \emph{functional} can bind them to the correct formal arguments of the function being called by the \emph{functional}.
    \column{0.5\textwidth}
      \vspace{-1em}
        <<echo=TRUE,eval=FALSE>>=
# Func_tional accepts function name and dots '...' argument
func_tional <- function(func_name, ...) {
  func_name <- match.fun(func_name)
  func_name(...)  # Execute function call
}  # end func_tional
func_tional(sum, 1, 2, 3)
func_tional(sum, 1, 2, NA, 4, 5)
func_tional(sum, 1, 2, NA, 4, 5, na.rm=TRUE)
# Function with three arguments and dots '...' arguments
my_func <- function(in_put, param1, param2, ...) {
  c(input=in_put, param1=param1, param2=param2,
        dots=c(...))
}  # end my_func
my_func(1, 2, 3, param2=4, param1=5)
func_tional(my_func, 1, 2, 3, param2=4, param1=5)
func_tional(my_func, 1, 2, 3, 4, 5)
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Anonymous Functions}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      \texttt{R} allows defining functions without assigning a name to them.
      \vskip1ex
      \emph{Anonymous} functions are functions that are not assigned to a name.
      \vskip1ex
      \emph{Anonymous} functions can be passed as arguments to \emph{functionals}.
    \column{0.5\textwidth}
      \vspace{-1em}
        <<echo=TRUE,eval=FALSE>>=
# Simple anonymous function
(function(x) (x + 3)) (10)
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Functionals with Anonymous Functions}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      \emph{Anonymous} functions can be passed as arguments to \emph{functionals}.
      \vskip1ex
      \emph{Anonymous} functions can also be used as default values for function arguments.
    \column{0.5\textwidth}
      \vspace{-1em}
        <<echo=TRUE,eval=FALSE>>=
# Anonymous function passed to func_tional
func_tional(func_name=(function(x) (x + 3)), 5)
# Anonymous function is default value
func_tional <-
  function(..., func_name=function(x, y, z) {x+y+z}) {
    func_name <- match.fun(func_name)
    func_name(...)  # Execute function call
}  # end func_tional
func_tional(2, 3, 4)  # Use default func_name
func_tional(2, 3, 4, 5)
# Func_name bound by name
func_tional(func_name=sum, 2, 3, 4, 5)
# Pass anonymous function to func_name
func_tional(func_name=function(x, y, z) {x*y*z},
            2, 3, 4)
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Executing Function Calls Using the \texttt{do.call()} Functional}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      The functional \texttt{do.call()} executes a function call using a function name and a list of arguments.
      \vskip1ex
      \texttt{do.call()} allows calling a function on arguments that are elements of a list.
      \vskip1ex
      \texttt{do.call()} passes the list elements individually, instead of passing the whole list as one argument:\\
      \texttt{do.call(fun, list)=
      fun(list[[1]], list[[2]], \ldots)}
      \vskip1ex
      \texttt{do.call()} can be called inside other \emph{functionals} to allow them to execute function calls.
      \vskip1ex
      The function \texttt{str()} displays the structure of an \texttt{R} object, for example a function name and its formal arguments.
      \vskip1ex
      The function \texttt{do\_call()} from package \emph{rutils} performs the same operation as \texttt{do.call()}, but using recursion, which is much faster and uses less memory.
    \column{0.5\textwidth}
      \vspace{-1em}
        <<echo=TRUE,eval=FALSE>>=
str(sum)  # Sum() accepts multiple arguments
# Sum() can't accept list of arguments
sum(list(1, 2, 3))
str(do.call)  # "what" argument is a function
# Do.call passes list elements into "sum" individually
do.call(sum, list(1, 2, 3))
do.call(sum, list(1, 2, NA, 3))
do.call(sum, list(1, 2, NA, 3, na.rm=TRUE))
# Func_tional() accepts list with function name and arguments
func_tional <- function(list_arg) {
# Produce function name from argument
  func_name <- match.fun(list_arg[[1]])
# Execute function call uing do.call()
  do.call(func_name, list_arg[-1])
}  # end func_tional
arg_list <- list("sum", 1, 2, 3)
func_tional(arg_list)
# Do_call() performs same operation as do.call()
all.equal(
  do.call(sum, list(1, 2, NA, 3, na.rm=TRUE)),
  rutils::do_call(sum, list(1, 2, NA, 3), na.rm=TRUE))
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Performing Loops Using the \texttt{apply()} \secname}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      An important example of \emph{functionals} are the \texttt{apply()} functionals.
      \vskip1ex
      The functional \texttt{apply()} returns the result of applying a function to the rows or columns of an array or matrix.
      \vskip1ex
      If \texttt{MARGIN=1} then the function will be applied over the matrix \emph{rows,}
      \vskip1ex
      If \texttt{MARGIN=2} then the function will be applied over the matrix \emph{columns}.
      \vskip1ex
      \texttt{apply()} performs a loop over the list of objects, and can replace \texttt{"for"} loops in \texttt{R}.
    \column{0.5\textwidth}
      \vspace{-1em}
        <<echo=(-1)>>=
rm(list=ls())
str(apply)  # Get list of arguments
# Create a matrix
mat_rix <- matrix(6:1, nrow=2, ncol=3)
mat_rix
# Sum the rows and columns
row_sums <- apply(mat_rix, 1, sum)
col_sums <- apply(mat_rix, 2, sum)
mat_rix <- cbind(c(sum(row_sums), row_sums),
                  rbind(col_sums, mat_rix))
dimnames(mat_rix) <- list(c("col_sums", "row1", "row2"),
                         c("row_sums", "col1", "col2", "col3"))
mat_rix
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{The \texttt{apply()} Functional with dots \texttt{"..."} Argument}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      The dots \texttt{"..."} argument in \texttt{apply()} is designed to pass additional arguments to the function being called by \texttt{apply()}.
      \vskip1ex
      The additional arguments to \texttt{apply()} must be \emph{bound} by their full (complete) names.
      <<echo=TRUE,eval=FALSE>>=
str(apply)  # Get list of arguments
mat_rix <- matrix(sample(12), nrow=3, ncol=4)  # Create a matrix
mat_rix
apply(mat_rix, 2, sort)  # Sort matrix columns
apply(mat_rix, 2, sort, decreasing=TRUE)  # Sort decreasing order
      @
    \column{0.5\textwidth}
        <<echo=TRUE,eval=FALSE>>=
mat_rix[2, 2] <- NA  # Introduce NA value
mat_rix
# Calculate median of columns
apply(mat_rix, 2, median)
# Calculate median of columns with na.rm=TRUE
apply(mat_rix, 2, median, na.rm=TRUE)
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{The \texttt{apply()} Functional with Anonymous Functions}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      The \texttt{apply()} functional combined with \emph{anonymous} functions can be used to loop over function parameters.
      \vskip1ex
      The dots \texttt{"..."} argument in \texttt{apply()} is designed to pass additional arguments to the function being called by \texttt{apply()}.
      \vskip1ex
      The additional arguments to \texttt{apply()} must be \emph{bound} by their full (complete) names.
    \column{0.5\textwidth}
      \vspace{-1em}
      <<echo=TRUE,eval=FALSE>>=
# VTI percentage returns
re_turns <- rutils::diff_it(log(Cl(rutils::etf_env$VTI)))
library(moments)  # Load package moments
str(moment)  # Get list of arguments
# Apply moment function
moment(x=re_turns, order=3)
# 4x1 matrix of moment orders
moment_orders <- as.matrix(1:4)
# Anonymous function allows looping over function parameters
apply(X=moment_orders, MARGIN=1,
      FUN=function(moment_order) {
          moment(x=re_turns, order=moment_order)
        }  # end anonymous function
      )  # end apply

# Another way of passing parameters into moment() function
apply(X=moment_orders, MARGIN=1, FUN=moment, x=re_turns)
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{\texttt{apply()} Calling Functions with Multiple Arguments}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      When \texttt{apply()} calls a function with multiple arguments, then care must be taken for proper argument binding.
      \vskip1ex
      The dots \texttt{"..."} argument in \texttt{apply()} allows passing additional arguments to the function being called by \texttt{apply()}.
      \vskip1ex
      The additional arguments to \texttt{apply()} must be \emph{bound} by their full (complete) names.
      \vskip1ex
      The values of the \texttt{"X"} argument in \texttt{apply()} are \emph{bound} by position to the first unused argument in the function being called by \texttt{apply()}.
    \column{0.5\textwidth}
      \vspace{-1em}
        <<echo=TRUE>>=
# Function with three arguments
my_func <- function(arg1, arg2, arg3) {
  c(arg1=arg1, arg2=arg2, arg3=arg3)
}  # end my_func
my_func(1, 2, 3)
da_ta <- as.matrix(1:4)
# Pass da_ta to arg1
apply(X=da_ta, MAR=1, FUN=my_func, arg2=2, arg3=3)
# Pass da_ta to arg2
apply(X=da_ta, MAR=1, FUN=my_func, arg1=1, arg3=3)
# Pass da_ta to arg3
apply(X=da_ta, MAR=1, FUN=my_func, arg1=1, arg2=2)
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{The \texttt{lapply()} Functional}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      The functional \texttt{lapply()} is a specialized version of the functional \texttt{apply()}.
      \vskip1ex
      \texttt{lapply()} applies a function to a list of objects and returns a list.
      \vskip1ex
      The function \texttt{unlist()} collapses a list with atomic elements into a vector (which can cause type coercion).
      \vskip1ex
      {\color{red}{Rule of Thumb}}\\
      It's often better to use \texttt{lapply()}, since \texttt{apply()} and \texttt{sapply()} attempt to coerce their output into a vector or matrix, which may cause them to fail.
    \column{0.5\textwidth}
      \vspace{-1em}
        <<echo=TRUE,eval=FALSE>>=
# Vector of means of numeric columns
sapply(iris[, -5], mean)
# List of means of numeric columns
lapply(iris[, -5], mean)
# Lapply using anonymous function
unlist(lapply(iris,
              function(col_umn) {
                if (is.numeric(col_umn)) mean(col_umn)
              }  # end anonymous function
              )  # end lapply
       )  # end unlist
unlist(sapply(iris, function(col_umn) {
  if (is.numeric(col_umn)) mean(col_umn)}))
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{The \texttt{sapply()} Functional}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      The \texttt{sapply()} functional is a specialized version of the \texttt{apply()} functional.
      \vskip1ex
      \texttt{sapply()} applies a function to a vector or a list of objects and returns a vector or a list.
      \vskip1ex
      \texttt{sapply()} tries to return a vector, but if the elements can't be combined into a vector, then it returns a list.
      \vskip1ex
      When \texttt{sapply()} is given a data frame, it interprets it as a list, and applies the function to each element (column) of the data frame.
    \column{0.5\textwidth}
      \vspace{-1em}
        <<echo=TRUE,eval=FALSE>>=
sapply(6:10, sqrt)  # Sapply on vector
sapply(list(6, 7, 8, 9, 10), sqrt)  # Sapply on list

# Calculate means of iris data frame columns
sapply(iris, mean)  # Returns NA for Species

# Create a matrix
mat_rix <- matrix(sample(100), ncol=4)
# Calculate column means using apply
apply(mat_rix, 2, mean)

# Calculate column means using sapply, with anonymous function
sapply(1:NCOL(mat_rix),
       function(col_index) {  # Anonymous function
         mean(mat_rix[, col_index])
  }  # end anonymous function
)  # end sapply
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{\texttt{sapply()} Returning Matrices}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      If the function called by \texttt{sapply()} returns a vector, then \texttt{sapply()} returns a matrix, if possible.
      \vskip1ex
      The vectors returned by the function are arranged to form columns of the matrix returned by \texttt{sapply()}.
      \vskip1ex
      But if the function returns vectors of different lengths, then \texttt{sapply()} cannot return a matrix, and returns a list instead.
      \vskip1ex
      This behavior of \texttt{sapply()} can cause run-time errors.
      \vskip1ex
      The function \texttt{vapply()} is similar to \texttt{sapply()}, but it always attempts to simplify its output to a matrix, and if it can't then it produces an error.
      \vskip1ex
      \texttt{vapply()} requires the argument \texttt{FUN.VALUE} that specifes the output format of the function called by \texttt{vapply()}.
    \column{0.5\textwidth}
      \vspace{-1em}
        <<echo=TRUE,eval=FALSE>>=
# Vectors form columns of matrix returned by sapply
sapply(2:4, function(num) c(el1=num, el2=2*num))
# Vectors of different lengths returned as list
sapply(2:4, function(num) 1:num)
# vapply is similar to sapply
vapply(2:4, function(num) c(el1=num, el2=2*num),
       FUN.VALUE=c(row1=0, row2=0))
# vapply produces an error if it can't simplify
vapply(2:4, function(num) 1:num,
       FUN.VALUE=c(row1=0, row2=0))
      @
  \end{columns}
\end{block}

\end{frame}



%%%%%%%%%%%%%%%
\section{Object-Oriented Programming in \texttt{R}}


%%%%%%%%%%%%%%%
\subsection{The \texttt{S3} Object-Oriented Programming System in \texttt{R}}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      \texttt{S3} is the standard object oriented (OO) programming system in \texttt{R}.
      \vskip1ex
      The \texttt{S3} system is based on \emph{generic} functions and the \texttt{R} \emph{class} system.
      \vskip1ex
      \emph{Generic} functions are functions that execute different \emph{methods} depending on the class of the object on which the \emph{generic} function is called.
      \vskip1ex
      \emph{Methods} are functions that are specific to a \emph{generic} function and a class of objects.
      \vskip1ex
      \emph{Methods} follow the naming convention \texttt{generic\_function.classname()}.
      \vskip1ex
      The actual function that is executed (called a \emph{method}) is determined by the class of the object on which the \emph{generic} function is called.
      \vskip1ex
      For example, when the function \texttt{merge()} is called on a \texttt{zoo} object, then \texttt{R} executes the \emph{method} \texttt{merge.zoo()}.
    \column{0.5\textwidth}
      \vspace{-1em}
      <<echo=TRUE,eval=FALSE>>=
library(zoo)  # Load package zoo
# Show the generic function "merge"
merge
# Show the "merge" method dispatched to "zoo" objects
merge.zoo
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Generic Functions and Their Methods}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      The \emph{generic} function \texttt{merge()} has many \emph{methods} with names \texttt{merge.*()}.
      \vskip1ex
      The function \texttt{methods()} lists all the \emph{methods} of a generic function, or all the \emph{methods} for a \emph{class} of objects.
      \vskip1ex
      The \texttt{merge()} method dispatched to \texttt{zoo} objects is called \texttt{merge.zoo()}.
    \column{0.5\textwidth}
      \vspace{-1em}
      <<echo=(-1)>>=
library(zoo)  # Load package zoo
# Get all methods for generic function merge()
methods(generic.function="merge")
# Get generic function methods applied to "zoo" objects
methods(class="zoo")
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Method Dispatch Using \texttt{UseMethod()}}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      The function \texttt{UseMethod()} can be used to implement \emph{generic} functions.
      \vskip1ex
      \texttt{UseMethod()} accepts at least two arguments: the name of a \emph{generic} function, and the arguments passed to the \emph{generic} function.
      \vskip1ex
      \texttt{UseMethod()} calls (\emph{dispatches}) a particular \emph{method} associated with the \emph{generic} function, depending on the \emph{class} of the arguments passed to the \emph{generic} function.
      \vskip1ex
      The arguments passed to the \emph{generic} function are by default passed to \texttt{UseMethod()}, and then along to the \emph{method} itself.
    \column{0.5\textwidth}
      \vspace{-1em}
        <<echo=TRUE,eval=FALSE>>=
# Define a generic function
gen_sum <- function(a, b, ...) {
  UseMethod("gen_sum")
}  # end gen_sum

# Define method for "numeric" class
gen_sum.numeric <- function(a, b, ...) {
  sum(a, b)
}  # end gen_sum.character

# Define method for "character" class
gen_sum.character <- function(a, b, ...) {
  paste(a, "plus", b)
}  # end gen_sum.character

# Apply gen_sum to "numeric" objects
gen_sum(1, 2)
# Apply gen_sum to "character" objects
gen_sum("a", "b")
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Method Dispatch by Internal Generic Functions}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      \emph{Method} dispatch by \emph{internal generic} functions is performed inside compiled \texttt{C} code, instead of \texttt{R} code using the function \texttt{UseMethod()}.
      \vskip1ex
      \emph{Internal} functions are implemented using the function \texttt{.Internal()}.
    \column{0.5\textwidth}
      \vspace{-1em}
        <<echo=TRUE,eval=FALSE>>=
# 'cbind' is an internal generic function
cbind
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Operator Overloading}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      Operator \emph{overloading} refers to defining new \emph{methods} for an existing \emph{generic} function.
      \vskip1ex
      The \texttt{"+"} operator may be overloaded by defining a new \emph{method} for \texttt{"character"} objects.
      \vskip1ex
      But for the \emph{overloading} of the \texttt{"+"} operator to work, the objects must have an explicit \texttt{"character"} class \emph{attribute} assigned to them.
    \column{0.5\textwidth}
      \vspace{-1em}
        <<echo=TRUE,eval=FALSE>>=
# Define "+" method for "character" class
"+.character" <- function(a, b, ...) {
  paste(a, "plus", b)
}  # end +.character
methods("+")  # view methods for "+" operator
# Define variables with "character" class
char1 <- "a"
char2 <- "b"
class(char1)
char1 + char2  # Add two "character" objects - doesn't work
attributes(char1)  # Doesn't have explicit "character" class - only implicit
char1 <- structure("a", class="character")
char2 <- structure("b", class="character")
attributes(char1)  # Now has explicit "character" class
# Add two "character" objects
char1 + char2
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Overloading the \texttt{print()} Function}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      The \emph{generic} functions \texttt{print()}, \texttt{plot()} and \texttt{summary()} are very often \emph{overloaded} for newly defined classes.
      \vskip1ex
      Since \texttt{print()} is a \emph{generic} function, \texttt{R} \emph{dispatches} the \emph{method} associated with the \emph{class} of that variable.
      \vskip1ex
      When a variable is called by its name, then \texttt{R} invokes the \texttt{print()} function on that variable.
    \column{0.5\textwidth}
      \vspace{-1em}
        <<echo=TRUE,eval=FALSE>>=
# Define object of class "string"
obj_string <- "how are you today?"
class(obj_string) <- "string"
obj_string
# overload "print" method for string objects
print.string <- function(str_ing) {
  print(
    paste(strsplit(str_ing, split=" ")[[1]],
          collapse=" + "))
}  # end print.string
# methods("print")  # view new methods for "print" function
print(obj_string)
obj_string
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Operator Overwriting}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      Operator \emph{overwriting} refers to redefining an existing function.
      \vskip1ex
      The functions \texttt{.Internal()} and \texttt{.Primitive()} call functions that are part of the internal code of \texttt{R}.
      \vskip1ex
      Operator \emph{overwriting} should be used with care, since it may cause unintended consequences.
    \column{0.5\textwidth}
      \vspace{-1em}
        <<echo=TRUE,eval=FALSE>>=
# overwrite "+" operator
"+" = function(a, b) {
  if (is.character(a) && is.character(b)) {
    paste(a, "plus", b)
  } else {
    .Primitive("+") (a, b)
  }
}
methods("+")  # view methods for "+" operator
# Add two "numeric" objects
1 + 2
# Add two "character" objects
"a" + "b"
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Operator Overwriting Using \texttt{UseMethod()}}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      Existing functions can be \emph{overwritten} with \emph{generic} functions using \texttt{UseMethod()}.
      \vskip1ex
      Operator \emph{overwriting} should be used with care, since it may cause unintended consequences.
    \column{0.5\textwidth}
      \vspace{-1em}
        <<echo=TRUE,eval=FALSE>>=
# overwrite "+" operator with a generic function
"+" <- function(a, b, ...) {
  UseMethod("+")
}  # end gen_sum
# Define method for "numeric" class
"+.numeric" <- function(a, b, ...) {
  sum(a, b)
}  # end gen_sum.character
# Define method for "character" class
"+.character" <- function(a, b, ...) {
  paste(a, "plus", b)
}  # end gen_sum.character
methods("+")  # view methods for "+" operator
# Add two "numeric" objects
1 + 2
# Add two "character" objects
"a" + "b"
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Exploring Generic Function Methods}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      Most \emph{methods} can be viewed by simply calling their full name, unless they're non-visible.
      \vskip1ex
      Non-visible \emph{methods} can be viewed using the triple-colon operator \texttt{":::"}.
      \vskip1ex
      Non-visible \emph{methods} can also be viewed by calling the function \texttt{getAnywhere()}.
    \column{0.5\textwidth}
      \vspace{-1em}
        <<echo=TRUE,eval=FALSE>>=
cbind.ts  # Can't view non-visible method
stats::cbind.ts  # Can't view non-visible method
stats:::cbind.ts  # Display non-visible method
getAnywhere(cbind.ts)  # Display non-visible method
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Defining New Classes and Methods}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      A new \texttt{R} class can be created by simply assigning to the \emph{class} attribute of an existing object.
      \vskip1ex
      New \emph{methods} can be defined for existing \emph{generic} functions, and \texttt{R} will automatically \emph{dispatch} them for objects of the new \emph{class}.
      \vskip1ex
      The function unclass() removes the explicit class attribute from an object.
      \vskip1ex
      Calling unclass() allows using the \emph{methods} associated with the original object before a new \emph{class} attribute was assigned to it.
      \vskip1ex
      The functions \texttt{.Internal()} and \texttt{.Primitive()} call internally implemented (\emph{primitive}) functions.
    \column{0.5\textwidth}
      \vspace{-1em}
      <<echo=(-1)>>=
rm(list=ls())
new_zoo <- zoo(rnorm(10), order.by=(Sys.Date() + 0:9))
# Coerce "zoo" object to new class "zoo_xtra"
class(new_zoo) <- "zoo_xtra"
class(new_zoo)
methods(generic.function="length")
length  # Primitive function
# Define "length" method for class "zoo_xtra"
length.zoo_xtra <- function(in_ts) {
  cat("length of zoo_xtra object:\n")
# Unclass object, then calculate length
  NROW(unclass(in_ts))
}  # end length.zoo_xtra
NROW(new_zoo)  # Apply "length" method to "zoo_xtra" object
methods(generic.function="length")
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Defining New Generic Functions and Methods}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      New \emph{methods} have to be called by their full name if a \emph{generic} function isn't defined for them.
      \vskip1ex
      Once a \emph{generic} function is defined, then new \emph{methods} can be called by their short name
    \column{0.5\textwidth}
      \vspace{-1em}
      <<echo=TRUE,eval=FALSE>>=
# Define "last" method for class "zoo_xtra"
last.zoo_xtra <- function(in_ts) {
  in_ts[NROW(in_ts)]
}  # end last.zoo_xtra
last(new_zoo)  # Doesn't work
last.zoo_xtra(new_zoo)  # Works
# Define a generic function
last <- function(a, b, ...) {
  UseMethod("last")
}  # end last
last(new_zoo)  # Now works
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Creating a "string" Class}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      A new \texttt{"string"} class can be created from a \texttt{character} object, by assigning to its \emph{class} attribute.
      \vskip1ex
      The \emph{generic} function \texttt{as.string()} converts objects to class "\emph{string}".
      \vskip1ex
      The function \texttt{structure()} adds attributes to an object (specified as \texttt{symbol=value} pairs), and returns it.
      \vskip1ex
      The function \texttt{inherits()} checks whether the object \emph{class} matches any of the names in the \texttt{"what"} argument.
    \column{0.5\textwidth}
      \vspace{-1em}
      <<echo=TRUE,eval=FALSE>>=
# Define generic "string" class converter
as.string <- function(str_ing, ...)
  UseMethod("as.string")
# Default "string" class converter
as.string.default <- function(str_ing, ...)
  structure(str_ing, class="string", ...)
# Numeric "string" class converter
as.string.numeric <- function(str_ing, ...)
  structure(as.character(str_ing), class="string", ...)
# "string" class checker
is.string <- function(str_ing)
  inherits(x=str_ing, what="string")
# Define "string" object
obj_string <- as.string("how are you today?")
obj_string
is.string(obj_string)
is.string("hello")
as.string(123)
is.string(as.string(123))
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Inheritance and Derived Classes and Methods}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      \emph{Inheritance} is a mechanism for defining a new class that is \emph{derived} from a \emph{base} class.
      \vskip1ex
      The \emph{derived} class \emph{inherits} all the \emph{methods} from the \emph{base} class, but can also have new \emph{methods} of its own.
      \vskip1ex
      In the \texttt{S3} system \emph{inheritance} is implemented by making the \emph{class} attribute a \emph{vector}.
      \vskip1ex
      When a \emph{generic} function \texttt{gen\_fun} is called on an object with class attribute \texttt{c("class2", "class1")}, then \texttt{R} \emph{dispatches} a \emph{method} called \texttt{gen\_fun.class2}.
      \vskip1ex
      If there's no \emph{method} with that name, then \texttt{R} first \emph{dispatches} a \emph{method} called \texttt{gen\_fun.class1}.
      \vskip1ex
      Finally if there are no \emph{methods} with those names, then \texttt{R} \emph{dispatches} a \emph{method} called \texttt{gen\_fun.default}.
    \column{0.5\textwidth}
      \vspace{-1em}
      <<echo=(-1)>>=
rm(list=ls())
library(xts)
new_xts <- xts(rnorm(10), order.by=(Sys.Date() + 0:9))
class(new_xts)  # Class attribute is a vector
# "last" is a generic function from package "xts"
last
methods(generic.function="last")
last(new_xts)  # Apply "last" method from "xts" class
# Derive object "xts_xtra" from "xts" object
class(new_xts) <- c("xts_xtra", class(new_xts))
class(new_xts)  # Class attribute is a vector
# "xts_xtra" object inherits "last" method from "xts" class
last(new_xts)
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Defining New Methods for Derived Classes}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      The \texttt{S3} system automatically \emph{dispatches} newly defined \emph{methods} to objects of the new \emph{class}.
      \vskip1ex
      If new \emph{methods} aren't found, then it \emph{dispatches} existing \emph{methods} from the \emph{base} class to objects of the new \emph{class}.
      \vskip1ex
      The function \texttt{NextMethod()} \emph{dispatches} the base method of a \emph{generic} function.
    \column{0.5\textwidth}
      \vspace{-1em}
      <<echo=TRUE,eval=FALSE>>=
# Define new "last" method for class "xts_xtra"
last.xts_xtra <- function(in_ts) {
  cat("last element of xts_xtra object:\n")
  drop(in_ts[NROW(in_ts), ])
}  # end last.xts_xtra
last(new_xts)  # Apply "last" from "xts_xtra" class
# Define "last" method for class "xts_xtra"
last.xts_xtra <- function(in_ts) {
  cat("last element of xts_xtra object:\n")
  drop(NextMethod())
}  # end last.xts_xtra
last(new_xts)  # Apply "last" from "xts_xtra" class
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Homework Assignment}
\begin{frame}[t]{\subsecname}

\begin{block}{Required}
  \begin{itemize}
    \item Create a function for calculating the kurtosis of a time series of returns,
    \item Using this function calculate the kurtosis of DAX returns, and of t-distribution returns with four degrees of freedom (use the same number of data points in both cases),
    \item Plot the probability density of DAX returns together with t-distribution returns with four degrees of freedom on a single plot,
  \end{itemize}
\end{block}
\pause

\begin{block}{Recommended}
  \begin{itemize}
    \item Read chapters 4, 5, 10 from: \href{http://cran.r-project.org/doc/manuals/r-release/R-intro.pdf}{\emph{Introduction to \texttt{R}}}.
  \end{itemize}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Additional Reading}
\begin{frame}[t]{\subsecname}

Download \texttt{R} Interpreter from \texttt{CRAN} (Comprehensive \texttt{R} Archive Network)\\
\hskip1em\url{http://cran.r-project.org/}\\
\vskip4ex
Download \emph{RStudio} IDE (Integrated Development Environment)\\
\hskip1em\url{http://www.rstudio.com/products/rstudio/}\\
\vskip4ex

\end{frame}


\end{document}
