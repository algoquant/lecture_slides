% Define knitr options
% !Rnw weave=knitr
% Set global chunk options
<<knitr_setup,include=FALSE,cache=FALSE>>=
library(knitr)
opts_chunk$set(prompt=TRUE, eval=FALSE, tidy=FALSE, strip.white=FALSE, comment=NA, highlight=FALSE, message=FALSE, warning=FALSE, size="tiny", fig.width=4, fig.height=4)
options(width=80, dev="pdf")
options(digits=3)
thm <- knit_theme$get("acid")
knit_theme$set(thm)
@


% Define document options
\documentclass[9pt]{beamer}
\DeclareMathSizes{8pt}{6pt}{6pt}{5pt}
\mode<presentation>
\usetheme{AnnArbor}
% \usecolortheme{whale}
% Uncover everything in a step-wise fashion
% \beamerdefaultoverlayspecification{<+->}
% mathtools package for math symbols
% \usepackage{mathtools}
\usepackage[latin1]{inputenc}
\usepackage{hyperref}
\usepackage{fancybox}
\usepackage{url}
\usepackage[backend=bibtex,style=alphabetic]{biblatex} % bibstyle=numeric
% \bibliographystyle{amsalpha} % doesn't work
\addbibresource{FRE_lectures.bib}
% \addbibresource[location=remote]{http://www.citeulike.org/user/jerzyp}
\renewcommand\bibfont{\footnotesize}
\renewcommand{\pgfuseimage}[1]{\scalebox{0.75}{\includegraphics{#1}}} % scale bib icons
\setbeamertemplate{bibliography item}[text] % set bib icons
% \setbeamertemplate{bibliography item}{} % remove bib icons

% \usepackage{enumerate}
% \let\emph\textbf
% \let\alert\textbf
% Define colors for hyperlinks
\definecolor{links}{HTML}{2A1B81}
\hypersetup{colorlinks=true,linkcolor=,urlcolor=links}
% Make url text scriptsize
\renewcommand\UrlFont{\scriptsize}
% Make institute text italic and small
\setbeamerfont{institute}{size=\small,shape=\itshape}
\setbeamerfont{date}{size=\small}
\setbeamerfont{block title}{size=\normalsize} % shape=\itshape
\setbeamerfont{block body}{size=\footnotesize}


% Title page setup
\title[Control Statements, Operators and Debugging]{Control Statements, Operators and Debugging}
\subtitle{FRE6871 \& FRE7241, Fall 2022}
\institute[NYU Tandon]{NYU Tandon School of Engineering}
\titlegraphic{\includegraphics[scale=0.2]{image/tandon_long_color.png}}
\author[Jerzy Pawlowski]{Jerzy Pawlowski \emph{\href{mailto:jp3900@nyu.edu}{jp3900@nyu.edu}}}
% \email{jp3900@poly.edu}
\date{\today}
% \pgfdeclareimage[height=0.5cm]{university-logo}{engineering_long_white}
% \logo{\pgfuseimage{engineering_long_white}}


%%%%%%%%%%%%%%%
\begin{document}


%%%%%%%%%%%%%%%
\maketitle


%%%%%%%%%%%%%%%
\section{Operators}


%%%%%%%%%%%%%%%
\subsection{Logical Operators}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      \texttt{R} has the following logical operators:
      \begin{itemize}
        \item \texttt{"<"} less than,
        \item \texttt{"<="} less than or equal to,
        \item \texttt{">"} greater than,
        \item \texttt{">="} greater than or equal to,
        \item \texttt{"=="} exactly equal to,
        \item \texttt{"!="} not equal to,
        \item \texttt{"!x"} Not \texttt{x},
        \item \texttt{"x \& y"} \texttt{x} AND \texttt{y},
        \item \texttt{"x | y"} \texttt{x} OR \texttt{y},
      \end{itemize}
      These operators are applied to vectors element-wise.
    \column{0.5\textwidth}
      \vspace{-1em}
        <<echo=(-(1:1))>>=
rm(list=ls())
TRUE | FALSE
TRUE | NA
vector1 <- c(2, 4, 6)
vector1 < 5  # Element-wise comparison
(vector1 < 5) & (vector1 > 3)
vector1[(vector1 < 5) & (vector1 > 3)]
vector2 <- c(-10, 0, 10)
vector1 < vector2
c(FALSE, TRUE, FALSE) & c(TRUE, TRUE, FALSE)
c(FALSE, TRUE, FALSE) | c(TRUE, TRUE, FALSE)
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Long Form Logical Operators}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      \texttt{R} also has two long form logical operators:
      \begin{itemize}
        \item \texttt{"x \&\& y"} \texttt{x} AND \texttt{y},
        \item \texttt{"x || y"} \texttt{x} OR \texttt{y},
      \end{itemize}
      These operators differ from the short form operators in two ways:
      \begin{itemize}
        \item They only evaluate the first elements of their vector arguments,
        \item They short-circuit (stop evaluation as soon as the expression is determined),
      \end{itemize}
      {\color{red}{Rule of Thumb}}
      \begin{itemize}
        \item Use \texttt{"\&\&"} and \texttt{"||"} in if-clauses,
      \end{itemize}
    \column{0.5\textwidth}
      \vspace{-1em}
        <<echo=(-(1:1))>>=
rm(list=ls())
c(FALSE, TRUE, FALSE) && c(TRUE, TRUE, FALSE)
c(FALSE, TRUE, FALSE) || c(TRUE, TRUE, FALSE)
echo_true <- function() {cat("echo_true\t"); TRUE}
echo_false <- function() {cat("echo_false\t"); FALSE}
echo_true() | echo_false()
echo_true() || echo_false()  # echo_false() isn't evaluated at all!
vectorv <- c(2, 4, 6)
# Works (does nothing) using '&&'
if (is.matrix(vectorv) && (vectorv[2, 3] > 0)) {
  vectorv[2, 3] <- 1
}
# No short-circuit so fails (produces an error)
if (is.matrix(vectorv) & (vectorv[2, 3] > 0)) {
  vectorv[2, 3] <- 1
}
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Arithmetic Operators}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      Arithmetic \emph{operators} perform arithmetic operations on \texttt{numeric} or \texttt{complex} vectors,
      \begin{itemize}
        \item "\texttt{+}" performs addition,
        \item "\texttt{-}" performs subtraction,
        \item "\texttt{*}" performs multiplication,
        \item "\texttt{/}" performs division,
        \item "\texttt{\textasciicircum{}}" and "\texttt{**}" perform exponentiation,
      \end{itemize}
    \column{0.5\textwidth}
      \vspace{-1em}
      <<echo=TRUE,eval=FALSE>>=
?Arithmetic
4.7 * 0.5  # Multiplication
4.7 / 0.5  # Division
# Exponentiation
2**3
2^3
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Comparing Objects With \texttt{identical()} and \texttt{all.equal()}}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      The function \texttt{identical()} tests if two objects are exactly the same, and always returns a single logical \texttt{TRUE} or \texttt{FALSE} (never \texttt{NA} or logical \texttt{vectors}).
      \vskip1ex
      For atomic arguments \texttt{identical()} often gives the same result as the \texttt{"=="} operator, but it's not synonymous with it in general.
      \vskip1ex
      The \texttt{"=="} operator applies the \emph{recycling rule} to vector arguments and returns logical \texttt{vectors}, but \texttt{identical()} doesn't and returns a single logical value.
      \vskip1ex
      The function \texttt{all.equal()} tests the equality of two objects to within the square root of the \emph{machine precision}.
      \vskip1ex
      The variable \texttt{.Machine} contains information about the numerical characteristics of the computer \texttt{R} is running on, such as the largest \texttt{double} and \texttt{integer} numbers, and the \emph{machine precision}.
    \column{0.5\textwidth}
      \vspace{-1em}
      <<echo=TRUE,eval=FALSE>>=
numv <- 2
numv==2
identical(numv, 2)

identical(numv, NULL)
# This doesn't work:
# numv==NULL
is.null(numv)

vectorv <- c(2, 4, 6)
vectorv==2
identical(vectorv, 2)

# numv is equal to "1.0" within machine precision
numv <- 1.0 + 2*sqrt(.Machine$double.eps)
all.equal(numv, 1.0)

# Info machine precision of computer R is running on
# ?.Machine
# Machine precision
.Machine$double.eps
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Lookup and Matching Using \texttt{which()} and \texttt{match()}}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      The function \texttt{which()} returns the indices of the \texttt{TRUE} elements of a \texttt{Boolean} \texttt{vector} or \texttt{array}.
      \vskip1ex
      If the argument is an \texttt{array} and \texttt{arr.ind=TRUE}, then \texttt{which()} returns a matrix with rows containing the indices of the \texttt{TRUE} elements.
      \vskip1ex
      The functions \texttt{which.max()} and \texttt{which.min()} return the index of the minimum or maximum of a \texttt{numeric} or \texttt{Boolean} vector.
      \vskip1ex
      \texttt{match()} returns the index of the vector element that \emph{exactly} matches its first argument.
      \vskip1ex
      If it doesn't find an exact match then it returns \texttt{NA}.
      \vskip1ex
      The expressions \texttt{match(x, vec\_tor)} and \texttt{min(which(vec\_tor == x))} produce the same result, but \texttt{match()} can be faster for large vectors.
    \column{0.5\textwidth}
      \vspace{-1em}
      <<echo=TRUE,eval=FALSE>>=
vectorv <- sample(1e3, 1e3)
matrixv <- matrix(vectorv, ncol=4)
which(vectorv == 5)
match(5, vectorv)
# Equivalent but slower than above
(1:NROW(vectorv))[vectorv == 5]
which(vectorv < 5)
# Find indices of TRUE elements of Boolean matrix
which((matrixv == 5)|(matrixv == 6), arr.ind=TRUE)
# Equivalent but slower than above
arrayInd(which((matrixv == 5)|(matrixv == 6)),
         dim(matrixv), dimnames(matrixv))
# Find index of largest element
which.max(vectorv)
which(vectorv == max(vectorv))
# Find index of smallest element
which.min(vectorv)
# Benchmark match() versus which()
all.equal(match(5, vectorv),
          min(which(vectorv == 5)))
library(microbenchmark)
summary(microbenchmark(
  match=match(5, vectorv),
  which=min(which(vectorv == 5)),
  times=10))[, c(1, 4, 5)]  # end microbenchmark summary
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Lookup and Matching Using \texttt{\%in\%} and \texttt{any()}}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      The binary operator \texttt{\%in\%} returns a \texttt{Boolean} \texttt{vector} with \texttt{TRUE} values corresponding to elements that have matches.
      \vskip1ex
      \texttt{\%in\%} is a wrapper for \texttt{match()} defined as follows: 
      \texttt{"\%in\%" <- function(x, table) match(x, table, nomatch=0) > 0}.
      \vskip1ex
      \texttt{\%in\%} never returns \texttt{NA}, so it's preferred in \texttt{if()} statements.
      \vskip1ex
      \texttt{any()} returns \texttt{TRUE} if at least one element of a \texttt{Boolean} vector is \texttt{TRUE}, and \texttt{FALSE} otherwise.
      \vskip1ex
      The function \texttt{pmatch()} performs partial matching of strings.
    \column{0.5\textwidth}
      \vspace{-1em}
      <<echo=TRUE,eval=FALSE>>=
# Does 5 belong in vectorv?
5 %in% vectorv
match(5, vectorv, nomatch=0) > 0
# Does (-5) belong in vectorv?
(-5) %in% vectorv
c(5, -5) %in% vectorv
match(-5, vectorv)
# Equivalent to "5 %in% vectorv"
any(vectorv == 5)
# Equivalent to "(-5) %in% vectorv"
any(vectorv == (-5))
# Any negative values in vectorv?
any(vectorv < 0)
# Example of use in if() statement
if (any(vectorv < 2))
  cat("vector contains small values\n")
# Partial matching of strings
pmatch("med", c("mean", "median", "mode"))
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Finding Closest Match Using \texttt{findInterval()}}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      The function \texttt{match()} returns the index of the vector element that \emph{exactly} matches its first argument.
      \vskip1ex
      If \texttt{match()} doesn't find an exact match then it returns \texttt{NA}.
      \vskip1ex
      The function \texttt{findInterval()} returns the indices of the intervals specified by \texttt{"vec"} that contain the elements of \texttt{"x"}.
      \vskip1ex
      If there's an exact match, then \texttt{findInterval()} returns the same index as function \texttt{match()}.
      \vskip1ex
      If there's no exact match, then \texttt{findInterval()} finds the element of \texttt{"vec"} that is closest to, but not greater than, the element of \texttt{"x"}.
    \column{0.5\textwidth}
      \vspace{-1em}
      <<echo=TRUE,eval=FALSE>>=
# Display the formal arguments of findInterval
args(findInterval)
# Get index of the element of "vec" that matches 5
findInterval(x=5, vec=c(3, 5, 7))
match(5, c(3, 5, 7))
# No exact match
findInterval(x=6, vec=c(3, 5, 7))
match(6, c(3, 5, 7))
# Indices of "vec" that match elements of "x"
findInterval(x=1:8, vec=c(3, 5, 7))
# Return only indices of inside intervals
findInterval(x=1:8, vec=c(3, 5, 7), all.inside=TRUE)
# Make rightmost interval inclusive
findInterval(x=1:8, vec=c(3, 5, 7), rightmost.closed=TRUE)
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Assignment Operators}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      The standard assignment operator in \texttt{R} is \texttt{"<-"}.
      \vskip1ex
      Both \texttt{"<-"} and \texttt{"="} are valid assignment operators in \texttt{R}.
      \vskip1ex
      The \texttt{"<-"} operator may cause an error if \texttt{R} confuses it with the \texttt{"<"} logical operator.
      \vskip1ex
      But they differ in \emph{scope} and  \emph{precedence} (\texttt{"<-"} has higher precedence than \texttt{"="}).
      \vskip1ex
      The \texttt{"="} operator is used for named arguments in function calls.
      \vskip1ex
      When variables are assigned within an argument list using the \texttt{"="} operator, their \emph{scope} is limited to the function.
      \vskip1ex
      {\color{red}{Rule of Thumb}}:\\
      Use \texttt{"<-"} in \texttt{R} scripts and inside functions,\\
      Use \texttt{"="} only in function calls.
    \column{0.5\textwidth}
      \vspace{-1em}
            <<echo=TRUE,eval=FALSE>>=
numv1 <- 3  # "<-" and "=" are valid assignment operators
numv1
numv1 = 3
numv1
2<-3  # "<" operator confused with "<-"
2 < -3  # Add space or brackets to avoid confusion
# "=" assignment within argument list
median(x=1:10)
x  # x doesn't exist outside the function
# "<-" assignment within argument list
median(x <- 1:10)
x  # x exists outside the function
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{The \texttt{assign()} Function}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      The \texttt{assign()} function assigns a value to an object in a specified \emph{environment}, by referencing it using a character string (name).
      \vskip1ex
      \texttt{assign()} can be used to either assign values to existing variables, or to create new variables.
      \vskip1ex
      \texttt{assign()} looks for the object name in the specified \emph{environment}, and assigns a value to it.
      \vskip1ex
      If \texttt{assign()} can't find the object name, then it creates it.
      \vskip1ex
      \texttt{assign()} expects a character string as its argument.
      \vskip1ex
      If a object name is passsed to \texttt{assign()}, then it evaluates that object to get the string it contains.
      \vskip1ex
      If the object doesn't contain a string, then \texttt{assign()} produces an error.
    \column{0.5\textwidth}
      \vspace{-1em}
            <<echo=TRUE,eval=FALSE>>=
myvar <- 1  # Create new object
assign(x="myvar", value=2)  # Assign value to existing object
myvar
rm(myvar)  # Remove myvar
assign(x="myvar", value=3)  # Create new object from name
myvar
# Create new object in new environment
new_env <- new.env()  # Create new environment
assign("myvar", 3, envir=new_env)  # Assign value to name
ls(new_env)  # List objects in "new_env"
new_env$myvar
rm(list=ls())  # Delete all objects
symbol <- "myvar"  # Define symbol containing string "myvar"
assign(symbol, 1)  # Assign value to "myvar"
ls()
myvar
assign("symbol", "new_var")
assign(symbol, 1)  # Assign value to "new_var"
ls()
symbol <- 10
assign(symbol, 1)  # Can't assign to non-string
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Applying \texttt{assign()} to Lists of Names}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      \texttt{assign()} allows creating new objects from listv or vectors of names (character strings), such as column names.
      \vskip1ex
    \column{0.5\textwidth}
      \vspace{-1em}
            <<echo=TRUE,eval=FALSE>>=
rm(list=ls())  # Delete all objects
# Create individual vectors from column names of EuStockMarkets
for (colname in colnames(EuStockMarkets)) {
# Assign column values to column names
  assign(colname, EuStockMarkets[, colname])
}  # end for
ls()
head(DAX)
head(EuStockMarkets[, "DAX"])
identical(DAX, EuStockMarkets[, "DAX"])
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Retrieving Objects Using \texttt{get()}}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      The function \texttt{get()} accepts a character string and returns the value of the corresponding object in a specified \emph{environment}.
      \vskip1ex
      \texttt{get()} retrieves objects that are referenced using character strings, instead of their names.
      \vskip1ex
      The functions \texttt{get()} and \texttt{assign()} allow retrieving and assigning values to objects that are referenced using character strings.
      \vskip1ex
      The function \texttt{mget()} accepts a vector of strings and returns a list of the corresponding objects.
    \column{0.5\textwidth}
      \vspace{-1em}
            <<echo=TRUE,eval=FALSE>>=
# Create new environment
test_env <- new.env()
# Pass string as name to create new object
assign("myvar1", 2, envir=test_env)
# Create new object using $ string referencing
test_env$myvar2 <- 1
# List objects in new environment
ls(test_env)
# Reference an object by name
test_env$myvar1
# Reference an object by string name using get
get("myvar1", envir=test_env)
# Retrieve and assign value to object
assign("myvar1",
       2*get("myvar1", envir=test_env),
       envir=test_env)
get("myvar1", envir=test_env)
# Return all objects in an environment
mget(ls(test_env), envir=test_env)
# Delete environment
rm(test_env)
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Metaprogramming in \texttt{R}}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      A powerful feature of \texttt{R} is \emph{non-standard evaluation} (aka \emph{metaprogramming} or \emph{programming on the language}).
      \vskip1ex
      Unevaluated \emph{expressions} are objects that represent \texttt{R} formulas and commands.
      \vskip1ex
      \emph{Metaprogramming} allows creating and manipulating unevaluated \texttt{R} \emph{expressions} and then executing them as needed.
      \vskip1ex
      The book \href{http://adv-r.had.co.nz/}{\emph{Advanced \texttt{R}}} by Hadley Wickham provides a good explanation of 
      \href{http://adv-r.had.co.nz/Computing-on-the-language.html}{\emph{metaprogramming} in \texttt{R}} and 
      \href{http://adv-r.had.co.nz/Expressions.html}{\texttt{R} \emph{expressions}}.
      \vskip1ex
      \texttt{R} interretsp character strings that are not in quotes "" as \emph{symbols} or \emph{expressions}.
      \vskip1ex
      The function \texttt{as.symbol()} converts a character string into a \emph{symbol} object.
      \vskip1ex
      The function \texttt{parse()} converts a character string into an unevaluated \emph{expression} object.
      \vskip1ex
      The function \texttt{eval()} evaluates a \emph{symbol} or \emph{expression} in a specified \emph{environment}.
    \column{0.5\textwidth}
      \vspace{-1em}
            <<echo=TRUE,eval=FALSE>>=
rm(list=ls())  # Delete all objects
# Convert string to symbol
as.symbol("some_string")
# The "name" class is synonymous with a symbol
class(as.symbol("some_string"))
# Symbols are created during assignments
symbol <- 2
# Evaluate symbol (same as typing it)
eval(symbol)
# Convert string into a symbol and evaluate it
eval(as.symbol("symbol"))
# Convert string into unevaluated expression
expv <- parse(text="newv <- symbol")
expv
class(expv)
ls()
eval(expv)  # Evaluate expression
ls()  # Expression evaluation created new object
newv
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Manipulating Symbols and Expressions}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      The function \texttt{quote()} accepts \emph{symbols} and \emph{expressions}, and returns an \emph{expression} object without evaluating it.
      \vskip1ex
      The function \texttt{quote()} creates unevaluated \emph{expression} objects which later can be evaluated by functions.
      \vskip1ex
      The function \texttt{substitute()} replaces objects in unevaluated expressions with their corresponding values, and returns an \emph{expression}.
      \vskip1ex
      \texttt{substitute()} looks up the object names in either named \texttt{listv} (symbol-value pairs) or in \texttt{environments}, and evaluates the objects in them.
      \vskip1ex
      \texttt{substitute()} is often used inside functions to substitute formal arguments with the names of the actual arguments they are bound to in a function call.
    \column{0.5\textwidth}
      \vspace{-1em}
            <<echo=TRUE,eval=FALSE>>=
# Create the expression "1+1"
quote(1+1)
# Evaluate the expression "1+1"
eval(quote(1+1))
# Create an expression containing several commands
expv <- quote({x <- 1; y <- 2; x+y})
expv
# Evaluate all the commands in the expression
eval(expv)
ls()
# Return an expression without evaluating it
newv <- 2*symbol
expv <- quote(symbol + newv)
expv
eval(expv)  # Evaluate expression
# Substitute objects in an expression
expv <- substitute(symbol + newv,
                          env=list(symbol=1, newv=2))
expv
eval(expv)  # Evaluate expression
# Get_input() substitutes its formal argument with the actual argument
get_input <- function(input) {
  substitute(input)
}  # end get_input
myvar <- 2
get_input(myvar)
eval(get_input(myvar))
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Converting Symbols and Expressions Into Strings}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      The function \texttt{deparse()} is the opposite of \texttt{parse()}, and it converts \emph{symbols} and \emph{expressions} into character strings.
      \vskip1ex
      The combination of functions \texttt{deparse(substitute())} returns a character string representing the actual argument passed into a function.
    \column{0.5\textwidth}
      \vspace{-1em}
            <<echo=TRUE,eval=FALSE>>=
# Define symbol
myvar <- 10
# Convert symbol value into string
deparse(myvar)
# Convert symbol into string without evaluating it
deparse(quote(myvar))
# Substitute object with value from named list
symbol <- 2
deparse(substitute(symbol + myvar,
                   env=list(myvar=2)))
# Create string with name of input argument
get_name <- function(input) {
  names(input) <- deparse(substitute(input))
  input
}  # end get_name
get_name(myvar)
      @
  \end{columns}
\end{block}

\end{frame}



%%%%%%%%%%%%%%%
\section{Control Structures}


%%%%%%%%%%%%%%%
\subsection{The Parenthesis \texttt{"()"} and Curly Braces \texttt{"\{\}"} Operators}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      The parenthesis \texttt{"()"} and curly braces \texttt{"\{\}"} operators are used to enclose and to group (combine) expressions.
      \vskip1ex
      The parenthesis \texttt{"()"} and curly braces \texttt{"\{\}"} operators are functions, and they return values.
      \vskip1ex
      An expression enclosed by the parenthesis \texttt{"()"} operator is evaluated separatately from other expressions, and its result is returned.
      \vskip1ex
      Enclosing expressions in parenthesis makes them less ambiguous.
      \vskip1ex
      The curly braces \texttt{"\{\}"} operator can group several expressions, that can be written either on separate lines, or be separated by the semicolon \texttt{";"} operator.
      \vskip1ex
      The curly braces \texttt{"\{\}"} operator returns the last expression it encloses.
      \vskip1ex
      Both the parenthesis \texttt{"()"} and curly braces \texttt{"\{\}"} operators are functions, and executing them requires a little additional processing time.
      \vskip1ex
      The square braces (brackets) \texttt{"[]"} operator subsets (references) the elements of vectors, matrices, and listv.
    \column{0.5\textwidth}
      \vspace{-1em}
        <<echo=(-(1:1))>>=
rm(list=ls())
# Expressions enclosed in parenthesis are less ambiguous
-2:5
(-2):5
-(2:5)
# Expressions enclosed in parenthesis are less ambiguous
-2*3+5
-2*(3+5)

# Expressions can be separated by semicolons or by lines
{1+2; 2*3; 1:5}
# or
{1+2
2*3
1:5}

matrixv <- matrix(nr=3, nc=4)
matrixv <- 0
# Subset whole matrix
matrixv[] <- 0

# Parenthesis and braces require a little additional processing time
library(microbenchmark)
summary(microbenchmark(
  basep=sqrt(rnorm(10000)^2),
  parven=sqrt(((((rnorm(10000)^2))))),
  bra_ce=sqrt({{{{rnorm(10000)^2}}}}),
  times=10))[, c(1, 4, 5)]  # end microbenchmark summary
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{The \texttt{"if () else"} Control Statement}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      \texttt{R} has the familiar \texttt{"if () \{...\} else \{...\}"} statement to control execution flow depending on logical conditions.
      \vskip1ex
      The logical conditions must be either a \texttt{Boolean} or \texttt{numeric} type, otherwise an error is produced.
      \vskip1ex
      The \texttt{"else"} statement can also be omitted.
      \vskip1ex
      \texttt{"if"} statements can be nested using multiple \texttt{"else if"} statements.
    \column{0.5\textwidth}
      \vspace{-1em}
        <<echo=(-(1:1))>>=
rm(list=ls())
numv1 <- 1

if (numv1) {  # Numeric zero is FALSE, all other numbers are TRUE
  numv2 <- 4
} else if (numv1 == 0) {  # 'else if' together on same line
  numv2 <- 0
} else {  # 'else' together with curly braces
  numv2 <- -4
}  # end if

numv2
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{The \texttt{switch()} Control Statement}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      The function \texttt{switch()} matches its first argument \texttt{"EXPR"} with one of the symbols in the following arguments, evaluates the corresponding expression, and returns it.
      \vskip1ex
      The arguments that follow the first argument \texttt{"EXPR"} should be given as \emph{symbol=value} pairs.
      \vskip1ex
      If \texttt{"EXPR"} is a character string, then the expression bound to that symbol is returned by \texttt{switch()}.
      \vskip1ex
      If \texttt{"EXPR"} is an integer, then \texttt{switch()} returns the expression from that position.
      \vskip1ex
      If \texttt{switch()} can't match \texttt{"EXPR"} to any symbol, then it returns \texttt{NULL} invisibly.
      \vskip1ex
      Using \texttt{switch()} is a convenient alternative to a cascade of \texttt{"if () else"} statements.
      \vskip1ex
      The function \texttt{match.arg()} matches a string to one of the possible values, and returns the matched value, or produces an \texttt{error} if it can't match it.
    \column{0.5\textwidth}
      \vspace{-1em}
        <<echo=TRUE>>=
switch("a", a="aaahh", b="bee", c="see", d=2,
       "else this")
switch("c", a="aaahh", b="bee", c="see", d=2,
       "else this")
switch(3, a="aaahh", b="bee", c="see", d=2,
       "else this")
switch("cc", a="aaahh", b="bee", c="see", d=2,
       "else this")
# Measure of central tendency
centra_lity <- function(input,
            method=c("mean", "mean_narm", "median")) {
# validate "method" argument
  method <- match.arg(method)
  switch(method,
         mean=mean(input),
         mean_narm=mean(input, na.rm=TRUE),
         median=median(input))
}  # end centra_lity
myvar <- rnorm(100, mean=2)
centra_lity(myvar, "mean")
centra_lity(myvar, "mean_narm")
centra_lity(myvar, "median")
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Iteration Using \texttt{for()} and \texttt{while()} Loops}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      The \texttt{for()} loop statement:
      \vspace{-1em}
      <<echo=TRUE,eval=FALSE>>=
for (indeks in vectorv) {expvs}
@
      \vspace{-1em}
      iterates the \emph{dummy} variable \texttt{in\_dex} over the elements of the vector or list \texttt{vec\_tor}, and evaluates in a loop the \texttt{ex\_pressions} contained in the body of the \texttt{for()} loop.
      \vskip1ex
      Upon loop exit the \emph{dummy} variable \texttt{in\_dex} is left equal to the last element of the vector \texttt{vec\_tor}.
      \vskip1ex
      \texttt{while()} loops start by testing their logical condition, and they repeat executing the loop body until that condition is \texttt{FALSE}.
      \vskip1ex
      But \texttt{while()} loops risk producing infinite loops if not written
properly, so \alert{Use Them With Care!}
    \column{0.5\textwidth}
      \vspace{-1em}
        <<echo=(-(1:1))>>=
rm(list=ls())
color_list <- list("red", "white", "blue")
# Loop over list
for (some_color in color_list) {
  print(some_color)
}  # end for
# Loop over vector
for (indeks in 1:3) {
  print(color_list[[indeks]])
}  # end for

# While loops require initialization
indeks <- 1
# While loop
while (indeks < 4) {
  print(color_list[[indeks]])
  indeks <- indeks + 1
}  # end while
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Performing Loops Using \texttt{for()} and \texttt{apply()}}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      The \texttt{for()} loop doesn't return a value, so values calculated in the \texttt{for()} loop body must be assigned to variables in the parent environment, or otherwise they are lost.
      \vskip1ex
      The expressions in the \texttt{for()} loop body have access to variables in the parent environment in which the \texttt{for()} loop is executed, and they can modify those variables.
      \vskip1ex
      So even though \texttt{for()} loops don't return a value, they can be used to perform calculations on variables in the parent environment, but this is discouraged since it can produce errors that are hard to debug.
      \vskip1ex
      {\color{red}{Rule of Thumb:}}\\
      \begin{itemize}
        \item \texttt{for()} loops are preferred for producing \emph{side effects}, like plotting or reading and writing data to files,
        \item \texttt{apply()} loops are preferred for performing calculations which produce vectors or matrices of values.
      \end{itemize}
    \column{0.5\textwidth}
      \vspace{-1em}
      <<echo=TRUE,eval=FALSE>>=
vectorv <- integer(7)
# Loop over a vector and overwrite it
for (i in seq_along(vectorv)) {
  cat("Changing element:", i, "\n")
  vectorv[i] <- i^2
}  # end for
# Modifying vectorv inside sapply() has no effect
vectorv <- integer(7)
vectorv
sapply(seq_along(vectorv), 
       function(i) {
         vectorv[i] <- i^2
       })  # end sapply
vectorv
# Super-assignment operator "<<-" allows modifying vectorv
sapply(seq_along(vectorv), 
       function(i) {
         vectorv[i] <<- i^2 # "<<-" !!!
       })  # end sapply
vectorv
# sapply() loop returns vector of values
vectorv <- sapply(seq_along(vectorv), 
                  function(i) (i^2))
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Fibonacci Sequence Using \texttt{for()} Loop}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      The \emph{Fibonacci} sequence of integers is defined by the recurrence relation:
      \begin{displaymath}
        F_n = F_{n-1} + F_{n-2},
      \end{displaymath}
      \begin{displaymath}
        F_1 = 0, F_2 = 1,
      \end{displaymath}
      \begin{displaymath}
        F_n = 0, 1, 1, 2, 3, 5, 8, 13, \ldots
      \end{displaymath}
      The \emph{Fibonacci} sequence was invented by the \emph{Indian} mathematician Virahanka in the 8th century AD, and later described by the Italian mathematician \emph{Fibonacci} in his famous treatise \emph{Liber Abaci}.
      \vskip1ex
      Very often variables are initialized to \texttt{NULL} before the start of iteration.
      \vskip1ex
      A more efficicent way to perform iteration is by pre-allocating the vector.
      \vskip1ex
      The function \texttt{numeric()} returns an zero length \texttt{numeric} vector.
      \vskip1ex
      The function \texttt{numeric(k)} returns a \texttt{numeric} vector of zeros of length \texttt{k}.
    \column{0.5\textwidth}
      \vspace{-1em}
        <<echo=(-(1:1))>>=
rm(list=ls())
# fib_seq <- numeric()  # zero length numeric vector
# Pre-allocate vector instead of "growing" it
fib_seq <- numeric(10)
fib_seq[1] <- 0  # Initialize
fib_seq[2] <- 1  # Initialize
for (i in 3:10) {  # Perform recurrence loop
  fib_seq[i] <- fib_seq[i-1] + fib_seq[i-2]
}  # end for
fib_seq
      @
  \end{columns}
\end{block}

\end{frame}



%%%%%%%%%%%%%%%
\section{Manipulating Vectors and Matrices}


%%%%%%%%%%%%%%%
\subsection{Allocating Memory to Vectors and Matrices}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      \texttt{R} automatically allocates memory to new objects as needed during runtime, but at the cost of slowing down calculations.
      \vskip1ex
      Allocating memory of the correct \emph{mode} speeds up calculations by avoiding automatic memory allocation by \texttt{R}.
      \vskip1ex
      The functions \texttt{character()}, \texttt{integer()}, and \texttt{numeric()} return zero-length vectors of the specified \emph{mode}.
      \vskip1ex
      Zero length vectors are not the same as \texttt{NULL} objects.
      \vskip1ex
      The function \texttt{character(k)} returns a \texttt{character} vector of empty strings of length \texttt{k}.
      \vskip1ex
      The function \texttt{integer(k)} returns a \texttt{integer} vector of zeros of length \texttt{k}.
      \vskip1ex
      The function \texttt{numeric(k)} returns a \texttt{numeric} vector of zeros of length \texttt{k}.
      \vskip1ex
      The function \texttt{vector()} by default returns a \texttt{Boolean} vector, unless the \emph{mode} is specified.
      \vskip1ex
      The function \texttt{matrix()} by default returns a \texttt{Boolean} matrix containing \texttt{NA} values, unless the \emph{mode} is specified.
    \column{0.5\textwidth}
      \vspace{-1em}
        <<echo=TRUE>>=
# Allocate character vector
character()
character(5)
is.character(character(5))
# Allocate integer vector
integer()
integer(5)
is.integer(integer(5))
is.numeric(integer(5))
# Allocate numeric vector
numeric()
numeric(5)
is.integer(numeric(5))
is.numeric(numeric(5))
# Allocate Boolean vector
vector()
vector(length=5)
# Allocate numeric vector
vector(length=5, mode="numeric")
is.null(vector())
# Allocate Boolean matrix
matrix()
is.null(matrix())
# Allocate integer matrix
matrix(NA_integer_, nrow=3, ncol=2)
is.integer(matrix(NA_integer_, nrow=3, ncol=2))
# Allocate numeric matrix
matrix(NA_real_, nrow=3, ncol=2)
is.numeric(matrix(NA_real_, nrow=3, ncol=2))
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Logical Operators Applied to Vectors and Matrices}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      When logical operators are applied to vectors and matrices, they are applied element-wise, producing \texttt{Boolean} vectors and matrices.
    \column{0.5\textwidth}
      \vspace{-1em}
        <<echo=TRUE>>=
vectorv <- sample(1:9)
vectorv
vectorv < 5  # Element-wise comparison
vectorv == 5  # Element-wise comparison
matrixv <- matrix(vectorv, ncol=3)
matrixv
matrixv < 5  # Element-wise comparison
matrixv == 5  # Element-wise comparison
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Coercing Vectors Into Matrices}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      Vectors can be coerced into matrices by adding a dimension attribute.
      \vskip1ex
      The \texttt{dimnames} attribute can be assigned a named list to convert it into a named matrix.
      \vskip1ex
      The function \texttt{structure()} adds attributes (specified as \texttt{symbol=value} pairs) to an object, and returns it.
    \column{0.5\textwidth}
      \vspace{-1em}
            <<echo=TRUE,eval=FALSE>>=
matrixv <- 1:6  # Create a vector
class(matrixv)  # Get its class
# Is it vector or matrix?
c(is.vector(matrixv), is.matrix(matrixv))
structure(matrixv, dim=c(2, 3))  # Matrix object
# Adding dimension attribute coerces into matrix
dim(matrixv) <- c(2, 3)
class(matrixv)  # Get its class
# Is it vector or matrix?
c(is.vector(matrixv), is.matrix(matrixv))
# Assign dimnames attribute
dimnames(matrixv) <- list(rows=c("row1", "row2"),
                        columns=c("col1", "col2", "col3"))
matrixv
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Coercing Matrices Into Other Types}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      Matrices can be explicitly coerced using the \texttt{"as.*"} coercion functions.
      \vskip1ex
      But coercion functions strip the \emph{attributes} from an object.
    \column{0.5\textwidth}
      \vspace{-1em}
            <<echo=TRUE,eval=FALSE>>=
matrixv <- matrix(1:10, 2, 5)  # Create matrix
matrixv
# as.numeric strips dim attribute from matrix
as.numeric(matrixv)
# Explicitly coerce to "character"
matrixv <- as.character(matrixv)
c(typeof(matrixv), mode(matrixv), class(matrixv))
# Coercion converted matrix to vector
c(is.matrix(matrixv), is.vector(matrixv))
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Binding Vectors and Matrices Together}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      Vectors can be bound into matrices using the functions \texttt{cbind()} and \texttt{rbind()}.
      \vskip1ex
      The \emph{recycling rule} allows operations on vectors of different lengths:\\
      \begin{enumerate}
        \item Vectors are scanned from left to right,
        \item Shorter vectors are extended in length by recycling their values until they match the length of longer vectors,
      \end{enumerate}
    \column{0.5\textwidth}
      \vspace{-1em}
            <<echo=TRUE,eval=FALSE>>=
vector1 <- 1:3  # Define vector
vector2 <- 6:4  # Define vector
# Bind vectors into columns
cbind(vector1, vector2)
# Bind vectors into rows
rbind(vector1, vector2)
# Extend to four elements
vector2 <- c(vector2, 7)
# Recycling rule applied
cbind(vector1, vector2)
# Another example of recycling rule
1:6 + c(10, 20)
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Replicating Objects Using \texttt{rep()}}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      The function \texttt{rep()} replicates vectors and listv a given number of times.
      \vskip1ex
      \texttt{rep()} accepts a vector or list \texttt{"x"}, and an integer specifying the type and number of replications.
      \vskip1ex
      Argument \texttt{"times"} replicates the whole vector a given number of times.
      \vskip1ex
      Argument \texttt{"each"} replicates each vector element a given number of times.
      \vskip1ex
      Argument \texttt{"length.out"} replicates the whole vector a certain number of times, so that the output vector length is equal to \texttt{"length.out"}.
    \column{0.5\textwidth}
      \vspace{-1em}
            <<echo=TRUE,eval=FALSE>>=
# Replicate a single element
rep("a", 5)
# Replicate the whole vector several times
rep(c("a", "b"), 5)
rep(c("a", "b"), times=5)
# Replicate the first element, then the second, etc.
rep(c("a", "b"), each=5)
# Replicate to specified length
rep(c("a", "b"), length.out=5)
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Multiplying Vectors and Matrices}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      The multiplication \texttt{"*"} \emph{operator} performs \emph{element-wise} (\emph{element-by-element}) multiplication of vectors and matrices.
      \vskip1ex
      By default the matrix elements are multiplied column-wise by the vector elements: the first matrix element in the first column is multiplied by the first vector element, then the second matrix column is multiplied by the remaining vector elements, etc.
      \vskip1ex
      The \emph{recycling rule} is applied to the vector elements as needed.
      \vskip1ex
      The transpose function \texttt{t()} can be applied if we want to perform row-wise multiplication.
      \vskip1ex
      But the transpose function \texttt{t()} is very slow for large matrices.
      \vskip1ex
      A better choice is to use functions \texttt{lapply()} and \texttt{do.call()}.
     \column{0.5\textwidth}
      \vspace{-1em}
      <<echo=TRUE>>=
# Define vector and matrix
vector1 <- c(2, 4, 3)
matrixv <- matrix(sample(1:12), ncol=3)
# Multiply columns of matrix by vector
vector1*matrixv
# Or
matrixv*vector1
# Multiply rows of matrix by vector
t(vector1*t(matrixv))
# Multiply rows of matrix by vector - transpose is very slow
product <- lapply(1:NCOL(matrixv), 
  function(x) vector1[x]*matrixv[, x])
do.call(cbind, product)
library(microbenchmark)
summary(microbenchmark(
  trans=t(vector1*t(matrixv)),
  lapp={
    product <- lapply(1:NCOL(matrixv), function(x) vector1[x]*matrixv[, x])
    do.call(cbind, product)
  },
  times=10))[, c(1, 4, 5)]  # end microbenchmark summary
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Matrix Inner Multiplication}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      The \texttt{\%*\%} operator performs \emph{inner} (\emph{scalar}) multiplication of vectors and matrices.
      \vskip1ex
      \emph{Inner} multiplication multiplies the rows of one matrix with the columns of another matrix, so that each pair produces a single number:
      \begin{displaymath}
        C_{i,j} = \sum_{k=1}^n A_{i,k} B_{k,j}
      \end{displaymath}
      \emph{Inner} multiplication produces a vector or matrix with a reduced dimension.
      \vskip1ex
      \emph{Inner} multiplication requires the dimensions of the matrices to be \emph{conformable} (number of columns in the first matrix must be equal to the number of rows in the second).
      \vskip1ex
      The function \texttt{drop()} removes any dimensions of length \emph{one}.
      \vskip1ex
      The functions \texttt{rowSums()} and \texttt{colSums()} calculate the sums of rows and columns, and they're very fast because they pass their data to compiled \texttt{C++} code.
    \column{0.5\textwidth}
      \vspace{-1em}
      <<echo=(-(1:1))>>=
vector1
vector2 <- 6:4  # Define vector
# Multiply two vectors element-by-element
vector1 * vector2
# Calculate inner product
vector1 %*% vector2
# Calculate inner product and drop dimensions
drop(vector1 %*% vector2)
# Multiply columns of matrix by vector
matrixv %*% vector1  # Single column matrix
drop(matrixv %*% vector1)  # vector
rowSums(t(vector1 * t(matrixv)))
# using rowSums() and t() is 10 times slower than %*%
library(microbenchmark)
summary(microbenchmark(
  inner=drop(matrixv %*% vector1),
  transp=rowSums(t(vector1 * t(matrixv))),
  times=10))[, c(1, 4, 5)]  # end microbenchmark summary
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Matrix Transpose}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      The function \texttt{t()} returns the transpose of a matrix.
      \vskip1ex
      The function \texttt{crossprod()} also performs \emph{inner} (\emph{scalar}) multiplication, exactly the same as the \texttt{\%*\%} operator, but is slightly faster.
    \column{0.5\textwidth}
      \vspace{-1em}
      <<echo=(-(1:1)),eval=FALSE>>=
library(microbenchmark)
# Multiply matrix by vector fails because dimensions aren't conformable
vector1 %*% matrixv
# Works after transpose
drop(vector1 %*% t(matrixv))
# Calculate inner product
crossprod(vector1, vector2)
# Create matrix and vector
matrixv <- matrix(1:3000, ncol=3)
tmatrixv <- t(matrixv)
vectorv <- 1:3
# crossprod() is slightly faster than "%*%" operator
summary(microbenchmark(
  cross_prod=crossprod(tmatrixv, vectorv),
  inner_prod=matrixv %*% vectorv,
  times=10))[, c(1, 4, 5)]  # end microbenchmark summary
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Matrix Outer Multiplication}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      An \emph{outer} product consists of all possible products of pairs of elements of two objects:
      \begin{displaymath}
        C_{i,j} = A_i \cdot B_j
      \end{displaymath}
      An \emph{outer} product of a function consists of applying it to all possible pairs of elements of two objects:
      \begin{displaymath}
        C_{i,j} = f(A_i, B_j)
      \end{displaymath}
      \emph{Outer} multiplication produces an object with dimension equal to the sum of the factors' dimensions, and with the number of elements equal to the product of the factors' elements.
      \vskip1ex
      The function \texttt{outer()} calculates the \emph{outer} product of two matrices, and by default multiplies the elements of its arguments.
      \vskip1ex
      \texttt{outer()} can also calculate the values of a vectorized function of two variables passed to the \texttt{"FUN"} argument.
    \column{0.5\textwidth}
      \vspace{-1em}
      <<echo=TRUE>>=
# Define named vectors
vector1 <- sample(1:4)
names(vector1) <- paste0("row", 1:4, "=", vector1)
vector1
vector2 <- sample(1:3)
names(vector2) <- paste0("col", 1:3, "=", vector2)
vector2
# Calculate outer product of two vectors
matrixv <- outer(vector1, vector2)
matrixv
# Calculate vectorized function spanned over two vectors
matrixv <- outer(vector1, vector2,
                 FUN=function(x1, x2) x2*sin(x1))
matrixv
      @
  \end{columns}
\end{block}

\end{frame}



%%%%%%%%%%%%%%%
\section{Manipulating Lists and Data Frames}


%%%%%%%%%%%%%%%
\subsection{Flattening a List of Vectors to a Matrix Using \texttt{do.call()}}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      A list of vectors can be flattened into a matrix using the functions \texttt{do.call()} and either \texttt{rbind()} or \texttt{cbind()}.
      \vskip1ex
      If the list contains vectors of different lengths, then \texttt{R} applies the recycling rule.
      \vskip1ex
      If the list contains a \texttt{NULL} element, that element is skipped.
    \column{0.5\textwidth}
      \vspace{-1em}
      <<echo=TRUE,eval=FALSE>>=
# Create list of vectors
listv <- lapply(1:3, function(x) sample(6))
# Bind list elements into matrix - doesn't work
rbind(listv)
# Bind list elements into matrix - tedious
rbind(listv[[1]], listv[[2]], listv[[3]])
# Bind list elements into matrix - works!
do.call(rbind, listv)
# Create numeric list
listv <- list(1, 2, 3, 4)
do.call(rbind, listv)  # Returns single column matrix
do.call(cbind, listv)  # Returns single row matrix
# Recycling rule applied
do.call(cbind, list(1:2, 3:5))
# NULL element is skipped
do.call(cbind, list(1, NULL, 3, 4))
# NA element isn't skipped
do.call(cbind, list(1, NA, 3, 4))
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Efficient Binding of Lists Into Matrices}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      A list of vectors can be flattened into a matrix using the functions \texttt{do.call()} and either \texttt{rbind()} or \texttt{cbind()}.
      \vskip1ex
      But for large vectors this procedure can be very slow, and often causes an out of memory error.
      \vskip1ex
      The function \texttt{do\_call\_rbind()} efficiently combines a list of vectors into a matrix.
      \vskip1ex
      \texttt{do\_call\_rbind()} produces the same result as \texttt{do.call(rbind, list\_var)}, but using recursion.
      \vskip1ex
      \texttt{do\_call\_rbind()} calls lapply in a loop, each time binding neighboring list elements and dividing the length of the list by half.
      \vskip1ex
      \texttt{do\_call\_rbind()} is the same function as \texttt{do.call.rbind()} from package \emph{qmao}:\\
\hskip1em\url{https://r-forge.r-project.org/R/?group_id=1113}
    \column{0.5\textwidth}
      \vspace{-1em}
      <<echo=(-(1:1)), eval=FALSE>>=
library(microbenchmark)
list_vectors <- lapply(1:5, rnorm, n=10)
matrixv <- do.call(rbind, list_vectors)
dim(matrixv)
do_call_rbind <- function(listv) {
  while (NROW(listv) > 1) {
# Index of odd list elements
    odd_index <- seq(from=1, to=NROW(listv), by=2)
# Bind odd and even elements, and divide listv by half
    listv <- lapply(odd_index, function(indeks) {
      if (indeks==NROW(listv)) return(listv[[indeks]])
      rbind(listv[[indeks]], listv[[indeks+1]])
    })  # end lapply
  }  # end while
# listv has only one element - return it
  listv[[1]]
}  # end do_call_rbind
identical(matrixv, do_call_rbind(list_vectors))
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Filtering Data Frames Using \texttt{subset()}}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      \emph{Filtering} means extracting rows from a \emph{data frame} that satisfy a logical condition.
      \vskip1ex
      \emph{Data frames} can be filtered using Boolean vectors and brackets \texttt{"[]"} operators.
      \vskip1ex
      The function \texttt{subset()} filters \emph{data frames}, by applying logical conditions to its columns, using the column names.
      \vskip1ex
      \texttt{subset()} provides a succinct notation and discards \texttt{NA} values, but it's slightly slower than using \texttt{Boolean} vectors and brackets \texttt{"[]"} operators.
    \column{0.5\textwidth}
      \vspace{-1em}
      <<echo=(-(1:1)), eval=FALSE>>=
library(microbenchmark)
airquality[(airquality$Solar.R > 320 &
              !is.na(airquality$Solar.R)), ]
subset(x=airquality, subset=(Solar.R > 320))
summary(microbenchmark(
    subset=subset(x=airquality, subset=(Solar.R > 320)),
    brackets=airquality[(airquality$Solar.R > 320 &
                  !is.na(airquality$Solar.R)), ],
times=10))[, c(1, 4, 5)]  # end microbenchmark summary
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Splitting Data Frames Using \texttt{factor} Categorical Variables}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      The function \texttt{split()} divides an object into a list of objects, according to a \texttt{factor} (categorical variable).
      \vskip1ex
      The list's \texttt{namesv} attribute is equal to the \texttt{factor} levels.
    \column{0.5\textwidth}
      \vspace{-1em}
      <<echo=TRUE,eval=FALSE>>=
unique(iris$Species)  # Species has three distinct values
# Split into separate data frames by hand
setosa <- iris[iris$Species=="setosa", ]
versi <- iris[iris$Species=="versicolor", ]
virgin <- iris[iris$Species=="virginica", ]
dim(setosa)
head(setosa, 2)
# Split iris into list based on Species
split_iris <- split(iris, iris$Species)
str(split_iris, max.confl=1)
names(split_iris)
dim(split_iris$setosa)
head(split_iris$setosa, 2)
all.equal(setosa, split_iris$setosa)
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{The \protect\emph{split-apply-combine} Procedure}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      The \emph{split-apply-combine} procedure consists of:
      \begin{itemize}
        \item dividing an object into a list, according to a factor (attribute).
        \item applying a function to each list element.
        \item combining the results.
      \end{itemize}
      The \emph{split-apply-combine} procedure is also called the \emph{map-reduce} procedure, or simply \emph{data pivoting}, and it's similar to \emph{pivot tables} in \emph{Excel}.
      \vskip1ex
      \emph{Data pivoting} can be performed \emph{data frames}, by aggregating its columns based on categorical data stored in one of its columns.
      \vskip1ex
      You can read more about the \emph{split-apply-combine} procedure in Hadley Wickham's paper:\\
      \url{http://www.jstatsoft.org/v40/i01/paper}
      \vskip1ex
    \column{0.5\textwidth}
      \hskip1em\includegraphics[width=0.45\paperwidth]{figure/split_apply_combine_procedure.png}
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{\protect\emph{Data Pivoting} Example}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      \emph{Data pivoting} can be performed through successive applications of functions \texttt{split()}, \texttt{apply()}, and \texttt{unlist()}.
      \vskip1ex
      A \emph{data frame} can be \emph{pivoted} either by first splitting it into a list of \emph{data frames} and then aggregating, or by splitting just a single column and aggregating it.
      \vskip1ex
      The function \texttt{split()} divides an object into a list of objects, according to a \texttt{factor} (categorical variable).
      \vskip1ex
      The list's \texttt{namesv} attribute is equal to the \texttt{factor} levels.
      \vskip1ex
      The functional \texttt{aggregate()} \emph{pivots} the columns of a \emph{data frame}.
      \vskip1ex
      \texttt{aggregate()} can accept a \texttt{"formula"} argument with the column names, or it can accept \texttt{"x"} and \texttt{"by"} arguments with the columns.
      \vskip1ex
      \texttt{aggregate()} returns a \emph{data frame} containing the names of the groups (\texttt{factor} confls).
    \column{0.5\textwidth}
      \vspace{-1em}
      <<echo=TRUE,eval=FALSE>>=
unique(mtcars$cyl)  # cyl has three unique values
# Split mpg column based on number of cylinders
split(mtcars$mpg, mtcars$cyl)
# Split mtcars data frame based on number of cylinders
split_cars <- split(mtcars, mtcars$cyl)
str(split_cars, max.confl=1)
names(split_cars)
# Aggregate the mean mpg over split mtcars data frame
sapply(split_cars, function(x) mean(x$mpg))
# Or: split mpg column and aggregate the mean
sapply(split(mtcars$mpg, mtcars$cyl), mean)
# Same but using with()
with(mtcars, sapply(split(mpg, cyl), mean))
# Or: aggregate() using formula syntax
aggregate(formula=(mpg ~ cyl), data=mtcars, FUN=mean)
# Or: aggregate() using data frame syntax
aggregate(x=mtcars$mpg, by=list(cyl=mtcars$cyl), FUN=mean)
# Or: using name for mpg
aggregate(x=list(mpg=mtcars$mpg), by=list(cyl=mtcars$cyl), FUN=mean)
# Aggregate() all columns
aggregate(x=mtcars, by=list(cyl=mtcars$cyl), FUN=mean)
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{The \texttt{tapply()} Functional}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      The functional \texttt{tapply()} is a specialized version of the \texttt{apply()} functional, that applies a function to elements of a \emph{jagged array}.
      \vskip1ex
      A \emph{jagged array} is a list consisting of vectors or matrices of different lengths.
      \vskip1ex
      \texttt{tapply()} accepts a vector of values \texttt{"X"}, a factor \texttt{"INDEX"}, and a function \texttt{"FUN"}.
      \vskip1ex
      \texttt{tapply()} first groups the elements of \texttt{"X"} according to the factor \texttt{"INDEX"}, transforming it into a \emph{jagged array}, and then applies \texttt{"FUN"} to each element of the \emph{jagged array}.
      \vskip1ex
      \texttt{tapply()} applies a function to sub-vectors aggregated using a factor, and performs \emph{data pivoting} in a single function call.
      \vskip1ex
      The \texttt{by()} function is a wrapper for \texttt{tapply()}.
      \vskip1ex
      The \texttt{with()} function evaluates an expression in an environment constructed from the data.
    \column{0.5\textwidth}
      \vspace{-1em}
      <<echo=TRUE,eval=FALSE>>=
# Mean mpg for each cylinder group
tapply(X=mtcars$mpg, INDEX=mtcars$cyl, FUN=mean)
# using with() environment
with(mtcars, tapply(X=mpg, INDEX=cyl, FUN=mean))
# Function sapply() instead of tapply()
with(mtcars, sapply(sort(unique(cyl)), function(x) {
       structure(mean(mpg[x==cyl]), names=x)
     }))  # end with
# Function by() instead of tapply()
with(mtcars, by(data=mpg, INDICES=cyl, FUN=mean))
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{\protect\emph{Data Pivoting} Returning a Matrix}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      Sometimes \emph{data pivoting} returns a list of vectors.
      \vskip1ex
      A list of vectors can be flattened into a matrix using the functions \texttt{do.call()} and either \texttt{rbind()} or \texttt{cbind()}.
      \vskip1ex
     The function \texttt{do.call()} executes a function call using a function name and a list of arguments.
      \vskip1ex
      \texttt{do.call()} passes the list elements individually, instead of passing the whole list as one argument:\\
      \texttt{do.call(fun, list)=
      fun(list[[1]], list[[2]], \ldots)}
    \column{0.5\textwidth}
      \vspace{-1em}
      <<echo=TRUE,eval=FALSE>>=
# Get several mpg stats for each cylinder group
data_cars <- sapply(split_cars,
              function(x) {
                c(mean=mean(x$mpg), max=max(x$mpg), min=min(x$mpg))
              }  # end anonymous function
              )  # end sapply
data_cars  # sapply() produces a matrix
data_cars <- lapply(split_cars,  # Now same using lapply
              function(x) {
                c(mean=mean(x$mpg), max=max(x$mpg), min=min(x$mpg))
              }  # end anonymous function
              )  # end sapply
is.list(data_cars)  # lapply produces a list
# do.call flattens list into a matrix
do.call(cbind, data_cars)
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{\protect\emph{Data Pivoting} of Panel Data}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      The \emph{data frame} \texttt{panel\_data} contains fundamental financial data for \emph{S\&P500} stocks.
      \vskip1ex
      The \texttt{Industry} column has \texttt{22} unique elements, while the \texttt{Sector} column has \texttt{10} unique elements.
      \vskip1ex
      Each \texttt{Industry} belongs to a single \texttt{Sector}, but each \texttt{Sector} may have several \texttt{Industries} that belong to it.
      \vskip1ex
      The functional \texttt{aggregate()} allows aggregating over the \texttt{Industry} column, by perforing \emph{data pivoting}.
    \column{0.5\textwidth}
      \vspace{-1em}
      <<echo=TRUE,eval=FALSE>>=
# Download CRSPpanel.txt from Brightspace
# Read the file using read.table() with header and sep arguments
panel_data <- read.table(file="/Users/jerzy/Develop/lecture_slides/data/CRSPpanel.txt", 
                         header=TRUE, sep="\t")
# Split panel_data based on Industry column
split_panel <- split(panel_data, panel_data$Industry)
# Number of companies in each Industry
sapply(split_panel, NROW)
# Number of Sectors that each Industry belongs to
sapply(split_panel, function(x) {
  NROW(unique(x$Sector))
})  # end sapply
# Or
aggregate(formula=(Sector ~ Industry), 
  data=panel_data, FUN=function(x) NROW(unique(x)))
# Industries and the Sector to which they belong
aggregate(formula=(Sector ~ Industry), data=panel_data, 
          FUN=unique)
# Or
with(panel_data, aggregate(x=Sector, by=list(Industry), 
                           FUN=unique))
# Or
with(panel_data, sapply(unique(Industry), 
  function(x) {
    Sector[match(x, Industry)]
  }))  # end sapply
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{\protect\emph{Data Pivoting} Returning a \protect\emph{Jagged Array}}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      A \emph{jagged array} is a list consisting of vectors or matrices of different lengths.
      \vskip1ex
      The functional \texttt{aggregate()} returns a \emph{data frame}, so it's output must be coerced if the \emph{data pivoting} attempts to return a \emph{jagged array}.
      \vskip1ex
      The functional \texttt{tapply()} returns an array, so it's output must be coerced if the \emph{data pivoting} attempts to return a \emph{jagged array}.
      \vskip1ex
      \texttt{tapply()} accepts a vector of values \texttt{"X"}, a factor \texttt{"INDEX"}, and a function \texttt{"FUN"}.
      \vskip1ex
      \texttt{tapply()} first groups the elements of \texttt{"X"} according to the factor \texttt{"INDEX"}, transforming it into a \emph{jagged array}, and then applies \texttt{"FUN"} to each element of the \emph{jagged array}.
      \vskip1ex
      \texttt{tapply()} applies a function to sub-vectors aggregated using a factor, and performs \emph{data pivoting} in a single function call.
    \column{0.5\textwidth}
      \vspace{-1em}
      <<echo=TRUE,eval=FALSE>>=
# Split panel_data based on Sector column
split_panel <- split(panel_data, panel_data$Sector)
# Number of companies in each Sector
sapply(split_panel, NROW)
# Industries belonging to each Sector (jagged array)
sec_ind <- sapply(split_panel, 
  function(x) unique(as.vector(x$Industry)))
# Or use aggregate() (returns a data frame)
sec_ind2 <- aggregate(formula=(Industry ~ Sector), 
  data=panel_data, FUN=function(x) unique(as.vector(x)))
# Or use aggregate() with "by" argument
sec_ind2 <- with(panel_data, 
  aggregate(x=Industry, by=list(Sector), 
    FUN=function(x) as.vector(unique(x))))
# Coerce sec_ind2 into a jagged array
namesv <- as.vector(sec_ind2[, 1])
sec_ind2 <- sec_ind2[, 2]
names(sec_ind2) <- namesv
all.equal(sec_ind2, sec_ind)
# Or use tapply() (returns an array)
sec_ind2 <- with(panel_data, 
  tapply(X=as.vector(Industry), INDEX=Sector, FUN=unique))
# Coerce sec_ind2 into a jagged array
sec_ind2 <- drop(as.matrix(sec_ind2))
all.equal(sec_ind2, sec_ind)
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{\protect\emph{Data Pivoting} Over Multiple Columns}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      \emph{Data pivoting} over multiple columns can be performed by splitting the \emph{data frame} and then performing an sapply() loop using an anonymous function.
      \vskip1ex
      Splitting the \emph{data frame} allows aggregations over multiple columns.
      \vskip1ex
      An anonymous function allows applying different aggregations on the same column.
    \column{0.5\textwidth}
      \vspace{-1em}
      <<echo=TRUE,eval=FALSE>>=
# Average ROE in each Industry
with(panel_data, 
  sapply(split(ROE, Industry), mean))
# Average, min, and max ROE in each Industry
t(with(panel_data, 
  sapply(split(ROE, Industry), FUN=function(x) 
      c(mean=mean(x), max=max(x), min=min(x)))  # end sapply
  ))  # end with
# Split panel_data based on Industry column
split_panel <- split(panel_data, panel_data$Industry)
# Average ROE and EPS in each Industry
t(sapply(split_panel, FUN=function(x) 
  c(mean_roe=mean(x$ROE), 
    mean_eps=mean(x$EPS.EXCLUDE.EI))))
# Or: split panel_data based on Industry column
split_panel <- split(panel_data[, c("ROE", "EPS.EXCLUDE.EI")], 
  panel_data$Industry)
# Average ROE and EPS in each Industry
t(sapply(split_panel, FUN=function(x) sapply(x, mean)))
# Average ROE and EPS using aggregate()
aggregate(x=panel_data[, c("ROE", "EPS.EXCLUDE.EI")], 
  by=list(panel_data$Industry), FUN=mean)
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{draft: Compare \texttt{for()} Loops With \protect\emph{split-apply-combine} Procedure}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.3\textwidth}
      from: Wickham Split Apply Combine for Data Analysis
      \vskip1ex
      The \emph{split-apply-combine} procedure allows for analyzing \emph{data frames}, by spliting an analysis into smaller steps, and then combining them together.
      \vskip1ex
      in data preparation, for performing group-wise ranking, standardization, or normalization.
      \vskip1ex
      creating summaries (aggregations) of data by groups.
      \vskip1ex
      During modeling, for fitting separate models to individual panels of data.
      \vskip1ex
      The \emph{split-apply-combine} procedure is similar to the \emph{map-reduce} procedure for processing large data.
      \vskip1ex
      also similar to \emph{pivot tables} in \emph{Excel}.
      \vskip1ex
      The \texttt{split()}, \texttt{apply()} and \texttt{combine} Procedure
      \vskip1ex
      The \texttt{lapply()} and \texttt{sapply()} functions are specialized versions of the \texttt{apply()} function.
      \vskip1ex
      The \texttt{lapply()} function applies a function to a list of objects and returns a list.
      \vskip1ex
      The \texttt{sapply()} function applies a function to a list or vector of objects and returns a vector.
    \column{0.7\textwidth}
      \vspace{-1em}
      <<echo=TRUE,eval=FALSE>>=
library(plyr)
one <- ozone[1, 1, ]
month <- ordered(rep(1:12, length72))
model <- rlm(one ~ month - 1)
deseas <- resid(model)
deseasf <- function(value) rlm(value ~ month - 1)

# For loops
models <- as.list(rep(NA, 24 * 24))
dim(models) <- c(24, 24)
deseas <- array(NA, c(24, 24, 72))
dimnames(deseas) <- dimnames(ozone)
for (i in seq_len(24)) {
for (j in seq_len(24)) {
mod <- deseasf(ozone[i, j, ])
models[[i, j]] <- mod
deseas[i, j, ] <- resid(mod)
}
}

# Apply functions
models <- apply(ozone, 1:2, deseasf)
resids_list <- lapply(models, resid)
resids <- unlist(resids_list)
dim(resids) <- c(72, 24, 24)
deseas <- aperm(resids, c(2, 3, 1))
dimnames(deseas) <- dimnames(ozone)

      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{draft: Examples of \protect\emph{split-apply-combine} Procedure}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.3\textwidth}
      from:
      http://4dpiecharts.com/2011/12/16/a-quick-primer-on-split-apply-combine-problems/
      \vskip1ex
      we have a \emph{data frame} with one column containing the values to calculate a statistic for and another column containing the group to which that value belongs
    \column{0.7\textwidth}
      \vspace{-1em}
      <<echo=TRUE,eval=FALSE>>=
# InsectSprays dataset
head(InsectSprays)

# Split the count column by the spray column.
count_by_spray <- with(InsectSprays, split(count, spray))

# Next apply the statistic to each element of the list. Lets use the mean here.
mean_by_spray <- lapply(count_by_spray, mean)

# Finally combine the list as a vector
unlist(mean_by_spray)

# or in one line
sapply(count_by_spray, mean)

# Can also use the functions tapply(), aggregate() and by():
with(InsectSprays, tapply(count, spray, mean))
with(InsectSprays, by(count, spray, mean))
aggregate(count ~ spray, InsectSprays, mean)
      @
  \end{columns}
\end{block}

\end{frame}



%%%%%%%%%%%%%%%
\section{Debugging and Exception Handling}


%%%%%%%%%%%%%%%
\subsection{Exception Conditions: Errors and Warnings}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      \emph{Exception conditions} are \texttt{R} objects containing information about \emph{errors} or \emph{warnings} produced while evaluating expressions.
      \vskip1ex
      The function \texttt{warning()} produces a \emph{warning} condition, but doesn't halt function execution, and returns its message to the warning handler.
      \vskip1ex
      The function \texttt{stop()} produces an \emph{error} condition, halts function execution, and returns its message to the error handler.
      \vskip1ex
      The handling of \emph{warning} conditions depends on the value of \texttt{options("warn")}:
      \begin{itemize}
        \item \emph{negative} then warnings are ignored,
        \item \emph{zero} then warnings are stored and printed after the top-confl function has completed,
        \item \emph{one} - warnings are printed as they occur,
        \item \emph{two} or larger - warnings are turned into errors,
      \end{itemize}
      The function \texttt{suppressWarnings()} evaluates its expressions and ignores all warnings.
    \column{0.5\textwidth}
      \vspace{-1em}
      <<echo=TRUE,eval=FALSE>>=
# ?options  # Get info on global options
getOption("warn")  # Global option for "warn"
options("warn")  # Global option for "warn"
getOption("error")  # Global option for "error"
sqrt_safe <- function(input) {
# Returns its argument
  if (input<0) {
    warning("sqrt_safe: input is negative")
    NULL  # Return NULL for negative argument
  } else {
    sqrt(input)
  }  # end if
}  # end sqrt_safe
sqrt_safe(5)
sqrt_safe(-1)
options(warn=-1)
sqrt_safe(-1)
options(warn=0)
sqrt_safe()
options(warn=1)
sqrt_safe()
options(warn=3)
sqrt_safe()
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Validating Function Arguments}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      Argument validation consists of first determining if any arguments are \emph{missing}, and then determining if the arguments are of the correct \emph{type}.
      \vskip1ex
      An argument is \emph{missing} when the formal argument is not bound to an actual value in the function call.
      \vskip1ex
      The function \texttt{missing()} returns \texttt{TRUE} if an argument is missing, and \texttt{FALSE} otherwise.
      \vskip1ex
      Missing arguments can be detected by:\\
      - assigning a \texttt{NULL} default value to formal arguments and then calling  \texttt{is.null()} on them,\\
      - calling the function \texttt{missing()} on the arguments.
      \vskip1ex
      The argument \emph{type} can be validated using functions such as \texttt{is.numeric()}, \texttt{is.character()}, etc.
      \vskip1ex
      The function \texttt{return()} returns its argument and terminates futher function execution.
    \column{0.5\textwidth}
      \vspace{-1em}
      <<echo=TRUE,eval=FALSE>>=
# Function valido validates its arguments
valido <- function(input=NULL) {
# Check if argument is valid and return double
  if (is.null(input)) {
    return("valido: input is missing")
  } else if (is.numeric(input)) {
    2*input
  } else cat("valido: input not numeric")
}  # end valido
valido(3)
valido("a")
valido()
# valido validates arguments using missing()
valido <- function(input) {
# Check if argument is valid and return double
  if (missing(input)) {
    return("valido: input is missing")
  } else if (is.numeric(input)) {
    2*input
  } else cat("valido: input is not numeric")
}  # end valido
valido(3)
valido("a")
valido()
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Validating Assertions Inside Functions}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      If assertions about variables inside a function are \texttt{FALSE}, then \texttt{stop()} can be called to halt its execution.
      \vskip1ex
      Calling \texttt{stop()} is preferable to calling \texttt{return()}, or inserting \texttt{cat()} statements into the code.
      \vskip1ex
      Using \texttt{stop()} inside a function allows calling the function \texttt{traceback()}, if an error was produced.
      \vskip1ex
      The function \texttt{traceback()} prints the call stack, showing the function that produced the \emph{error} condition.
      \vskip1ex
      \texttt{cat()} statements inside the function body provide information about the state of its variables.
    \column{0.5\textwidth}
      \vspace{-1em}
            <<echo=TRUE,eval=FALSE>>=
# valido() validates its arguments and assertions
valido <- function(input) {
# Check if argument is valid and return double
  if (missing(input)) {
    stop("valido: input is missing")
  } else if (!is.numeric(input)) {
    cat("input =", input, "\n")
    stop("valido: input is not numeric")
  } else 2*input
}  # end valido
valido(3)
valido("a")
valido()
      @
      \vspace{-2em}
      <<echo=TRUE,eval=FALSE>>=
# Print the call stack
traceback()
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Validating Assertions Using \texttt{stopifnot()}}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      \texttt{R} provides robust validation and debugging tools through \emph{type} validation functions, and functions \texttt{missing()}, \texttt{stop()}, and \texttt{stopifnot()}.
      \vskip1ex
      If the argument to function \texttt{stopifnot()} is \texttt{FALSE}, then it produces an \emph{error} condition, and halts function execution.
      \vskip1ex
      \texttt{stopifnot()} is a convenience wrapper for \texttt{stop()}, and eliminates the need to use \texttt{if ()} statements.
      \vskip1ex
      \texttt{stopifnot()} is often used to check the validity of function arguments.
      \vskip1ex
      \texttt{stopifnot()} can be inserted anywhere in the function body in order to check assertions about its variables.
    \column{0.5\textwidth}
      \vspace{-1em}
      <<echo=TRUE,eval=FALSE>>=
valido <- function(input) {
# Check argument using long form '&&' operator
  stopifnot(!missing(input) && is.numeric(input))
  2*input
}  # end valido
valido(3)
valido()
valido("a")
valido <- function(input) {
# Check argument using logical '&' operator
  stopifnot(!missing(input) & is.numeric(input))
  2*input
}  # end valido
valido()
valido("a")
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Validating Function Arguments and Assertions}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      The functions \texttt{stop()} and \texttt{stopifnot()} halt function execution and produce \emph{error} conditions if certain assertions are \texttt{FALSE}.
      \vskip1ex
      The \emph{type} validation functions, such as \texttt{is.numeric()}, \texttt{is.na()}, etc., and \texttt{missing()}, allow for validation of arguments and variables inside functions.
      \vskip1ex
      \texttt{cat()} statements can provide information about the state of variables inside a function.
      \vskip1ex
      \texttt{cat()} statements don't return values, so they provide information even when a function produces an \texttt{error}.
    \column{0.5\textwidth}
      \vspace{-1em}
      <<echo=TRUE,eval=FALSE>>=
# sumtwo() returns the sum of its two arguments
sumtwo <- function(input1, input2) {  # Even more robust
# Check if at least one argument is not missing
  stopifnot(!missing(input1) &&
              !missing(input2))
# Check if arguments are valid and return sum
  if (is.numeric(input1) && is.numeric(input2)) {
    input1 + input2  # Both valid
  } else if (is.numeric(input1)) {
    cat("input2 is not numeric\n")
    input1  # input1 is valid
  } else if (is.numeric(input2)) {
    cat("input1 is not numeric\n")
    input2  # input2 is valid
  } else {
    stop("none of the arguments are numeric")
  }
}  # end sumtwo
sumtwo(1, 2)
sumtwo(5, 'a')
sumtwo('a', 5)
sumtwo('a', 'b')
sumtwo()
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{The \texttt{R} Debugger Facility}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      The function \texttt{debug()} flags a function for future debugging, but doesn't invoke the debugger.
      \vskip1ex
      After a function is flagged for debugging with the call \texttt{"debug(myfun)"}, then the function call \texttt{"myfun()"} automatically invokes the debugger (browser).
      \vskip1ex
      When the debugger is first invoked, it prints the function code to the console, and produces a \emph{browser} prompt: \texttt{"Browse[2]>"}.
      \vskip1ex
      Once inside the debugger, the user can execute the function code one command at a time by pressing the \emph{Enter} key.
      \vskip1ex
      The user can examine the function arguments and variables with standard \texttt{R} commands, and can also change the values of objects or create new ones.
      \vskip1ex
      The command \texttt{"c"} executes the remainder of the function code without pausing.
      \vskip1ex
      The command \texttt{"Q"} exits the debugger (browser).
      \vskip1ex
      The call \texttt{"undebug(myfun)"} at the \texttt{R} prompt unflags the function for debugging.
    \column{0.5\textwidth}
      \vspace{-1em}
      <<echo=TRUE,eval=FALSE>>=
# Flag "valido" for debugging
debug(valido)
# Calling "valido" starts debugger
valido(3)
# unflag "valido" for debugging
undebug(valido)
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Debugging Using \texttt{browser()}}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      As an alternative to flagging a function for debugging, the user can insert the function \texttt{browser()} into the function body.
      \vskip1ex
      \texttt{browser()} pauses the execution of a function and invokes the debugger (browser) at the point where \texttt{browser()} was called.
      \vskip1ex
      Once inside the debugger, the user can execute all the same browser commands as when using \texttt{debug()}.
      \vskip1ex
      \texttt{browser()} is usually inserted just before the command that is suspected of producing an \emph{error} condition.
      \vskip1ex
      Another alternative to flagging a function for debugging, or inserting \texttt{browser()} calls, is setting the \texttt{"error"} option equal to \texttt{"recover"}.
      \vskip1ex
      Setting the \texttt{"error"} option equal to \texttt{"recover"} automatically invokes the debugger when an \emph{error} condition is produced.
    \column{0.5\textwidth}
      \vspace{-1em}
      <<echo=TRUE,eval=FALSE>>=
valido <- function(input) {
  browser()  # Pause and invoke debugger
# Check argument using long form '&&' operator
  stopifnot(!missing(input) && is.numeric(input))
  2*input
}  # end valido
valido()  # Invokes debugger
options("error")  # Show default NULL "error" option
options(error=recover)  # Set "error" option to "recover"
options(error=NULL)  # Set back to default "error" option
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Using the Debugger in \protect\emph{RStudio}}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      \emph{RStudio} has several built-in debugging facilities that complement those already installed in \texttt{R}:
      \begin{itemize}
        \item toggling breakpoints, instead of inserting \texttt{browser()} commands,
        \item stepping into functions,
        \item environment pane with environment stack, instead of calling \texttt{ls()},
        \item traceback pane, instead of calling \texttt{traceback()},
      \end{itemize}
      \emph{RStudio} provides an online debugging tutorial:
      \hskip1em\url{https://support.rstudio.com/hc/en-us/articles/205612627-Debugging-with-RStudio}
    \column{0.5\textwidth}
      \vspace{-1em}
      \includegraphics[width=0.5\paperwidth]{image/rstudio_debug.png}
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Handling Exception Conditions}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      The function \texttt{tryCatch()} executes functions and expressions, and handles any \emph{exception conditions} produced when they are evaluated.
      \vskip1ex
      \texttt{tryCatch()} first evaluates its \texttt{"expression"} argument.
      \vskip1ex
      If no error or warning \texttt{condition} is produced then \texttt{tryCatch()} just returns the value of the expression.
      \vskip1ex
      If an \texttt{exception condition} is produced then \texttt{tryCatch()} invokes error and warning \emph{handlers} and executes other expressions to provide information about the \texttt{exception condition}.
      \vskip1ex
      If a \emph{handler} is provided to \texttt{tryCatch()} then the error is captured by the \emph{handler}, instead of being broadcast to the console.
      \vskip1ex
      At the end, \texttt{tryCatch()} evaluates the expression provided to the \texttt{finally} argument.
    \column{0.5\textwidth}
      \vspace{-1em}
      <<echo=TRUE,eval=FALSE>>=
str(tryCatch)  # Get arguments of tryCatch()
tryCatch(  # Without error handler
  {  # Evaluate expressions
    numv <- 101  # Assign
    stop('my error')  # Produce error
  },
  finally=print(paste("numv=", numv))
)  # end tryCatch

tryCatch(  # With error handler
  {  # Evaluate expressions
    numv <- 101  # Assign
    stop('my error')  # Produce error
  },
  # Error handler captures error condition
  error=function(error_cond) {
    print(paste("error handler: ", error_cond))
  },  # end error handler
  # Warning handler captures warning condition
  warning=function(warning_cond) {
    print(paste("warning handler: ", warning_cond))
  },  # end warning handler
  finally=print(paste("numv=", numv))
)  # end tryCatch
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Error Conditions in Loops}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      If an \emph{error} occurs in an \texttt{apply()} loop, then the loop exits without returning any result.
      \vskip1ex
      \texttt{apply()} collects the values returned by the function supplied to its \texttt{FUN} argument, and returns them only after the loop is finished.
      \vskip1ex
      If one of the function calls produces an error, then the loop is interrupted and \texttt{apply()} exits without returning any result.
      \vskip1ex
      The function \texttt{tryCatch()} captures errors, allowing loops to continue after the error \texttt{condition}.
    \column{0.5\textwidth}
      \vspace{-1em}
      <<echo=TRUE,eval=FALSE>>=
# Apply loop without tryCatch
apply(matrix(1:5), 1, function(numv) {  # Anonymous function
    stopifnot(!(numv = 3))  # Check for error
    # Broadcast message to console
    cat("(cat) numv =", numv, "\n")
    # Return a value
    paste("(return) numv =", numv)
  }  # end anonymous function
)  # end apply
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Exception Handling in Loops}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      If the body of the function supplied to the \texttt{FUN} argument is wrapped in \texttt{tryCatch()}, then the loop can finish without interruption and return its results.
      \vskip1ex
      The messages produced by \emph{errors} and \emph{warnings} can be caught by \emph{handlers} (functions) that are supplied to \texttt{tryCatch()}.
      \vskip1ex
      The \emph{error} and \emph{warning} messages are bound (passed) to the formal arguments of the \emph{handler} functions that are supplied to \texttt{tryCatch()}.
      \vskip1ex
      \texttt{tryCatch()} always evaluates the expression provided to the \texttt{finally} argument, even after an \emph{error} occurs.
    \column{0.5\textwidth}
      \vspace{-1em}
      <<echo=TRUE>>=
# Apply loop with tryCatch
apply(as.matrix(1:5), 1, function(numv) {  # Anonymous function
    tryCatch(  # With error handler
      {  # Body
        stopifnot(numv != 3)  # Check for error
        # Broadcast message to console
        cat("(cat) numv =", numv, "\t")
        # Return a value
        paste("(return) numv =", numv)
      },
      # Error handler captures error condition
      error=function(error_cond)
        paste("handler: ", error_cond),
      finally=print(paste("(finally) numv =", numv))
    )  # end tryCatch
  }  # end anonymous function
)  # end apply
      @
  \end{columns}
\end{block}

\end{frame}


\end{document}
